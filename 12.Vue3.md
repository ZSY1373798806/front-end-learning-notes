## Vue 3 核心知识整理

### 1. 生命周期

#### 生命周期阶段

| 阶段   | 钩子函数                          | 说明                                                         |
| ------ | --------------------------------- | ------------------------------------------------------------ |
| 初始化 | `setup()`                         | 代替 `beforeCreate` / `created`，用于初始化响应式数据、方法等；选项式 API 兼容旧写法 |
| 挂载   | `onBeforeMount` / `onMounted`     | 挂载前/挂载后执行，可操作 DOM                                |
| 更新   | `onBeforeUpdate` / `onUpdated`    | 响应式数据更新前/后触发                                      |
| 卸载   | `onBeforeUnmount` / `onUnmounted` | 卸载前/后执行，可做清理操作                                  |
| 其它   | `onErrorCaptured`                 | 捕获子组件错误，可返回 `false` 阻止冒泡                      |
| 其它   | `onActivated` / `onDeactivated`   | `<keep-alive>` 组件激活/停用时调用                           |
| 其它   | `onServerPrefetch`                | SSR 期间异步获取数据                                         |
| 其它   | `onRenderTracked`                 | 跟踪渲染依赖                                                 |
| 其它   | `onRenderTriggered`               | 响应式变更触发渲染                                           |

#### 生命周期执行顺序

- **挂载阶段**：
   `父 onBeforeMount → 子 onBeforeMount → 子 onMounted → 父 onMounted`
- **更新阶段**：
   `父 onBeforeUpdate → 子 onBeforeUpdate → 子 onUpdated → 父 onUpdated`
- **卸载阶段**：
   `父 onBeforeUnmount → 子 onBeforeUnmount → 子 onUnmounted → 父 onUnmounted`

### 组件通信

- #### Props/Emits

  ```typescript
  interface Props {
     	prop1: string;
      prop2?: number;
  }
  const props = defineProps<Props>();
  
  interface CustomEmit {
      (e: 'click'): void;
    	(e: 'change', index: number)?: void;
  }
  const emit = defineEmits<CustomEmit>();
  ```

### 2. 组件通信

#### Props / Emits

```js
interface Props {
  prop1: string;
  prop2?: number;
}
const props = defineProps<Props>();

interface CustomEmit {
  (e: 'click'): void;
  (e: 'change', index: number): void;
}
const emit = defineEmits<CustomEmit>();
```

------

### 3. Ref

#### 使用场景

- 管理基本类型数据
- 需要明确的数据引用（传入函数仍保持响应性）

#### 为什么使用 `.value`

- 统一处理基本类型与对象
- 基本类型无法通过 Proxy 代理，`ref` 用 `{ value: xxx }` 封装实现响应式

#### 底层实现示意

```js
function ref(value) {
  return {
    __v_isRef: true,
    get value() { track(this, 'value'); return value; },
    set value(newVal) { value = newVal; trigger(this, 'value'); }
  }
}
```

#### 防抖实现示例

```js
function debouncedRef(value, delay = 200) {
  let timeout;
  return customRef((track, trigger) => ({
    get() {
      track();
      return value;
    },
    set(newVal) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        value = newVal;
        trigger();
      }, delay);
    }
  }))
}

// 使用
const text = debouncedRef('', 500);
```

------

### 4. Reactive

#### 使用场景

- 管理复杂对象/数组
- 避免频繁使用 `.value`
- 深层嵌套数据响应式

#### 局限性与解决方案

- 无法直接替换整个对象：

```js
let obj = reactive({ a: 1 });
obj = { a: 2 }; // 响应式丢失
```

- 解决方案：

```js
Object.assign(obj, { a: 2 }); // 保持响应性
const objRef = ref({ a: 1 }); // 替换整个对象时响应式有效
```

- 解构 reactive 对象保持响应性：

```js
const state = reactive({ count: 0, name: 'Vue' });
const { count, name } = toRefs(state);
count.value++; // 响应式生效
```

------

### 5. 响应式原理

- **ref**：
  - 基本类型通过 `RefImpl` 类实现，内部使用 getter/setter
  - 对象类型自动转为 reactive 代理
- **reactive**：
  - 基于 Proxy 代理整个对象，递归处理嵌套数据
  - get 时调用 `track()` 收集依赖，set 时调用 `trigger()` 触发更新

### 6. ref / toRef / toRefs 区别

| 方法                 | 用途                         | 示例                                    |
| -------------------- | ---------------------------- | --------------------------------------- |
| `ref(value: T)`      | 创建独立响应式引用           | `const count = ref(0); count.value++`   |
| `toRef(object, key)` | 创建对象属性的响应式引用     | `const nameRef = toRef(state, 'name');` |
| `toRefs(object)`     | 将对象所有属性转为响应式引用 | `const { name, age } = toRefs(state);`  |

### 7. 插槽（Slot）

#### 1. 什么是插槽（Slot）

- 插槽是一种 **组件内容分发机制**，允许父组件向子组件传递 **模板内容**。
- 插槽本质上是父组件提供内容，子组件决定渲染位置。

#### 2. 普通插槽（默认插槽）

父组件传入内容，子组件默认渲染：

```vue
<!-- Child.vue -->
<template>
  <div class="child">
    <slot>默认内容</slot>
  </div>
</template>

<!-- Parent.vue -->
<Child>
  <p>父组件传入内容</p>
</Child>
```

- 如果父组件不传内容，显示 `<slot>` 内的默认内容。
- 单个 `<slot>`，称为 **默认插槽**。

#### 3. 具名插槽（Named Slot）

子组件可以定义多个插槽，父组件按名称提供内容：

```vue
<!-- Child.vue -->
<template>
  <header><slot name="header">默认头部</slot></header>
  <main><slot>默认主体</slot></main>
  <footer><slot name="footer">默认底部</slot></footer>
</template>

<!-- Parent.vue -->
<Child>
  <template #header>
    <h1>这是头部内容</h1>
  </template>
  
  <p>默认主体内容</p>
  
  <template #footer>
    <p>底部内容</p>
  </template>
</Child>
```

- `#` 是 `v-slot` 的语法糖。
- 可以有多个具名插槽，也可以和默认插槽混用。

#### 4. 作用域插槽（Scoped Slot）

- 父组件可以从子组件获取数据，用于动态渲染。
- 子组件通过 `<slot :prop="value">` 将数据暴露给父组件。
- 父组件通过 `v-slot="{ prop }"` 或 `#default="{ prop }"` 接收。

```vue
<!-- Child.vue -->
<template>
  <ul>
    <slot v-for="item in list" :item="item" :index="item.id" :key="item.id"></slot>
  </ul>
</template>

<script setup>
const list = [
  { id: 1, name: 'A' },
  { id: 2, name: 'B' }
];
</script>

<!-- Parent.vue -->
<Child v-slot="{ item, index }">
  <li>{{ index }}: {{ item.name }}</li>
</Child>
```

- 父组件通过解构子组件暴露的数据进行渲染。
- 适用于 **列表渲染、动态内容定制**。

#### 5. 插槽总结

| 类型       | 特点                 | 使用场景                               |
| ---------- | -------------------- | -------------------------------------- |
| 默认插槽   | 单个 `<slot>`        | 子组件只需一个可插入内容位置           |
| 具名插槽   | `<slot name="xxx">`  | 子组件有多个内容区域                   |
| 作用域插槽 | `<slot :data="xxx">` | 子组件向父组件暴露数据，实现自定义渲染 |

------

### 8. Vue Router（组合式 API）

- `useRouter()` → 获取路由实例，替代 `this.$router`
- `useRoute()` → 获取当前路由对象，替代 `this.$route`
