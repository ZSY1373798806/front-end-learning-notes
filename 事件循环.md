### 浏览器事件循环 & 任务
- 概念
	js是单线程的；
	为了防止一个函数执行时间过长，阻塞后面的代码；
	会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列；
	异步队列有分为宏任务队列和微任务队列；
	宏任务的执行时间较长，微任务要优先于宏任务执行；
	当主线程结束，先执行准备好的微任务，再去执行准备好的宏任务；
	一个轮询结束；
- 任务
    - 宏任务
        setImmediate，setTimeout，setInterval，I/O，requestAnimationFrame
    - 微任务
        Promise.then，MutationObserver，queueMicrotask
        	MutationObserver（创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用）
        	// 选择需要观察变动的节点
			const targetNode = document.getElementById('some-id');
			// 观察器的配置（需要观察什么变动）
			const config = { attributes: true, childList: true, subtree: true };
        	// 创建一个观察器实例并传入回调函数
            const observer = new MutationObserver(callback);
            // 以上述配置开始观察目标节点
            observer.observe(targetNode, config);
            // 之后，可停止观察
            observer.disconnect();
    - 事件循环
        - 运行机制
            先执行栈中的内容，栈中的内容执行后，执行微任务；
            微任务清空后再执行宏任务；
            先取出一个宏任务，在去执行微任务；
            然后再取宏任务，清空微任务；
            以此不断循环；
            事件循环是由js的宿主环境（浏览器）来实现的
        - 事件循环步骤
            - 函数入栈，当栈中执行到异步任务时，将他丢给webapis（其它线程），接着执行同步任务，直到栈清空；
            - 在此期间webapis（其它线程）完成这个事件，把回调函数放入队列中等待执行（微 =》 微队列，宏 =》宏队列）
            - 执行栈为空时，事件循环把微任务队列清空；
            - 微任务队列清空后，进入宏任务队列，取宏任务队列第一项任务，放到栈中执行；
            - 执行完成后，查看是否有微任务队列，有的话，再次清空微任务队列；
            - 微任务队列清空后，再次取宏任务队列第一项，依次循环执行；
            - 如此反复，直到清空所有的任务
            ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220208235541.png)
            
### Node中的事件循环
- 原理	
	采用V8作为js的解析引擎；
	I/O处理方面使用自己设计的libuv，是一个基于事件驱动的跨平台抽象层；封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现