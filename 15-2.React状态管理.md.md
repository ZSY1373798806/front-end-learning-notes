# 一、Redux Toolkit (RTK) 核心概念

Redux Toolkit 是官方推荐的 Redux 工具集，目的是 **减少模板代码**、提高开发效率，同时保证 Redux 的最佳实践。

### 1. 核心原则

1. **单一状态树**：应用所有 state 存储在 store 中。
2. **不可变状态**：通过 `immer` 内部机制，允许直接写“可变”代码，保证不可变性。
3. **纯函数 reducer**：state 更新逻辑通过 reducer 完成。

### 2. RTK 优势

- 简化模板代码（无需手写 switch case）
- 内置 thunk，方便处理异步逻辑
- 集成 DevTools
- 提供 `createSlice`、`configureStore` 等便捷 API

------

# 二、核心 API 及用法

### 1. `configureStore`

- 用于创建 Redux store，自动集成中间件和 DevTools。

```js
import { configureStore } from '@reduxjs/toolkit'
import counterReducer from './counterSlice'

const store = configureStore({
  reducer: {
    counter: counterReducer,
    user: userReducer
  }
})
```

------

### 2. `createSlice`

- 自动生成 reducer 和 action
- 内置 `immer`，允许“直接修改” state

```js
import { createSlice } from '@reduxjs/toolkit'

const counterSlice = createSlice({
  name: 'counter',
  initialState: { count: 0 },
  reducers: {
    increment: state => { state.count += 1 },   // 可直接修改
    decrement: state => { state.count -= 1 },
    incrementByAmount: (state, action) => { state.count += action.payload }
  }
})

export const { increment, decrement, incrementByAmount } = counterSlice.actions
export default counterSlice.reducer
```

**调用方式：**

```js
store.dispatch(increment())
store.dispatch(incrementByAmount(5))
```

------

### 3. 同步处理

- `createSlice` 中的 reducers 默认都是同步的
- 调用时直接 `dispatch(action)` 即可

------

### 4. 异步处理（`createAsyncThunk`）

- 封装异步逻辑，自动生成 pending / fulfilled / rejected 状态

```js
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'

// 异步 action
export const fetchUser = createAsyncThunk(
  'user/fetchUser',
  async (userId, thunkAPI) => {
    const res = await fetch(`/api/users/${userId}`)
    return res.json()
  }
)

const userSlice = createSlice({
  name: 'user',
  initialState: { data: null, loading: false, error: null },
  reducers: {},
  extraReducers: builder => {
    builder
      .addCase(fetchUser.pending, state => { state.loading = true })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.loading = false
        state.data = action.payload
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.loading = false
        state.error = action.error.message
      })
  }
})

export default userSlice.reducer
```

------

### 5. 多 Slice 管理

- 将不同功能拆成多个 slice，`configureStore` 统一管理
- 支持命名空间，避免 action 重名

```js
const store = configureStore({
  reducer: {
    counter: counterSlice.reducer,
    user: userSlice.reducer
  }
})
```

**组件中使用：**

```js
import { useSelector, useDispatch } from 'react-redux'
import { increment } from './counterSlice'
import { fetchUser } from './userSlice'

const dispatch = useDispatch()
const count = useSelector(state => state.counter.count)
const userData = useSelector(state => state.user.data)

dispatch(increment())
dispatch(fetchUser(1))
```

------

# 三、RTK 常用组合

1. **同步 + 异步混合**

```js
const counterSlice = createSlice({
  name: 'counter',
  initialState: { count: 0, loading: false },
  reducers: {
    reset: state => { state.count = 0 }
  },
  extraReducers: builder => {
    builder
      .addCase(fetchSomeData.pending, state => { state.loading = true })
      .addCase(fetchSomeData.fulfilled, (state, action) => {
        state.loading = false
        state.count += action.payload
      })
  }
})
```

1. **多个 slice 联动**

- 在异步 thunk 中使用 `thunkAPI.dispatch` 调用另一个 slice 的 action

```js
export const fetchAndUpdate = createAsyncThunk(
  'data/fetchAndUpdate',
  async (_, thunkAPI) => {
    const data = await fetch('/api/data').then(res => res.json())
    thunkAPI.dispatch(counterSlice.actions.incrementByAmount(data.count))
  }
)
```

------

# 四、常见面试题

### 面试题 1：Redux Toolkit 和原生 Redux 区别？

- RTK 简化模板代码，自动生成 actions/reducers
- 内置 thunk，支持异步
- 内置 Immer，直接修改 state 即可
- 默认集成 DevTools

------

### 面试题 2：`createSlice` 与 `createAsyncThunk` 的作用？

- `createSlice`：定义 slice、reducers、actions
- `createAsyncThunk`：封装异步逻辑，自动生成 pending/fulfilled/rejected

------

### 面试题 3：RTK 如何处理异步请求？

- 使用 `createAsyncThunk`
- 或自定义 thunk：返回函数 `(dispatch, getState) => {...}`

------

### 面试题 4：多 slice 怎么管理？

- 每个功能拆一个 slice
- `configureStore({ reducer: { slice1, slice2 } })`
- 组件使用 `useSelector(state => state.sliceX.xxx)`

------

### 面试题 5：为什么 RTK 允许直接修改 state？

- 内置 `immer`，在内部生成新的不可变对象
- 开发者可写可变逻辑，提高可读性

------

### 面试题 6：同步 action 和异步 action 的区别？

| 类型        | 定义方式                 | 调用方式              | 适用场景            |
| ----------- | ------------------------ | --------------------- | ------------------- |
| 同步 action | createSlice reducers     | dispatch(action)      | 立即更新 state      |
| 异步 action | createAsyncThunk / thunk | dispatch(asyncAction) | API 请求 / 异步逻辑 |