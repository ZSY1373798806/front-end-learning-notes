## Vue
## 1️⃣ 生命周期（Lifecycle）

### 阶段与钩子

| 阶段          | 钩子                      | 特点                               |
| ------------- | ------------------------- | ---------------------------------- |
| 创建(create)  | beforeCreate → created    | 数据未初始化 vs 数据已可用但未挂载 |
| 挂载(mount)   | beforeMount → mounted     | 可发请求 vs 可操作 DOM             |
| 更新(update)  | beforeUpdate → updated    | 数据变化触发                       |
| 销毁(destroy) | beforeDestroy → destroyed | 可清理手动资源 vs 已销毁           |

**执行顺序注意点：**

- 组件创建时父优先，子后（父beforeCreate → 子beforeCreate → … → 子mounted → 父mounted）
- 更新时：父beforeUpdate → 子beforeUpdate → 子updated → 父updated
- 销毁时：父beforeDestroy → 子beforeDestroy → 子destroyed → 父destroyed

> 面试常考：父子执行顺序、生命周期钩子作用场景。

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220211225838.png)

## 2️⃣ Vue.use 原理

一、`Vue.use` 的作用

- 用来 **安装插件**（plugin），避免重复安装。
- 插件一般是给 Vue 添加 **全局功能**，比如：
  - 给 `Vue.prototype` 挂载方法；
  - 注册全局组件；
  - 注册全局指令；
  - 混入全局配置。

二、源码简化版（Vue 2.x）

```js
Vue.use = function (plugin) {
  const installedPlugins = this._installedPlugins || (this._installedPlugins = [])

  // 避免重复安装
  if (installedPlugins.indexOf(plugin) > -1) {
    return this
  }

  // 取出后续参数，传给 install
  const args = toArray(arguments, 1)
  args.unshift(this) // 把 Vue 传给 install

  // 插件的 install 方法
  if (typeof plugin.install === 'function') {
    plugin.install.apply(plugin, args)
  } else if (typeof plugin === 'function') {
    plugin.apply(null, args)
  }

  installedPlugins.push(plugin)
  return this
}
```

三、核心逻辑

1. **维护已安装插件的列表**
   - 通过 `Vue._installedPlugins` 数组，避免多次调用 `Vue.use` 重复安装。
2. **处理 install 方法**
   - 如果插件对象有 `install` 方法 → 调用 `plugin.install(Vue, ...args)`
   - 如果插件本身是函数 → 直接调用 `plugin(Vue, ...args)`
3. **传入参数**
   - 默认第一个参数是 `Vue` 构造函数；
   - 后面是 `Vue.use(plugin, options)` 传入的额外参数。

四、插件示例

```js
// 定义一个插件
const MyPlugin = {
  install(Vue, options) {
    // 1. 给原型挂方法
    Vue.prototype.$hello = function () {
      console.log('Hello from plugin!')
    }

    // 2. 注册全局组件
    Vue.component('my-component', {
      template: '<div>我是全局组件</div>'
    })
  }
}

// 使用插件
Vue.use(MyPlugin, { someOption: true })

// 使用效果
new Vue({
  created() {
    this.$hello() // Hello from plugin!
  }
})
```

------

✅ 总结一句：
 `Vue.use` 就是一个 **插件注册器**，确保只执行一次，并且给插件传入 `Vue` 实例和参数。插件本质就是通过 **扩展 Vue 原型 / 全局注册** 来增强 Vue 功能。

## 3️⃣ nextTick 原理

- **作用**：保证在 DOM 更新后执行回调。

   - **DOM 更新是在 flushSchedulerQueue 里完成的**

   - **nextTick 的回调是在 DOM 更新完成之后才会触发的**

     ```js
     数据变更
        ↓
     dep.notify() → watcher.update()
        ↓
     queueWatcher(watcher)   // 加入更新队列
        ↓
     nextTick(flushSchedulerQueue)   // 异步等待
        ↓
     flushSchedulerQueue()   // 批量执行 watcher.run() → 触发 patch → 更新 DOM
        ↓
     DOM 已经更新完成
        ↓
     flushCallbacks()   // 执行所有 nextTick 回调
     ```

     

- **为什么不能直接拿到 DOM？**
   Vue 是异步渲染，数据修改同步执行，DOM 更新异步。

- **核心原理**：微任务 + 宏任务队列

| 方法             | 优先级 | 说明              |
| ---------------- | ------ | ----------------- |
| Promise          | 高     | 微任务，性能最优  |
| MutationObserver | 次高   | 监听 DOM 变动触发 |
| setImmediate     | 中     | IE 专属           |
| setTimeout       | 低     | 宏任务，兜底      |

- #### 原理

  - 利用事件循环
    - Vue的nextTick实现利用了JavaScript的事件循环机制；在浏览器环境中，JavaScript是单线程执行的，事件循环负责管理异步任务的执行顺序
    - Vue将nextTick的回调函数放入微任务或宏任务队列
    - 当当前执行栈为空时，事件循环会从任务队列中取出任务执行；如果微任务队列中有任务，会先执行微任务队列中的任务，然后在执行宏任务队列中的任务；这样可以确保nextTick的回调函数在DOM更新之后执行
  - 内部实现
    - Vue内部维护了一个异步任务队列，用于存储nextTick的回调函数；当调用nextTick时，回调函数会被添加到这个队列中
    - Vue在更新DOM之后，会检查这个异步任务队列是否为空；如果不为空，会取出队列中的第一个任务并执行
    - 这样就保证了在DOM更新完成之后，nextTick的回调函数能够按照调用的顺序依次执行

  ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220219161533.png)

- **流程**：

  - 回调加入 `callbacks` 队列
  - `timerFunc()` 放入微/宏任务
  - 执行队列，更新 DOM 后回调触发

> 面试问法：`nextTick` 与 `setTimeout(fn,0)` 的区别 → nextTick 优先微任务，性能更高，渲染更精准。

> DOM更新是同步的；UI渲染是在所有微任务完成之后，是异步的；我们在nextTick里拿到的数据，是更新后的DOM，因为diff算法和patch补丁已经算出来了，并作用在DOM上

```js
// Vue 源码节选（next-tick.js）
if (typeof Promise !== 'undefined') {
  // 优先使用 Promise
  const p = Promise.resolve()
  timerFunc = () => p.then(flushCallbacks)
} else if (typeof MutationObserver !== 'undefined') {
  // 降级方案 1：MutationObserver
  const observer = new MutationObserver(flushCallbacks)
  // 监听一个文本节点，通过修改内容触发回调
} else if (typeof setImmediate !== 'undefined') {
  // 降级方案 2：setImmediate（IE）
  timerFunc = () => setImmediate(flushCallbacks)
} else {
  // 最终降级：setTimeout
  timerFunc = () => setTimeout(flushCallbacks, 0)
}

/**
 * 做了3件事
 * 1、将pending置为false
 * 2、清空callbacks数组
 * 3、执行callbacks数组中的每一个函数（比如flushSchedulerQueue、用户调用nextTick传递的回调函数）
 */
function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  /* 遍历callbacks数组，执行其中存储的每个flushSchedulerQueue函数 */
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

/**
 * 完成两件事
 * 1、用try catch包装flushSchedulerQueue函数，然后将其放入callbacks数组
 * 2、如果pending为false，表示现在浏览器的任务队列中没有flushCallbacks函数；
 *  如果pending为true，则表示浏览器的任务队列中已经被放入了flushCallbacks函数；
 *  待执行flushCallbacks函数时，pending会被再次置为false，表示下一个flushCallbacks函数可以进入浏览器的任务队列了
 * pending：保证在同一时刻，浏览器的任务队列只有一个flushCallbacks函数
 * @param {*} cb 接收一个回调函数 => flushSchedulerQueue
 * @param {*} ctx 上下文
 * @returns 
 */
/**
 * 流程：
 *  1、把回调函数放入callbacks等待执行
 *  2、将执行的函数放到微任务或宏任务中
 *  3、事件循环到了微任务或宏任务，执行函数依次执行callbacks中的回调
 * 
 * DOM更新是同步的；
 * UI渲染是在所有微任务完成之后，是异步的；
 * 我们在nextTick里拿到的数据，是更新后的DOM，因为diff算法和patch补丁已经算出来的，并作用在DOM上
 */
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  /* 用callbacks数组存储经过包装的cb函数 */
  callbacks.push(() => {
    if (cb) {
      /* 用try catch包装回调函数，便于错误捕获 */
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    /* 执行timerFunc，在浏览器的任务队列中（首选微任务队列）放入flushCallbacks函数 */
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
```

### Vue选项合并策略

## 1️⃣ 概念

- Vue 允许我们在 **实例化 Vue 或创建子组件时传入配置对象**，例如：

```js
const parent = Vue.extend({
  data() { return { a: 1 } },
  methods: { foo() { console.log('parent') } }
})

const child = new parent({
  data() { return { b: 2 } },
  methods: { foo() { console.log('child') } }
})
```

- Vue 内部需要把 **父级选项和子级选项合并**，这就是 **选项合并策略**（`mergeOptions`）。

------

## 2️⃣ 合并规则分类

### （1）对象类型（data, methods, computed, watch）

- **规则**：子对象覆盖父对象的同名属性；如果父子都存在不同属性，合并保留全部。
- **举例**：

```js
const parent = {
  data: { a: 1 },
  methods: { foo() { console.log('parent') } }
}

const child = {
  data: { b: 2 },
  methods: { bar() { console.log('child') } }
}

const merged = Vue.util.mergeOptions(parent, child)
/*
merged.data -> { a:1, b:2 }
merged.methods -> { foo: fn, bar: fn }
*/
```

------

### （2）生命周期钩子（created, mounted 等）

- **规则**：父子钩子合并为 **数组**，依次执行。
- **顺序**：父钩子先执行 → 子钩子后执行
- **示例**：

```js
const parent = { created() { console.log('parent created') } }
const child = { created() { console.log('child created') } }

const merged = Vue.util.mergeOptions(parent, child)
merged.created.forEach(fn => fn())  
// 输出：parent created
//       child created
```

> 面试常考点：钩子执行顺序父优先，且合并为数组。

------

### （3）数组类型（components, directives, filters）

- **规则**：子组件会 **覆盖父组件同名注册**。
- **原因**：同名组件需要被子组件覆盖以实现局部注册。

```js
const parent = { components: { A: {...} } }
const child = { components: { A: {...}, B: {...} } }

const merged = Vue.util.mergeOptions(parent, child)
console.log(merged.components) // { A: child.A, B: child.B }
```

------

### （4）默认策略

- **规则**：子选项优先覆盖父选项（子覆盖父）。
- 常见适用字段：`el`, `propsData`, `name`, `template` 等。

------

## 3️⃣ Vue 内部实现逻辑

Vue 内部核心方法：`mergeOptions(parent, child, vm)`

- 遍历 **父选项和子选项**，根据字段类型调用策略函数 `strats[key]`
- 钩子类字段：数组合并
- 对象类字段：对象合并
- 默认策略：子覆盖父

```js
function mergeOptions(parent, child, vm) {
  const options = {}
  for (const key in parent) mergeField(key)
  for (const key in child) if (!parent.hasOwnProperty(key)) mergeField(key)

  function mergeField(key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

- **strats**：存储各字段的合并策略
   例如：

```js
strats.data = function (parentVal, childVal, vm) { ... }       // data 合并
strats.created = mergeHook                             // 生命周期合并
strats.components = mergeAssets                        // 组件/指令/过滤器合并
```

------

## 4️⃣ 面试高频点

1. 生命周期钩子合并顺序：父 → 子
2. `data` 函数合并：子 `data` 覆盖父 `data`，注意 Vue 2 对对象是 **合并而非替换整个对象**（Vue 3 中 Proxy 可直接覆盖）
3. `methods`、`computed`、`watch` 对象合并：不同属性合并，同名覆盖
4. 全局组件/指令/过滤器注册：子会覆盖父同名注册

### 双向绑定原理

### 一、核心思想

Vue 2 的双向绑定是基于 **数据劫持 (Object.defineProperty)** + **发布-订阅模式 (Dep + Watcher)** 实现的。

一句话总结：
 **数据变化 → 触发 setter → 通知 Dep → Dep 通知 Watcher → Watcher 执行更新函数 → 视图更新**
 **视图变化 (v-model 输入) → 触发事件 → 修改数据 → 再走上面这套流程**

------

## 二、四大核心角色

### 1. **Observer（数据监听器）**

- 用 `Object.defineProperty` 给每个数据属性加上 `getter / setter`。
- 作用：劫持数据的读写。
- 当读取属性时 → 依赖收集（把 Watcher 加到 Dep 中）。
- 当修改属性时 → 通知 Dep 派发更新。

------

### 2. **Dep（依赖收集器）**

- 一个中间调度中心，维护着一组 Watcher。
- 每个响应式属性都会有一个 `Dep` 实例。
- 提供 `depend()`（收集依赖）和 `notify()`（派发更新）。

------

### 3. **Watcher（订阅者）**

- 订阅数据变化，当数据变化时，执行回调更新视图。
- 在实例化时，会读取一次数据，触发 getter，把自己加到 Dep 中。
- 内部有 `update()` 方法，当被通知时调用 → 触发视图更新。

------

### 4. **Compiler（模板编译器）**

- 解析模板中的指令（如 `v-model`、`v-text`、`{{ }}` 表达式）。
- 为每个绑定的节点生成更新函数，并且创建对应的 Watcher。
- 当数据变化时，Watcher 通知这些更新函数去更新 DOM。

------

## 三、运行流程

1. **初始化时**

   - `Observer` 劫持数据，为属性设置 getter/setter。
   - `Compiler` 解析模板，把变量替换成数据，并为变量创建 `Watcher`。
   - `Watcher` 在创建时会读取一次数据（触发 getter），从而被 `Dep` 收集。

2. **数据变化时**

   - 修改数据属性 → 触发 `setter` → 调用 `dep.notify()`。
   - `Dep` 通知所有 Watcher → 调用 `update()` → 执行对应的 DOM 更新函数。

3. **视图变化时**

   - 用户输入（例如 `v-model` 绑定的 input）触发 `input` 事件。
   - 事件回调里更新数据 → 数据变化再走 Observer → Dep → Watcher → 视图更新。

   ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220212103055.png)

## 四、总结一句

Vue 2 的双向绑定就是：

- **Observer** 劫持数据属性；
- **Dep** 收集和派发更新；
- **Watcher** 订阅数据变化，执行更新函数；
- **Compiler** 负责解析模板，把数据和 DOM 绑定起来。

## 五、简化版代码示例

```js
// Dep: 依赖收集器
class Dep {
  constructor() {
    this.subs = []
  }
  addSub(sub) {
    this.subs.push(sub)
  }
  notify() {
    this.subs.forEach(sub => sub.update())
  }
}
// Watcher: 订阅者
class Watcher {
  constructor(obj, key, cb) {
    this.obj = obj
    this.key = key
    this.cb = cb
    Dep.target = this
    this.value = obj[key] // 触发 getter 收集依赖
    Dep.target = null
  }
  update() {
    const newVal = this.obj[this.key]
    if (newVal !== this.value) {
      this.value = newVal
      this.cb(newVal)
    }
  }
}
// Observer: 数据劫持
function observe(obj) {
  Object.keys(obj).forEach(key => {
    let val = obj[key]
    const dep = new Dep()
    Object.defineProperty(obj, key, {
      get() {
        if (Dep.target) dep.addSub(Dep.target)
        return val
      },
      set(newVal) {
        val = newVal
        dep.notify()
      }
    })
  })
}
// 使用
const data = { msg: 'hello' }
observe(data)
// 绑定一个 watcher
new Watcher(data, 'msg', val => {
  console.log('视图更新:', val)
})
data.msg = 'world' // setter → dep.notify → watcher.update → 输出 "视图更新: world"
```

```js
//创建订阅发布者
//1.管理订阅
//2.集体通知
class Dep {
  constructor() {
    this.subs = [];
  }
  //添加订阅
  addSub(sub) {//其实就是watcher对象
    this.subs.push(sub)
  }
  //集体通知
  notify() {
    this.subs.forEach((sub) => {
      sub.update()
    })
  }
}
```
### 数组响应式重写
- 实现
```js
const arrExtend = Object.create(Array.prototype)
// const arrExtend = {}
// arrExtend._proto_=Array.prototype
const arrMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']
arrMethods.forEach(method => {
  const oldMethod = Array.prototype[method]
  const newMethod = function(...args) {
    oldMethod.apply(this, args)
    console.log(`${method} 方法被执行了`)
  }
  arrExtend[method] = newMethod
})
```

### 双向绑定的优点

双向绑定的优点是 **简化代码、提升开发效率、自动同步数据和视图**，尤其适合表单和数据频繁交互的场景。

### template原理和实现
![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209123317.png)

### 虚拟dom
## 1. 虚拟 DOM 概念

- **定义**：虚拟 DOM 是用 **JavaScript 对象** 表示真实 DOM 的一种抽象。
- **目的**：解决直接操作 DOM 的性能低和复杂问题，实现 **高效的视图更新**。
- **更新流程**：

```
数据改变 → 生成新的虚拟 DOM → 计算差异 (diff) → 最小化更新真实 DOM → 视图更新
```

------

## 2. 虚拟 DOM 格式（VNode）

每个节点都是一个 JS 对象，大致结构如下：

```
{
  tag: 'div',           // 标签名
  data: {               // 节点属性、样式、事件等
    class: 'box',
    style: { color: 'red' },
    attrs: { id: 'app' },
    on: { click: handleClick }
  },
  children: [/* 子节点 VNode */],
  text: 'Hello',        // 文本节点内容
  elm: null,            // 对应真实 DOM 节点
  key: 'uniqueKey'      // 提高 diff 算法效率，帮助复用 DOM
}
```

------

## 3. 虚拟 DOM 的优势

1. **无需手动操作 DOM**
   - 逻辑层只关注数据变化，Vue 自动计算最小更新。
2. **提高性能**
   - 比直接操作 DOM 更高效，因为减少了重排（reflow）和重绘（repaint）。
3. **可跨平台**
   - 抽象 DOM 结构，可在不同平台（浏览器、Native、Weex）渲染。
4. **简化开发**
   - 开发者只需关注数据和模板，不必关心 DOM 操作细节。

------

## 4. 为什么要使用虚拟 DOM

- 原生 DOM 操作效率低，尤其是频繁增删节点或修改样式时。
- jQuery/原生操作需要自己手动优化 DOM 更新。
- 虚拟 DOM 可以：
  - 批量计算差异（diff），最小化操作；
  - 保持声明式编程风格；
  - 自动处理复杂更新逻辑。

------

## 5. DOM 遍历与 Diff 算法

### (1) Diff 算法

- Vue 通过 **双端比较 + key 优化** 来判断哪些节点需要更新。
- 核心思想：
  1. 先比较同层节点；
  2. 根据 key 匹配复用节点；
  3. 不同则创建新节点或删除旧节点。

### (2) DOM 遍历方式

- **深度优先**（DFS）：遍历整个虚拟 DOM 树，逐层比较。
- **广度优先**（BFS）：不常用，但有些优化场景可以用。

------

## 6. 虚拟 DOM 实现原理

1. **JS 对象模拟真实 DOM**
   - 每个 VNode 对象都对应真实 DOM 的节点结构。
2. **diff 算法**
   - 比较新旧虚拟 DOM 树，找出节点差异。
3. **patch 算法**
   - 根据 diff 结果，把最小差异更新到真实 DOM。

简化版流程：

```
数据变化
  ↓
新 VNode = render()  // 生成新虚拟 DOM
  ↓
diff(旧 VNode, 新 VNode) // 比较差异
  ↓
patch(差异)  // 更新真实 DOM
```

------

## 7. 举例对比

| 方式           | 优点                      | 缺点                         |
| -------------- | ------------------------- | ---------------------------- |
| jQuery / 原生  | 直接操作 DOM，立即生效    | 频繁操作性能差，逻辑复杂     |
| Vue + 虚拟 DOM | 数据驱动，最小化 DOM 更新 | 初次渲染稍慢，有额外内存开销 |

------

✅ **一句话总结**：
 虚拟 DOM 是 **对真实 DOM 的 JS 抽象**，通过 diff + patch 算法实现 **高效、声明式、可复用的 DOM 更新**，大幅提升前端开发效率和性能。

## 1. Diff 算法概念

- **作用**：比较 **两棵虚拟 DOM 树** 的差异，找出最小的更新操作。
- **核心原则**：
  1. 只比较 **同层级节点**；
  2. 标签名不同 → **直接替换**；
  3. 标签名 + key 相同 → **局部更新**；
  4. 使用 **深度优先遍历**，优先更新子节点（递归调用 `updateChildren`）。

## 2. Diff 遍历策略

- **深度优先遍历（DFS）**：
  1. 先对子节点递归处理；
  2. 再处理相邻节点。
- **子节点 diff**：
  - 如果子节点存在差异 → 局部更新；
  - 如果子节点不存在 → 添加或删除节点。

------

## 3. Patch 函数（核心入口）

`patch(oldVnode, vnode)` 作用：

1. **oldVnode 不存在** → 直接创建新节点。
2. **oldVnode 存在** → 调用 `patchVNode(oldVnode, vnode)`：
   - 调用 `sameVNode(oldVnode, vnode)` 判断是否是同一个节点：
     - 如果 **相同** → 局部 diff；
     - 如果 **不同** → 替换节点，删除老节点。

- 4. patchVNode 方法（局部更新）

    `patchVNode(oldVnode, vnode)` 步骤：

    1. **文本节点更新**
       - 如果 `oldVnode.text !== vnode.text` → 替换文本节点。
    2. **子节点更新**
       - 如果 vnode 没有文本节点 → 进入子节点 diff。
       - 如果 oldCh 和 ch 都存在 → 调用 `updateChildren(oldCh, ch, parentElm)`。
       - 如果 oldCh 不存在，ch 存在 → 清空文本并添加新节点。
       - 如果 oldCh 存在，ch 不存在 → 删除旧节点。
    3. **文本节点清理**
       - oldVnode 有文本，而 vnode 没有 → 清空文本。

    ------

    ## 5. updateChildren 方法（子节点 diff 核心）

    - 核心思想：通过 **双端索引 + key 映射** 最小化 DOM 操作。
    - 步骤：
      1. 给 `oldCh` 和 `ch` 分别分配 `startIndex` 和 `endIndex`。
      2. 遍历 oldCh 和 ch：
         - 比较头尾节点 (`startVnode` / `endVnode`) 是否相同；
         - 相同 → `patchVNode` 递归更新；
         - 不同 → 查找 key 是否存在 → 节点移动或创建；
      3. 当任意一端遍历结束 → 停止 diff 过程；
      4. 剩余节点：
         - oldCh 剩余 → 删除节点；
         - ch 剩余 → 创建节点。

    ------

    ## 6. Diff 算法优化点

    - **key 的作用**：
      - 帮助 Vue 快速找到节点对应关系，避免大量 DOM 重建。
    - **同层比较**：
      - Diff 只在同层节点进行，不会跨层比较，降低算法复杂度（O(n)）。
    - **双端比较**：
      - 从头和尾同时开始匹配，减少移动和查找开销。
    - **最小化 DOM 操作**：
      - 通过 patch + updateChildren 只修改必要节点。

    ------

    ## 7. 面试常考点总结

    | 考点                    | 说明                                   |
    | ----------------------- | -------------------------------------- |
    | diff 只比较同层节点     | 跨层节点不比较，减少复杂度             |
    | key 的作用              | 唯一标识节点，帮助复用和移动节点       |
    | patchVNode 逻辑         | 文本更新 → 子节点 diff → 添加/删除节点 |
    | updateChildren 核心流程 | 双端索引 + key 映射 + 剩余节点处理     |

    ------

    ✅ **一句话总结**：
     Vue 的 diff 算法通过 **同层比较 + key 优化 + 深度优先遍历**，在 `patchVNode` 和 `updateChildren` 中精确计算节点差异，从而实现 **最小化 DOM 更新**。

- ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209204451.png)

### 初始化Vue到最终渲染的整个过程

## 1️⃣ Vue 实例初始化（`new Vue()`）

1. **初始化配置**

   - Vue 构造函数中，会调用 `init` 方法：

     ```
     this._init(options)
     ```

   - `_init` 主要做的事情：

     - 合并用户配置（`options`）和默认配置。
     - 初始化生命周期（`_lifecycle`）、事件系统（`_events`）、响应式数据（`_data`）等。
     - 初始化 `props`、`methods`、`computed`、`watch` 等。

2. **挂载前钩子**

   - `beforeCreate` → `created` 生命周期钩子执行。

------

## 2️⃣ 响应式数据初始化（Observer + Dep）

1. Vue 会对 `data` 做 **数据劫持（Object.defineProperty）**
   - 每个数据属性会被 `Observer` 包装。
   - 数据变化时，会触发对应的 **依赖收集（Dep）**，更新视图。
2. **计算属性（computed）和 watch**
   - computed 会生成一个 **Watcher**，懒执行并缓存值。
   - watch 也是一个 Watcher，监听数据变化。

------

## 3️⃣ 模板编译（Template → Render Function）

1. **编译流程**：
   - `template` → `AST（抽象语法树）` → `Render 函数` → `VNode（虚拟 DOM）`。
   - Vue 2 的编译器把模板编译成 `render` 方法，这样每次渲染都生成 VNode 树。
2. **VNode（虚拟 DOM）**
   - 用 JS 对象表示 DOM 结构。
   - 包含标签、属性、子节点等信息。

------

## 4️⃣ Mount（挂载到 DOM）

1. 调用 `$mount(el)`：
   - 如果 `el` 存在，Vue 会把 VNode 渲染到真实 DOM 上。
   - 创建 **根 Watcher**（渲染 Watcher）：
     - Watcher 会调用 `render` 生成 VNode。
     - 然后通过 `patch` 方法把 VNode 转换成真实 DOM。

------

## 5️⃣ Virtual DOM Diff 与 Patch

1. **初次渲染**
   - VNode → DOM，直接挂载到页面。
2. **数据变化更新**
   - 数据变化触发对应 Watcher。
   - Watcher 调用 `render` 生成新的 VNode。
   - 新旧 VNode 通过 **diff 算法** 比较差异。
   - 只更新有变化的部分，减少 DOM 操作。

------

## 6️⃣ 最终渲染完成

- 页面显示为最终的真实 DOM。
- 后续数据变化，会触发 Watcher → 重新渲染 → diff → patch → DOM 更新。

------

### 🔑 总结流程

```js
new Vue()
  └─ _init() 初始化
      ├─ 生命周期钩子 beforeCreate/created
      ├─ 初始化响应式 data/props/computed/watch
      └─ 事件系统初始化
  └─ template 编译 → render 函数 → VNode
  └─ $mount(el)
      ├─ 创建渲染 Watcher
      ├─ render → VNode
      └─ patch → 真正 DOM
  └─ 数据变化
      └─ Watcher 触发更新
          └─ 新旧 VNode diff → 更新 DOM
```

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220215214130.png)
## 1️⃣ MVVM & MVC

- **MVC（Model-View-Controller）**
  - Model：数据
  - View：视图
  - Controller：控制逻辑
  - 数据变化需要手动更新视图
- **MVVM（Model-View-ViewModel）**
  - Model：数据
  - View：视图
  - ViewModel：数据绑定逻辑
  - 数据变化自动驱动视图更新（双向绑定）

### Proxy & Object.defineProperty
- Proxy
	- Proxy可以直接监听对象而非属性；
	
	- 可以直接监听数组的变化
	
	  ```js
	  const handler = {
	    get(target, prop) {
	      // 拦截所有属性访问
	      return Reflect.get(target, prop);
	    },
	    set(target, prop, value) {
	      // 拦截所有属性设置
	      return Reflect.set(target, prop, value);
	    },
	    deleteProperty(target, prop) {
	      // 拦截属性删除
	      return Reflect.deleteProperty(target, prop);
	    }
	  };
	  
	  const proxy = new Proxy([], handler);
	  ```
	
	  ```js
	  function reactive(obj) {
	    return new Proxy(obj, {
	      get(target, key) {
	        track(target, key); // 依赖收集
	        return Reflect.get(target, key);
	      },
	      set(target, key, value) {
	        const oldValue = target[key];
	        const result = Reflect.set(target, key, value);
	        
	        // 特殊处理数组的 length 属性
	        if (key === 'length' && Array.isArray(target)) {
	          // 触发 length 相关更新
	        } else {
	          // 判断是新增还是修改
	          if (!target.hasOwnProperty(key)) {
	            trigger(target, 'add', key);
	          } else if (oldValue !== value) {
	            trigger(target, 'set', key);
	          }
	        }
	        return result;
	      },
	      deleteProperty(target, key) {
	        const hadKey = target.hasOwnProperty(key);
	        const result = Reflect.deleteProperty(target, key);
	        if (hadKey) {
	          trigger(target, 'delete', key);
	        }
	        return result;
	      }
	    });
	  }
	  ```
	
	- Proxy多达13种拦截方法；
	  get、set、has、deleteProperty、ownKeys、getOwnPropertyDescriptor、
	  defineProperty、preventExtensions、getPrototypeOf、isExtensible、
	  setPrototypeOf、apply、construct
	
	- Proxy返回一个新对象，我们只操作新对象；
	
	- Proxy持续优化；
	
	- 不支持IE；
	
	- Reflect 
	
	  - 1️⃣ Reflect 的作用
	    - 代替一些 `Object` 的方法，更“函数式”操作对象
	    - 返回布尔值表示操作是否成功，而不是抛出错误
	    - 常与 `Proxy` 配合，用于在拦截器里调用默认行为
	
	  - 2️⃣ 常用方法
	
	| 方法                                               | 说明                                                  |
	| -------------------------------------------------- | ----------------------------------------------------- |
	| `Reflect.get(target, prop, receiver)`              | 获取属性值，类似 `target[prop]`                       |
	| `Reflect.set(target, prop, value, receiver)`       | 设置属性值，类似 `target[prop] = value`，返回是否成功 |
	| `Reflect.has(target, prop)`                        | 检查属性是否存在，类似 `prop in target`               |
	| `Reflect.deleteProperty(target, prop)`             | 删除属性，类似 `delete target[prop]`                  |
	| `Reflect.ownKeys(target)`                          | 获取对象自身的所有属性（包括 Symbol）                 |
	| `Reflect.getOwnPropertyDescriptor(target, prop)`   | 获取属性描述符                                        |
	| `Reflect.defineProperty(target, prop, descriptor)` | 定义属性，类似 `Object.defineProperty`                |
	| `Reflect.preventExtensions(target)`                | 阻止对象扩展，类似 `Object.preventExtensions`         |
	| `Reflect.isExtensible(target)`                     | 判断对象是否可扩展                                    |
	| `Reflect.getPrototypeOf(target)`                   | 获取原型，类似 `Object.getPrototypeOf`                |
	| `Reflect.setPrototypeOf(target, proto)`            | 设置原型，类似 `Object.setPrototypeOf`                |
	| `Reflect.apply(target, thisArg, args)`             | 调用函数，类似 `Function.prototype.apply`             |
	| `Reflect.construct(target, args, newTarget)`       | 构造函数调用，类似 `new target(...args)`              |
	
- Object.defineProperty
	- 支持IE9；
	
	- 只能遍历对象属性直接修改；
	
	- 不再优化；
	
	- 不能监听数组
	
	  - 为什么不监听数组下标
	
	    - 性能问题
	
	      - 数组包含大量元素，为每个索引都设置getter/setter会消耗大量内存
	      - 每次数组操作都要遍历整个数组，时间复制度为O(n)
	
	    - 下标不可控
	
	      - 数组长度动态变化，无法预先定义所有索引的响应式
	      - 数组操作（push/pop/shift/unshift）会改变索引位置
	
	    - 监听盲区
	
	      ```js
	      const arr = [1, 2, 3];
	      // Vue2 无法检测到这种直接索引赋值
	      arr[0] = 10; 
	      // Vue2 无法检测到数组长度变化
	      arr.length = 0;
	      ```
	
	    - 无法监听新增、删除
	
	      ```js
	      // 无法检测新增元素
	      arr[3] = 4;
	      // 无法检测元素删除
	      delete arr[0];
	      ```
## 对比总结

| 特性                    | `Object.defineProperty` | `Proxy`            |
| :---------------------- | :---------------------- | :----------------- |
| 数组索引访问/设置       | ❌ 无法监听              | ✅ 完全支持         |
| 数组方法操作 (push/pop) | ⚠️ 需重写方法            | ✅ 原生支持         |
| 数组长度变化            | ❌ 无法监听              | ✅ 支持 length 变更 |
| 新增/删除元素           | ❌ 无法监听              | ✅ 完全支持         |
| 性能表现                | ⚠️ 数组较大时性能差      | ✅ 高效             |
| 嵌套对象处理            | ⚠️ 需要递归初始化        | ✅ 惰性代理         |
| 浏览器兼容性            | ✅ IE9+                  | ❌ 不兼容 IE        |

## 3️⃣ 服务端渲染（SSR）

- **定义**：在服务器生成完整 HTML 片段返回
- **优点**：SEO 好，首屏渲染快
- **缺点**：只能执行 `beforeCreate` 和 `created` 钩子；增加服务器负载
- **工具**：Nuxt.js (`vue-server-renderer`)

### vue常用修饰符
- stop
	阻止冒泡
- prevent
	阻止默认事件（如：a标签的跳转）
- capture
	事件默认是由里往外冒泡；capture作用是由外往里捕获
- self
	点击事件绑定的本身才会触发事件
- once
	事件只执行一次
- passive
	相当于给onscroll事件添加一个.lazy修饰符（@scroll.passive="onScroll"）
- enter
- trim
	去除首尾空格
- number
	将v-model值转成数字
		22aa => 22
		aa22 => aa22（无效）
- lazy
	改变输入框的值时value不会改变；当光标离开输入框时，v-model绑定的值value才会改变
- sync
	配合this.$emit('update:xxx', data)
- native
	加在自定义组件的事件上，保证事件能执行

## 5️⃣ keep-alive

- **作用**：缓存组件，避免重复渲染
- **缓存机制**：`cache` 对象 + `keys` 队列
- **钩子**：`activated` / `deactivated`
- **原理**：基于 VNode 节点缓存组件实例
- **源码核心点**：`pruneCacheEntry` 清理缓存，监听 `include/exclude` 动态调整缓存
- **注意**：多层嵌套路由时，需每层 `router-view` 包裹 `keep-alive`

​	**源码核心**：

- 通过 key 标记组件实例
- 命中缓存 → 复用 vnode.componentInstance
- pruneCache 清理不满足 include/exclude 的缓存

- #### 源码 src/core/components/keep-alive.js

  ```js
  export default {
    name: 'keep-alive',
    abstract: true,
  
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number]
    },
  
    created () {
      this.cache = Object.create(null)
      this.keys = []
    },
  
    destroyed () {
      for (const key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys)
      }
    },
  
    mounted () {
      this.$watch('include', val => {
        pruneCache(this, name => matches(val, name))
      })
      this.$watch('exclude', val => {
        pruneCache(this, name => !matches(val, name))
      })
    },
  
    render() {
      /* 获取默认插槽中的第一个组件节点 */
      const slot = this.$slots.default
      const vnode = getFirstComponentChild(slot)
      /* 获取该组件节点的componentOptions */
      const componentOptions = vnode && vnode.componentOptions
  
      if (componentOptions) {
        /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */
        const name = getComponentName(componentOptions)
  
        const { include, exclude } = this
        /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */
        if (
          (include && (!name || !matches(include, name))) ||
          // excluded
          (exclude && name && matches(exclude, name))
        ) {
          return vnode
        }
  
        const { cache, keys } = this
        /* 获取组件的key值 */
        const key = vnode.key == null
          // same constructor may get registered as different local components
          // so cid alone is not enough (#3269)
          ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
          : vnode.key
       /*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance
          // make current key freshest
          remove(keys, key)
          keys.push(key)
        }
          /* 如果没有命中缓存，则将其设置进缓存 */
          else {
          cache[key] = vnode
          keys.push(key)
          // prune oldest entry
          /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode)
          }
        }
  
        vnode.data.keepAlive = true
      }
      return vnode || (slot && slot[0])
    }
  }
  ```

- #### 源码解析

  - this.cache

    是一个对象，用来存储需要缓存的组件，格式如下

    ```js
    this.cache = {
        'key1':'组件1',
        'key2':'组件2',
        // ...
    }
    ```

  - pruneCacheEntry

    在组件销毁的时候执行pruneCacheEntry函数

    ```js
    function pruneCacheEntry (cache: VNodeCache, key: string, keys: Array<string>, current?: VNode) {
      const cached = cache[key]
      /* 判断当前没有处于被渲染状态的组件，将其销毁*/
      if (cached && (!current || cached.tag !== current.tag)) {
        cached.componentInstance.$destroy()
      }
      cache[key] = null
      remove(keys, key)
    }
    ```

  - 监听include & exclude变化

    ```js
    mounted () {
        this.$watch('include', val => {
            pruneCache(this, name => matches(val, name))
        })
        this.$watch('exclude', val => {
            pruneCache(this, name => !matches(val, name))
        })
    }
    ```

    如果include或exclude发生变化，即表示定义（不）需要缓存的组件的规则发生了变化，则执行pruneCache函数

    ```js
    function pruneCache (keepAliveInstance, filter) {
      const { cache, keys, _vnode } = keepAliveInstance
      for (const key in cache) {
        const cachedNode = cache[key]
        if (cachedNode) {
          const name = getComponentName(cachedNode.componentOptions)
          if (name && !filter(name)) {
            pruneCacheEntry(cache, key, keys, _vnode)
          }
        }
      }
    }
    ```


### 路由vue-router

- **守卫类型**：
  - 全局：`beforeEach`、`afterEach`
  - 路由：`beforeEnter`
  - 组件：`beforeRouteEnter`、`beforeRouteUpdate`、`beforeRouteLeave`

- **模式**：

- hash → 监听 `hashchange`
- history → `pushState/replaceState` + `popState`，需 Nginx `try_files`
- abstract → Node 环境

- **keep-alive 配合路由**：
   多级嵌套需每层 router-view 包裹 keep-alive。

- 路由懒加载
  为什么会更快 分包
- keep-alive
  - 作用
    实现组件缓存，保存这些组件的状态，避免反复渲染；
  - 生命周期：activated，deactivated
    页面第一次进入，钩子的触发顺序created-> mounted-> activated；
    退出时触发deactivated；
    当再次进入（前进或者后退）时，只触发activated

  - 原理
    vue内部将dom节点抽象成一个个VNode节点；keep-alive组件的缓存也是基于VNode节点；
    它将满足条件（pruneCache）的组件在cache对象中缓存起来；
    在需要重新渲染的时候再将VNode节点从cache对象中取出并渲染；
  - 踩坑
    - 多级路由嵌套，只缓存到二级，后面几层router-view中的组件缓存会出现问题
      解决：每次的router-view都包裹一层keep-alive
