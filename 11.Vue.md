## Vue
## 1️⃣ 生命周期（Lifecycle）

### 阶段与钩子

| 阶段          | 钩子                      | 特点                               |
| ------------- | ------------------------- | ---------------------------------- |
| 创建(create)  | beforeCreate → created    | 数据未初始化 vs 数据已可用但未挂载 |
| 挂载(mount)   | beforeMount → mounted     | 可发请求 vs 可操作 DOM             |
| 更新(update)  | beforeUpdate → updated    | 数据变化触发                       |
| 销毁(destroy) | beforeDestroy → destroyed | 可清理手动资源 vs 已销毁           |

**执行顺序注意点：**

- 组件创建时父优先，子后（父beforeCreate → 子beforeCreate → … → 子mounted → 父mounted）
- 更新时：父beforeUpdate → 子beforeUpdate → 子updated → 父updated
- 销毁时：父beforeDestroy → 子beforeDestroy → 子destroyed → 父destroyed

> 面试常考：父子执行顺序、生命周期钩子作用场景。

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220211225838.png)

## 2️⃣ Vue.use 原理

- Vue 插件安装机制：

```js
if (typeof plugin.install === 'function') {
  plugin.install.apply(plugin, args)
} else if (typeof plugin === 'function') {
  plugin.apply(null, args)
}
```

- **核心**：插件本质是给 Vue 原型扩展方法、组件或指令。

## 3️⃣ nextTick 原理

- **作用**：保证在 DOM 更新后执行回调。
- **为什么不能直接拿到 DOM？**
   Vue 是异步渲染，数据修改同步执行，DOM 更新异步。
- **核心原理**：微任务 + 宏任务队列

| 方法             | 优先级 | 说明              |
| ---------------- | ------ | ----------------- |
| Promise          | 高     | 微任务，性能最优  |
| MutationObserver | 次高   | 监听 DOM 变动触发 |
| setImmediate     | 中     | IE 专属           |
| setTimeout       | 低     | 宏任务，兜底      |

- #### 原理

  - 利用事件循环
    - Vue的nextTick实现利用了JavaScript的事件循环机制；在浏览器环境中，JavaScript是单线程执行的，事件循环负责管理异步任务的执行顺序
    - Vue将nextTick的回调函数放入微任务或宏任务队列
    - 当当前执行栈为空时，事件循环会从任务队列中取出任务执行；如果微任务队列中有任务，会先执行微任务队列中的任务，然后在执行宏任务队列中的任务；这样可以确保nextTick的回调函数在DOM更新之后执行
  - 内部实现
    - Vue内部维护了一个异步任务队列，用于存储nextTick的回调函数；当调用nextTick时，回调函数会被添加到这个队列中
    - Vue在更新DOM之后，会检查这个异步任务队列是否为空；如果不为空，会取出队列中的第一个任务并执行
    - 这样就保证了在DOM更新完成之后，nextTick的回调函数能够按照调用的顺序依次执行

  ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220219161533.png)

- **流程**：

  - 回调加入 `callbacks` 队列
  - `timerFunc()` 放入微/宏任务
  - 执行队列，更新 DOM 后回调触发

> 面试问法：`nextTick` 与 `setTimeout(fn,0)` 的区别 → nextTick 优先微任务，性能更高，渲染更精准。

> DOM更新是同步的；UI渲染是在所有微任务完成之后，是异步的；我们在nextTick里拿到的数据，是更新后的DOM，因为diff算法和patch补丁已经算出来了，并作用在DOM上

```js
// Vue 源码节选（next-tick.js）
if (typeof Promise !== 'undefined') {
  // 优先使用 Promise
  const p = Promise.resolve()
  timerFunc = () => p.then(flushCallbacks)
} else if (typeof MutationObserver !== 'undefined') {
  // 降级方案 1：MutationObserver
  const observer = new MutationObserver(flushCallbacks)
  // 监听一个文本节点，通过修改内容触发回调
} else if (typeof setImmediate !== 'undefined') {
  // 降级方案 2：setImmediate（IE）
  timerFunc = () => setImmediate(flushCallbacks)
} else {
  // 最终降级：setTimeout
  timerFunc = () => setTimeout(flushCallbacks, 0)
}

/**
 * 做了3件事
 * 1、将pending置为false
 * 2、清空callbacks数组
 * 3、执行callbacks数组中的每一个函数（比如flushSchedulerQueue、用户调用nextTick传递的回调函数）
 */
function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  /* 遍历callbacks数组，执行其中存储的每个flushSchedulerQueue函数 */
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

/**
 * 完成两件事
 * 1、用try catch包装flushSchedulerQueue函数，然后将其放入callbacks数组
 * 2、如果pending为false，表示现在浏览器的任务队列中没有flushCallbacks函数；
 *  如果pending为true，则表示浏览器的任务队列中已经被放入了flushCallbacks函数；
 *  待执行flushCallbacks函数时，pending会被再次置为false，表示下一个flushCallbacks函数可以进入浏览器的任务队列了
 * pending：保证在同一时刻，浏览器的任务队列只有一个flushCallbacks函数
 * @param {*} cb 接收一个回调函数 => flushSchedulerQueue
 * @param {*} ctx 上下文
 * @returns 
 */
/**
 * 流程：
 *  1、把回调函数放入callbacks等待执行
 *  2、将执行的函数放到微任务或宏任务中
 *  3、事件循环到了微任务或宏任务，执行函数依次执行callbacks中的回调
 * 
 * DOM更新是同步的；
 * UI渲染是在所有微任务完成之后，是异步的；
 * 我们在nextTick里拿到的数据，是更新后的DOM，因为diff算法和patch补丁已经算出来的，并作用在DOM上
 */
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  /* 用callbacks数组存储经过包装的cb函数 */
  callbacks.push(() => {
    if (cb) {
      /* 用try catch包装回调函数，便于错误捕获 */
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    /* 执行timerFunc，在浏览器的任务队列中（首选微任务队列）放入flushCallbacks函数 */
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
```

### Vue选项合并策略

## 1️⃣ 概念

- Vue 允许我们在 **实例化 Vue 或创建子组件时传入配置对象**，例如：

```js
const parent = Vue.extend({
  data() { return { a: 1 } },
  methods: { foo() { console.log('parent') } }
})

const child = new parent({
  data() { return { b: 2 } },
  methods: { foo() { console.log('child') } }
})
```

- Vue 内部需要把 **父级选项和子级选项合并**，这就是 **选项合并策略**（`mergeOptions`）。

------

## 2️⃣ 合并规则分类

### （1）对象类型（data, methods, computed, watch）

- **规则**：子对象覆盖父对象的同名属性；如果父子都存在不同属性，合并保留全部。
- **举例**：

```js
const parent = {
  data: { a: 1 },
  methods: { foo() { console.log('parent') } }
}

const child = {
  data: { b: 2 },
  methods: { bar() { console.log('child') } }
}

const merged = Vue.util.mergeOptions(parent, child)
/*
merged.data -> { a:1, b:2 }
merged.methods -> { foo: fn, bar: fn }
*/
```

------

### （2）生命周期钩子（created, mounted 等）

- **规则**：父子钩子合并为 **数组**，依次执行。
- **顺序**：父钩子先执行 → 子钩子后执行
- **示例**：

```js
const parent = { created() { console.log('parent created') } }
const child = { created() { console.log('child created') } }

const merged = Vue.util.mergeOptions(parent, child)
merged.created.forEach(fn => fn())  
// 输出：parent created
//       child created
```

> 面试常考点：钩子执行顺序父优先，且合并为数组。

------

### （3）数组类型（components, directives, filters）

- **规则**：子组件会 **覆盖父组件同名注册**。
- **原因**：同名组件需要被子组件覆盖以实现局部注册。

```js
const parent = { components: { A: {...} } }
const child = { components: { A: {...}, B: {...} } }

const merged = Vue.util.mergeOptions(parent, child)
console.log(merged.components) // { A: child.A, B: child.B }
```

------

### （4）默认策略

- **规则**：子选项优先覆盖父选项（子覆盖父）。
- 常见适用字段：`el`, `propsData`, `name`, `template` 等。

------

## 3️⃣ Vue 内部实现逻辑

Vue 内部核心方法：`mergeOptions(parent, child, vm)`

- 遍历 **父选项和子选项**，根据字段类型调用策略函数 `strats[key]`
- 钩子类字段：数组合并
- 对象类字段：对象合并
- 默认策略：子覆盖父

```js
function mergeOptions(parent, child, vm) {
  const options = {}
  for (const key in parent) mergeField(key)
  for (const key in child) if (!parent.hasOwnProperty(key)) mergeField(key)

  function mergeField(key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

- **strats**：存储各字段的合并策略
   例如：

```js
strats.data = function (parentVal, childVal, vm) { ... }       // data 合并
strats.created = mergeHook                             // 生命周期合并
strats.components = mergeAssets                        // 组件/指令/过滤器合并
```

------

## 4️⃣ 面试高频点

1. 生命周期钩子合并顺序：父 → 子
2. `data` 函数合并：子 `data` 覆盖父 `data`，注意 Vue 2 对对象是 **合并而非替换整个对象**（Vue 3 中 Proxy 可直接覆盖）
3. `methods`、`computed`、`watch` 对象合并：不同属性合并，同名覆盖
4. 全局组件/指令/过滤器注册：子会覆盖父同名注册

### 双向绑定原理
	vue采用 数据劫持 结合 发布-订阅 模式；
- Observer监听器
	- 通过Object.defineProperty()来监听数据的变动，遍历对象，包括子对象，给每个属性加上getter，setter
	- 每当数据发生变化，就会触发setter；
	- 这时候Observer就要通知订阅者，订阅者就是Watcher；
- Compiler指令解析器
	- Compiler 编译模板指令，生成绑定函数。
	- 将模板中的变量替换成数据，然后初始化渲染页面视图； 并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者； 一旦数据有变动，收到通知，调用更新函数更新视图；
- Watcher订阅者
	订阅者作为Observer和Compiler之间的通信桥梁，接收 Dep 通知并更新视图。
	- 在自身实例化时，往属性订阅器(dep)里添加自己；
	- 自身必须有一个update方法；
	- 当Observer属性变动，通知(dep.notice())时，能调用自身的update()方法，并触发Compile中的绑定回调
- Dep订阅器
	采用发布-订阅模式；
	用来收集订阅者Watcher；
	对监听器Observer和订阅者Watcher进行统一管理；
	![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220212103055.png)
```js
//创建订阅发布者
//1.管理订阅
//2.集体通知
class Dep {
  constructor() {
    this.subs = [];
  }
  //添加订阅
  addSub(sub) {//其实就是watcher对象
    this.subs.push(sub)
  }
  //集体通知
  notify() {
    this.subs.forEach((sub) => {
      sub.update()
    })
  }
}
```
### 数组响应式重写
- 实现
```js
const arrExtend = Object.create(Array.prototype)
// const arrExtend = {}
// arrExtend._proto_=Array.prototype
const arrMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']
arrMethods.forEach(method => {
  const oldMethod = Array.prototype[method]
  const newMethod = function(...args) {
    oldMethod.apply(this, args)
    console.log(`${method} 方法被执行了`)
  }
  arrExtend[method] = newMethod
})
```


### 双向绑定的优点

### template原理和实现
![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209123317.png)

### 虚拟dom
	数据改变-虚拟dom计算变更-操作真实dom-视图更新
- 格式：
	 {
		tag: 'div', // 选择器
		data: {class,attribute,style}, // 最后渲染成真实dom节点后，节点上的class、attribute、style及绑定的事件
		children: [{xxx}], // vnode子节点
		text: 'xxx', // 文本属性
		elm, //vnode对应的真实dom节点
		key, // vnode标记，提高diff的效率
	}
- 虚拟dom的好处
	虚拟dom是为了解决模板渲染问题；
	- 无需手动优化
	- 无需手动操作dom。只管代码逻辑
	- 会比较虚拟dom的变化，计算出最小的需要更新的视图，再去操作dom
- 为什么要用虚拟dom
- 与jQuery或原生操作dom的方式，有什么区别
- dom遍历方式
  - diff算法
- 实现原理
	- 用js对象模拟真实dom，对真实dom进行抽象；
	- diff算法，比较两颗dom数的差异；
	- patch算法，将差异更新应用到真实dom；
### diff算法
- 作用：
	diff算法用来比较两棵虚拟dom树的差异
	![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220214215959.png)
- 深度优先遍历，记录差异
	先子节点，后相邻节点（深度优先 递归updateChildren）
	![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220214215941.png)
- vdom的核心；
    - 只比较同层级节点
    - 标签名不同直接替换
    - 标签名+key相同 → 局部更新
    - 深度优先遍历子节点
    - patchVNode 更新 DOM
    
    > 面试常考点：diff 只比较同层节点、key的作用、patch更新策略。
- patch函数（vdom最核心的方法，完成视图更新的关键方法）
	- 作用
        完成oldVnode和vnode的diff过程；
        并根据需要操作的vdom节点打上patch；
        最后生成新的真实dom节点并完成视图更新工作；
	  -执行情况(两种)
		1. oldVnode不存在
			创建新节点
		2. oldVnode存在
			会对oldVnode和vnode进行diff及patch的过程；
			patch会调用sameVNode方法，来对两个传入的vnode进行基本属性比较；
			1. 只有当基本属性相同的情况，才认为这2个vnode只是局部发生更新；
			然后才会对2个vnode进行diff；
			2. 如果2个vnode基本属性存在不一致，会直接跳过diff过程；
			依据vnode新建一个真实的dom，同时删除老的dom节点；
	  	（oldCh=oldVnode的子节点，ch=vnode的子节点）
- patchVNode（diff过程的方法）
	- 进行文本节点判断，若oldVnode.text!==vnode.text，直接进行文本节点的替换；
	- vnode没有文本节点，进入子节点的diff；
	- oldCh和ch都存在且不同，调用updateChildren对子节点进行diff；
	- oldCh不存在，ch存在，清空oldVnode的文本节点，同时调用addVnodes方法，将ch添加到elm真实dom节点中；
	- oldCh存在，ch不存在，删除elm真实节点下的oldCh；
	- oldVnode有文本节点，而vnode没有，清空这个文本节点；
- updateChildren（子节点diff流程，整个diff过程中最重要的环节）
	- 首先给oldCh和ch分别分配一个startIndex和endIndex来作为遍历的索引；
	- 当oldCh或ch遍历完后（条件：oldCh或ch的startIndex>endIndex），停止oldCh和ch的diff过程；
    ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209204451.png)
### 初始化Vue到最终渲染的整个过程
![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220215214130.png)
### MVVM & MVC
### Proxy & Object.defineProperty
- Proxy
	- Proxy可以直接监听对象而非属性；
	- 可以直接监听数组的变化
	
	  ```js
	  const handler = {
	    get(target, prop) {
	      // 拦截所有属性访问
	      return Reflect.get(target, prop);
	    },
	    set(target, prop, value) {
	      // 拦截所有属性设置
	      return Reflect.set(target, prop, value);
	    },
	    deleteProperty(target, prop) {
	      // 拦截属性删除
	      return Reflect.deleteProperty(target, prop);
	    }
	  };
	  
	  const proxy = new Proxy([], handler);
	  ```
	
	  ```js
	  function reactive(obj) {
	    return new Proxy(obj, {
	      get(target, key) {
	        track(target, key); // 依赖收集
	        return Reflect.get(target, key);
	      },
	      set(target, key, value) {
	        const oldValue = target[key];
	        const result = Reflect.set(target, key, value);
	        
	        // 特殊处理数组的 length 属性
	        if (key === 'length' && Array.isArray(target)) {
	          // 触发 length 相关更新
	        } else {
	          // 判断是新增还是修改
	          if (!target.hasOwnProperty(key)) {
	            trigger(target, 'add', key);
	          } else if (oldValue !== value) {
	            trigger(target, 'set', key);
	          }
	        }
	        return result;
	      },
	      deleteProperty(target, key) {
	        const hadKey = target.hasOwnProperty(key);
	        const result = Reflect.deleteProperty(target, key);
	        if (hadKey) {
	          trigger(target, 'delete', key);
	        }
	        return result;
	      }
	    });
	  }
	  ```
	- Proxy多达13种拦截方法；
	  get、set、has、deleteProperty、ownKeys、getOwnPropertyDescriptor、
	  defineProperty、preventExtensions、getPrototypeOf、isExtensible、
	  setPrototypeOf、apply、construct
	- Proxy返回一个新对象，我们只操作新对象；
	- Proxy持续优化；
	- 不支持IE；
	
- Object.defineProperty
	- 支持IE9；
	
	- 只能遍历对象属性直接修改；
	
	- 不再优化；
	
	- 不能监听数组
	
	  - 为什么不监听数组下标
	
	    - 性能问题
	
	      - 数组包含大量元素，为每个索引都设置getter/setter会消耗大量内存
	      - 每次数组操作都要遍历整个数组，时间复制度为O(n)
	
	    - 下标不可控
	
	      - 数组长度动态变化，无法预先定义所有索引的响应式
	      - 数组操作（push/pop/shift/unshift）会改变索引位置
	
	    - 监听盲区
	
	      ```js
	      const arr = [1, 2, 3];
	      // Vue2 无法检测到这种直接索引赋值
	      arr[0] = 10; 
	      // Vue2 无法检测到数组长度变化
	      arr.length = 0;
	      ```
	
	    - 无法监听新增、删除
	
	      ```js
	      // 无法检测新增元素
	      arr[3] = 4;
	      // 无法检测元素删除
	      delete arr[0];
	      ```
## 对比总结

| 特性                    | `Object.defineProperty` | `Proxy`            |
| :---------------------- | :---------------------- | :----------------- |
| 数组索引访问/设置       | ❌ 无法监听              | ✅ 完全支持         |
| 数组方法操作 (push/pop) | ⚠️ 需重写方法            | ✅ 原生支持         |
| 数组长度变化            | ❌ 无法监听              | ✅ 支持 length 变更 |
| 新增/删除元素           | ❌ 无法监听              | ✅ 完全支持         |
| 性能表现                | ⚠️ 数组较大时性能差      | ✅ 高效             |
| 嵌套对象处理            | ⚠️ 需要递归初始化        | ✅ 惰性代理         |
| 浏览器兼容性            | ✅ IE9+                  | ❌ 不兼容 IE        |

### 服务端渲染

- 定义：在服务端渲染整个html片段，直接返回给客户端；
- 优点：有利于SEO
- 缺点：只支持beforeCreate，created钩子函数；服务端渲染的应用只能在node server运行环境；更多的服务器负载；
- nuxtjs：vue-server-renderer
### vue常用修饰符
- stop
	阻止冒泡
- prevent
	阻止默认事件（如：a标签的跳转）
- capture
	事件默认是由里往外冒泡；capture作用是由外往里捕获
- self
	点击事件绑定的本身才会触发事件
- once
	事件只执行一次
- passive
	相当于给onscroll事件添加一个.lazy修饰符（@scroll.passive="onScroll"）
- enter
- trim
	去除首尾空格
- number
	将v-model值转成数字
		22aa => 22
		aa22 => aa22（无效）
- lazy
	改变输入框的值时value不会改变；当光标离开输入框时，v-model绑定的值value才会改变
- sync
	配合this.$emit('update:xxx', data)
- native
	加在自定义组件的事件上，保证事件能执行
	

### keep-alive

**作用**：缓存组件，避免重复渲染。

**缓存机制**：`cache` 对象 + `keys` 队列

**钩子**：activated / deactivated

**源码核心**：

- 通过 key 标记组件实例
- 命中缓存 → 复用 vnode.componentInstance
- pruneCache 清理不满足 include/exclude 的缓存

- #### 源码 src/core/components/keep-alive.js

  ```js
  export default {
    name: 'keep-alive',
    abstract: true,
  
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number]
    },
  
    created () {
      this.cache = Object.create(null)
      this.keys = []
    },
  
    destroyed () {
      for (const key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys)
      }
    },
  
    mounted () {
      this.$watch('include', val => {
        pruneCache(this, name => matches(val, name))
      })
      this.$watch('exclude', val => {
        pruneCache(this, name => !matches(val, name))
      })
    },
  
    render() {
      /* 获取默认插槽中的第一个组件节点 */
      const slot = this.$slots.default
      const vnode = getFirstComponentChild(slot)
      /* 获取该组件节点的componentOptions */
      const componentOptions = vnode && vnode.componentOptions
  
      if (componentOptions) {
        /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */
        const name = getComponentName(componentOptions)
  
        const { include, exclude } = this
        /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */
        if (
          (include && (!name || !matches(include, name))) ||
          // excluded
          (exclude && name && matches(exclude, name))
        ) {
          return vnode
        }
  
        const { cache, keys } = this
        /* 获取组件的key值 */
        const key = vnode.key == null
          // same constructor may get registered as different local components
          // so cid alone is not enough (#3269)
          ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
          : vnode.key
       /*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance
          // make current key freshest
          remove(keys, key)
          keys.push(key)
        }
          /* 如果没有命中缓存，则将其设置进缓存 */
          else {
          cache[key] = vnode
          keys.push(key)
          // prune oldest entry
          /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode)
          }
        }
  
        vnode.data.keepAlive = true
      }
      return vnode || (slot && slot[0])
    }
  }
  ```

- #### 源码解析

  - this.cache

    是一个对象，用来存储需要缓存的组件，格式如下

    ```js
    this.cache = {
        'key1':'组件1',
        'key2':'组件2',
        // ...
    }
    ```

  - pruneCacheEntry

    在组件销毁的时候执行pruneCacheEntry函数

    ```js
    function pruneCacheEntry (cache: VNodeCache, key: string, keys: Array<string>, current?: VNode) {
      const cached = cache[key]
      /* 判断当前没有处于被渲染状态的组件，将其销毁*/
      if (cached && (!current || cached.tag !== current.tag)) {
        cached.componentInstance.$destroy()
      }
      cache[key] = null
      remove(keys, key)
    }
    ```

  - 监听include & exclude变化

    ```js
    mounted () {
        this.$watch('include', val => {
            pruneCache(this, name => matches(val, name))
        })
        this.$watch('exclude', val => {
            pruneCache(this, name => !matches(val, name))
        })
    }
    ```

    如果include或exclude发生变化，即表示定义（不）需要缓存的组件的规则发生了变化，则执行pruneCache函数

    ```js
    function pruneCache (keepAliveInstance, filter) {
      const { cache, keys, _vnode } = keepAliveInstance
      for (const key in cache) {
        const cachedNode = cache[key]
        if (cachedNode) {
          const name = getComponentName(cachedNode.componentOptions)
          if (name && !filter(name)) {
            pruneCacheEntry(cache, key, keys, _vnode)
          }
        }
      }
    }
    ```


### 路由vue-router

- **守卫类型**：
  - 全局：`beforeEach`、`afterEach`
  - 路由：`beforeEnter`
  - 组件：`beforeRouteEnter`、`beforeRouteUpdate`、`beforeRouteLeave`

- **模式**：

- hash → 监听 `hashchange`
- history → `pushState/replaceState` + `popState`，需 Nginx `try_files`
- abstract → Node 环境

- **keep-alive 配合路由**：
   多级嵌套需每层 router-view 包裹 keep-alive。

- 路由懒加载
  为什么会更快 分包
- keep-alive
  - 作用
    实现组件缓存，保存这些组件的状态，避免反复渲染；
  - 生命周期：activated，deactivated
    页面第一次进入，钩子的触发顺序created-> mounted-> activated；
    退出时触发deactivated；
    当再次进入（前进或者后退）时，只触发activated

  - 原理
    vue内部将dom节点抽象成一个个VNode节点；keep-alive组件的缓存也是基于VNode节点；
    它将满足条件（pruneCache）的组件在cache对象中缓存起来；
    在需要重新渲染的时候再将VNode节点从cache对象中取出并渲染；
  - 踩坑
    - 多级路由嵌套，只缓存到二级，后面几层router-view中的组件缓存会出现问题
      解决：每次的router-view都包裹一层keep-alive
