## Vue
## 1️⃣ 生命周期（Lifecycle）

### 阶段与钩子

| 阶段          | 钩子                      | 特点                               |
| ------------- | ------------------------- | ---------------------------------- |
| 创建(create)  | beforeCreate → created    | 数据未初始化 vs 数据已可用但未挂载 |
| 挂载(mount)   | beforeMount → mounted     | 可发请求 vs 可操作 DOM             |
| 更新(update)  | beforeUpdate → updated    | 数据变化触发                       |
| 销毁(destroy) | beforeDestroy → destroyed | 可清理手动资源 vs 已销毁           |

**执行顺序注意点：**

- 组件创建时父优先，子后（父beforeCreate → 子beforeCreate → … → 子mounted → 父mounted）
- 更新时：父beforeUpdate → 子beforeUpdate → 子updated → 父updated
- 销毁时：父beforeDestroy → 子beforeDestroy → 子destroyed → 父destroyed

> 面试常考：父子执行顺序、生命周期钩子作用场景。

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220211225838.png)

## 2️⃣ Vue.use 原理

`Vue.use` 是 **Vue 提供的插件安装方法**，用于将一个插件安装到 Vue 中，使其可以扩展 Vue 的功能，包括：

- 添加全局方法或属性
- 添加全局指令
- 添加实例方法
- 注入组件或混入全局逻辑

一、`Vue.use` 的作用

- 用来 **安装插件**（plugin），避免重复安装。
- 插件一般是给 Vue 添加 **全局功能**，比如：
  - 给 `Vue.prototype` 挂载方法；
  - 注册全局组件；
  - 注册全局指令；
  - 混入全局配置。

二、源码简化版（Vue 2.x）

```js
Vue.use = function (plugin) {
  const installedPlugins = this._installedPlugins || (this._installedPlugins = [])

  // 避免重复安装
  if (installedPlugins.indexOf(plugin) > -1) {
    return this
  }

  // 取出后续参数，传给 install
  const args = toArray(arguments, 1)
  args.unshift(this) // 把 Vue 传给 install

  // 插件的 install 方法
  if (typeof plugin.install === 'function') {
    plugin.install.apply(plugin, args)
  } else if (typeof plugin === 'function') {
    plugin.apply(null, args)
  }

  installedPlugins.push(plugin)
  return this
}
```

三、核心逻辑

1. **维护已安装插件的列表**
   - 通过 `Vue._installedPlugins` 数组，避免多次调用 `Vue.use` 重复安装。
2. **处理 install 方法**
   - 如果插件对象有 `install` 方法 → 调用 `plugin.install(Vue, ...args)`
   - 如果插件本身是函数 → 直接调用 `plugin(Vue, ...args)`
3. **传入参数**
   - 默认第一个参数是 `Vue` 构造函数；
   - 后面是 `Vue.use(plugin, options)` 传入的额外参数。

四、插件示例

```js
// 定义一个插件
const MyPlugin = {
  install(Vue, options) {
    // 1. 给原型挂方法
    Vue.prototype.$hello = function () {
      console.log('Hello from plugin!')
    }

    // 2. 注册全局组件
    Vue.component('my-component', {
      template: '<div>我是全局组件</div>'
    })
  }
}

// 使用插件
Vue.use(MyPlugin, { someOption: true })

// 使用效果
new Vue({
  created() {
    this.$hello() // Hello from plugin!
  }
})
```

------

✅ 总结一句：
 `Vue.use` 就是一个 **插件注册器**，确保只执行一次，并且给插件传入 `Vue` 实例和参数。插件本质就是通过 **扩展 Vue 原型 / 全局注册** 来增强 Vue 功能。

## Vue 2 `nextTick` 的核心原理

因为 Vue 2 的 DOM 更新是异步批处理的，而 `nextTick` 会在更新队列 flush 完毕、DOM 更新完成后才执行回调，所以回调中访问的 DOM 已是最新状态。

### 1️⃣ 数据变更到 DOM 更新是异步的

1. 当你修改响应式数据，例如：

```js
this.msg = "new";
```

1. 会触发 **依赖收集的 watcher**：

```js
dep.notify() → watcher.update()
```

1. watcher 并不会立即更新 DOM，而是：

```js
queueWatcher(watcher)   // 加入更新队列
```

1. Vue 会在 **下一个“tick”** 批量执行队列：

```js
flushSchedulerQueue()   // watcher.run() → patch → 更新 DOM
```

> 这种异步批处理机制可以减少重复渲染，提高性能。

------

### 2️⃣ `nextTick` 的工作流程

```js
数据变更
   ↓
dep.notify() → watcher.update()
   ↓
queueWatcher(watcher)           // 更新队列
   ↓
nextTick(flushSchedulerQueue)   // 回调加入异步队列
   ↓
flushSchedulerQueue()           // 批量执行 watcher.run() → patch → 更新 DOM
   ↓
DOM 已更新
   ↓
flushCallbacks()                // 执行 nextTick 回调
```

💡 **关键点**：`nextTick` 回调总是在 DOM 更新完成后才触发。

------

### 3️⃣ 为什么不能同步拿到 DOM

- Vue 的 DOM 更新是异步的，**数据修改不会立即改变 DOM**。
- 直接在修改数据后访问 DOM，只能拿到旧值。
- `nextTick` 利用了异步队列机制，把回调延迟到 DOM 更新之后执行，因此在回调中能拿到最新 DOM。

------

### 4️⃣ `nextTick` 的异步队列机制

| 方法             | 优先级 | 说明              |
| ---------------- | ------ | ----------------- |
| Promise          | 高     | 微任务，性能最优  |
| MutationObserver | 次高   | 监听 DOM 变动触发 |
| setImmediate     | 中     | IE 专用           |
| setTimeout       | 低     | 宏任务，兜底      |

- Vue 会维护一个 **callbacks 队列** 存储 nextTick 的回调。
- 当队列 flush 时：
  1. 先执行 watcher，更新 DOM。
  2. 再依次执行 nextTick 回调。

------

### 5️⃣ 总结逻辑

1. **数据变化 → watcher 更新**（异步队列）。
2. **DOM 更新**（patch 补丁应用）。
3. **nextTick 回调执行**（DOM 已是最新状态）。

> 核心思想：**微任务 + 宏任务 + 更新队列的顺序保证了 nextTick 回调总是 DOM 更新后触发**。

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220219161533.png)

<img src="https://i-coder.oss-cn-beijing.aliyuncs.com/files/Untitled diagram _ Mermaid Chart-2025-08-21-042841.png" style="zoom: 67%;" />

```js
// Vue 源码节选（next-tick.js）
if (typeof Promise !== 'undefined') {
  // 优先使用 Promise
  const p = Promise.resolve()
  timerFunc = () => p.then(flushCallbacks)
} else if (typeof MutationObserver !== 'undefined') {
  // 降级方案 1：MutationObserver
  const observer = new MutationObserver(flushCallbacks)
  // 监听一个文本节点，通过修改内容触发回调
} else if (typeof setImmediate !== 'undefined') {
  // 降级方案 2：setImmediate（IE）
  timerFunc = () => setImmediate(flushCallbacks)
} else {
  // 最终降级：setTimeout
  timerFunc = () => setTimeout(flushCallbacks, 0)
}

/**
 * 做了3件事
 * 1、将pending置为false
 * 2、清空callbacks数组
 * 3、执行callbacks数组中的每一个函数（比如flushSchedulerQueue、用户调用nextTick传递的回调函数）
 */
function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  /* 遍历callbacks数组，执行其中存储的每个flushSchedulerQueue函数 */
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

/**
 * 完成两件事
 * 1、用try catch包装flushSchedulerQueue函数，然后将其放入callbacks数组
 * 2、如果pending为false，表示现在浏览器的任务队列中没有flushCallbacks函数；
 *  如果pending为true，则表示浏览器的任务队列中已经被放入了flushCallbacks函数；
 *  待执行flushCallbacks函数时，pending会被再次置为false，表示下一个flushCallbacks函数可以进入浏览器的任务队列了
 * pending：保证在同一时刻，浏览器的任务队列只有一个flushCallbacks函数
 * @param {*} cb 接收一个回调函数 => flushSchedulerQueue
 * @param {*} ctx 上下文
 * @returns 
 */
/**
 * 流程：
 *  1、把回调函数放入callbacks等待执行
 *  2、将执行的函数放到微任务或宏任务中
 *  3、事件循环到了微任务或宏任务，执行函数依次执行callbacks中的回调
 * 
 * DOM更新是同步的；
 * UI渲染是在所有微任务完成之后，是异步的；
 * 我们在nextTick里拿到的数据，是更新后的DOM，因为diff算法和patch补丁已经算出来的，并作用在DOM上
 */
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  /* 用callbacks数组存储经过包装的cb函数 */
  callbacks.push(() => {
    if (cb) {
      /* 用try catch包装回调函数，便于错误捕获 */
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    /* 执行timerFunc，在浏览器的任务队列中（首选微任务队列）放入flushCallbacks函数 */
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
```

### Vue选项合并策略

## 1️⃣ 概念

- Vue 允许我们在 **实例化 Vue 或创建子组件时传入配置对象**，例如：

```js
const parent = Vue.extend({
  data() { return { a: 1 } },
  methods: { foo() { console.log('parent') } }
})

const child = new parent({
  data() { return { b: 2 } },
  methods: { foo() { console.log('child') } }
})
```

- Vue 内部需要把 **父级选项和子级选项合并**，这就是 **选项合并策略**（`mergeOptions`）。

------

## 2️⃣ 合并规则分类

### （1）对象类型（data, methods, computed, watch）

- **规则**：子对象覆盖父对象的同名属性；如果父子都存在不同属性，合并保留全部。
- **举例**：

```js
const parent = {
  data: { a: 1 },
  methods: { foo() { console.log('parent') } }
}

const child = {
  data: { b: 2 },
  methods: { bar() { console.log('child') } }
}

const merged = Vue.util.mergeOptions(parent, child)
/*
merged.data -> { a:1, b:2 }
merged.methods -> { foo: fn, bar: fn }
*/
```

------

### （2）生命周期钩子（created, mounted 等）

- **规则**：父子钩子合并为 **数组**，依次执行。
- **顺序**：父钩子先执行 → 子钩子后执行
- **示例**：

```js
const parent = { created() { console.log('parent created') } }
const child = { created() { console.log('child created') } }

const merged = Vue.util.mergeOptions(parent, child)
merged.created.forEach(fn => fn())  
// 输出：parent created
//       child created
```

> 面试常考点：钩子执行顺序父优先，且合并为数组。

------

### （3）数组类型（components, directives, filters）

- **规则**：子组件会 **覆盖父组件同名注册**。
- **原因**：同名组件需要被子组件覆盖以实现局部注册。

```js
const parent = { components: { A: {...} } }
const child = { components: { A: {...}, B: {...} } }

const merged = Vue.util.mergeOptions(parent, child)
console.log(merged.components) // { A: child.A, B: child.B }
```

------

### （4）默认策略

- **规则**：子选项优先覆盖父选项（子覆盖父）。
- 常见适用字段：`el`, `propsData`, `name`, `template` 等。

------

## 3️⃣ Vue 内部实现逻辑

Vue 内部核心方法：`mergeOptions(parent, child, vm)`

- 遍历 **父选项和子选项**，根据字段类型调用策略函数 `strats[key]`
- 钩子类字段：数组合并
- 对象类字段：对象合并
- 默认策略：子覆盖父

```js
function mergeOptions(parent, child, vm) {
  const options = {}
  for (const key in parent) mergeField(key)
  for (const key in child) if (!parent.hasOwnProperty(key)) mergeField(key)

  function mergeField(key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

- **strats**：存储各字段的合并策略
   例如：

```js
strats.data = function (parentVal, childVal, vm) { ... }       // data 合并
strats.created = mergeHook                             // 生命周期合并
strats.components = mergeAssets                        // 组件/指令/过滤器合并
```

------

## 4️⃣ 面试高频点

1. 生命周期钩子合并顺序：父 → 子
2. `data` 函数合并：子 `data` 覆盖父 `data`，注意 Vue 2 对对象是 **合并而非替换整个对象**（Vue 3 中 Proxy 可直接覆盖）
3. `methods`、`computed`、`watch` 对象合并：不同属性合并，同名覆盖
4. 全局组件/指令/过滤器注册：子会覆盖父同名注册

### 双向绑定原理

### 一、核心思想

Vue 2 的双向绑定是基于 **数据劫持 (Object.defineProperty)** + **发布-订阅模式 (Dep + Watcher)** 实现的。

一句话总结：
 **数据变化 → 触发 setter → 通知 Dep → Dep 通知 Watcher → Watcher 执行更新函数 → 视图更新**
 **视图变化 (v-model 输入) → 触发事件 → 修改数据 → 再走上面这套流程**

### 流程总结

- **读数据 → getter → 依赖收集**
- **改数据 → setter → 通知 Watcher → 更新视图**

------

## 二、四大核心角色

### 1. **Observer（数据监听器）**

- 用 `Object.defineProperty` 给每个数据属性加上 `getter / setter`。
- 作用：劫持数据的读写。
- 当读取属性时 → 依赖收集（把 Watcher 加到 Dep 中）。
- 当修改属性时 → 通知 Dep 派发更新。

------

### 2. **Dep（依赖收集器）**

- 一个中间调度中心，维护着一组 Watcher。
- 每个响应式属性都会有一个 `Dep` 实例。
- 提供 `depend()`（收集依赖）和 `notify()`（派发更新）。

------

### 3. **Watcher（订阅者）**

- 订阅数据变化，当数据变化时，执行回调更新视图。
- 在实例化时，会读取一次数据，触发 getter，把自己（当前的Watcher）加到 Dep 中。
- 内部有 `update()` 方法，当被通知时调用 → 触发视图更新。

------

### 4. **Compiler（模板编译器）**

- 解析模板中的指令（如 `v-model`、`v-text`、`{{ }}` 表达式）。

- 为每个绑定的节点生成更新函数，并且创建对应的 Watcher。

- 当数据变化时，Watcher 通知这些更新函数去更新 DOM。

  

- 完整流程

  - 编译阶段
    - parse：解析模板指令，生成AST
    - optimize：遍历AST，标记静态节点；优化diff，提升渲染性能
    - generate：AST转为render函数

  - 挂载
    - 执行render函数，生成VNode
    - 把VNode转为真实DOM

  - 依赖收集
    - 在render过程中，访问变量，触发getter；getter内部调用dep.depend()，把当前Watcher收集进依赖

  - 更新阶段
    - 触发setter，执行dep.notify()，通知所有Watcher执行update()，生成新的VNode
    - patch(oldVNode, newVNode)，diff算法比对差异，更新真实DOM


- 📌 总结一句

  - Compiler 把模板转成 **render 函数**。

  - render 函数执行时会触发数据依赖收集。

  - 数据更新时，watcher 会重新执行 render，生成新 VNode，并用 patch 更新 DOM。

------

## 三、运行流程

1. **初始化时**

   - `Observer` 劫持数据，为属性设置 getter/setter。
   - `Compiler` 解析模板，把变量替换成数据，并为变量创建 `Watcher`。
   - `Watcher` 在创建时会读取一次数据（触发 getter），从而被 `Dep` 收集。

2. **数据变化时**

   - 修改数据属性 → 触发 `setter` → 调用 `dep.notify()`。
   - `Dep` 通知所有 Watcher → 调用 `update()` → 执行对应的 DOM 更新函数。

3. **视图变化时**

   - 用户输入（例如 `v-model` 绑定的 input）触发 `input` 事件。
   - 事件回调里更新数据 → 数据变化再走 Observer → Dep → Watcher → 视图更新。

   ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220212103055.png)

## 四、总结一句

Vue 2 的双向绑定就是：

- **Observer** 劫持数据属性；
- **Dep** 收集和派发更新；
- **Watcher** 订阅数据变化，执行更新函数；
- **Compiler** 负责解析模板，把数据和 DOM 绑定起来。

## 五、简化版代码示例

```js
// Dep: 依赖收集器
class Dep {
  constructor() {
    this.subs = []
  }
  addSub(sub) {
    this.subs.push(sub)
  }
  notify() {
    this.subs.forEach(sub => sub.update())
  }
}
// Watcher: 订阅者
class Watcher {
  constructor(obj, key, cb) {
    this.obj = obj
    this.key = key
    this.cb = cb
    Dep.target = this
    this.value = obj[key] // 触发 getter 收集依赖
    Dep.target = null
  }
  update() {
    const newVal = this.obj[this.key]
    if (newVal !== this.value) {
      this.value = newVal
      this.cb(newVal)
    }
  }
}
// Observer: 数据劫持
function observe(obj) {
  Object.keys(obj).forEach(key => {
    let val = obj[key]
    const dep = new Dep()
    Object.defineProperty(obj, key, {
      get() {
        if (Dep.target) dep.addSub(Dep.target)
        return val
      },
      set(newVal) {
        val = newVal
        dep.notify()
      }
    })
  })
}
// 使用
const data = { msg: 'hello' }
observe(data)
// 绑定一个 watcher
new Watcher(data, 'msg', val => {
  console.log('视图更新:', val)
})
data.msg = 'world' // setter → dep.notify → watcher.update → 输出 "视图更新: world"
```

```js
//创建订阅发布者
//1.管理订阅
//2.集体通知
class Dep {
  constructor() {
    this.subs = [];
  }
  //添加订阅
  addSub(sub) {//其实就是watcher对象
    this.subs.push(sub)
  }
  //集体通知
  notify() {
    this.subs.forEach((sub) => {
      sub.update()
    })
  }
}
```
### 数组响应式重写
- 实现
```js
const arrExtend = Object.create(Array.prototype)
// const arrExtend = {}
// arrExtend._proto_=Array.prototype
const arrMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']
arrMethods.forEach(method => {
  const oldMethod = Array.prototype[method]
  const newMethod = function(...args) {
    oldMethod.apply(this, args)
    console.log(`${method} 方法被执行了`)
  }
  arrExtend[method] = newMethod
})
```

### 双向绑定的优点

双向绑定的优点是 **简化代码、提升开发效率、自动同步数据和视图**，尤其适合表单和数据频繁交互的场景。

### template原理和实现

`template` 的原理就是：
 Template → AST → 优化 → Render Function → VNode → 真实 DOM。

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209123317.png)

### 虚拟dom
## 1. 虚拟 DOM 概念

- **定义**：虚拟 DOM 是用 **JavaScript 对象** 表示真实 DOM 的一种抽象。
- **目的**：解决直接操作 DOM 的性能低和复杂问题，实现 **高效的视图更新**。
- **更新流程**：

```
数据改变 → 生成新的虚拟 DOM → 计算差异 (diff) → 最小化更新真实 DOM → 视图更新
```

------

## 2. 虚拟 DOM 格式（VNode）

每个节点都是一个 JS 对象，大致结构如下：

```
{
  tag: 'div',           // 标签名
  data: {               // 节点属性、样式、事件等
    class: 'box',
    style: { color: 'red' },
    attrs: { id: 'app' },
    on: { click: handleClick }
  },
  children: [/* 子节点 VNode */],
  text: 'Hello',        // 文本节点内容
  elm: null,            // 对应真实 DOM 节点
  key: 'uniqueKey'      // 提高 diff 算法效率，帮助复用 DOM
}
```

------

## 3. 虚拟 DOM 的优势

1. **无需手动操作 DOM**
   - 逻辑层只关注数据变化，Vue 自动计算最小更新。
2. **提高性能**
   - 比直接操作 DOM 更高效，因为减少了重排（reflow）和重绘（repaint）。
3. **可跨平台**
   - 抽象 DOM 结构，可在不同平台（浏览器、Native、Weex）渲染。
4. **简化开发**
   - 开发者只需关注数据和模板，不必关心 DOM 操作细节。

------

## 4. 为什么要使用虚拟 DOM

- 原生 DOM 操作效率低，尤其是频繁增删节点或修改样式时。
- jQuery/原生操作需要自己手动优化 DOM 更新。
- 虚拟 DOM 可以：
  - 批量计算差异（diff），最小化操作；
  - 保持声明式编程风格；
  - 自动处理复杂更新逻辑。

------

## 5. DOM 遍历与 Diff 算法

### (1) Diff 算法

- Vue 通过 **双端比较 + key 优化** 来判断哪些节点需要更新。
- 核心思想：
  1. 先比较同层节点；
  2. 根据 key 匹配复用节点；
  3. 不同则创建新节点或删除旧节点。

### (2) DOM 遍历方式

- **深度优先**（DFS）：遍历整个虚拟 DOM 树，逐层比较。
- **广度优先**（BFS）：不常用，但有些优化场景可以用。

------

## 6. 虚拟 DOM 实现原理

1. **JS 对象模拟真实 DOM**
   - 每个 VNode 对象都对应真实 DOM 的节点结构。
2. **diff 算法**
   - 比较新旧虚拟 DOM 树，找出节点差异。
3. **patch 算法**
   - 根据 diff 结果，把最小差异更新到真实 DOM。

✅ **一句话总结**：

- **diff** 是“比对”的过程，决定哪些地方需要变。
- **patch** 是“执行”的过程，把 diff 结果真正更新到 DOM。

简化版流程：

```
数据变化
  ↓
新 VNode = render()  // 生成新虚拟 DOM
  ↓
diff(旧 VNode, 新 VNode) // 比较差异
  ↓
patch(差异)  // 更新真实 DOM
```

------

## 7. 举例对比

| 方式           | 优点                      | 缺点                         |
| -------------- | ------------------------- | ---------------------------- |
| jQuery / 原生  | 直接操作 DOM，立即生效    | 频繁操作性能差，逻辑复杂     |
| Vue + 虚拟 DOM | 数据驱动，最小化 DOM 更新 | 初次渲染稍慢，有额外内存开销 |

------

✅ **一句话总结**：
 虚拟 DOM 是 **对真实 DOM 的 JS 抽象**，通过 diff + patch 算法实现 **高效、声明式、可复用的 DOM 更新**，大幅提升前端开发效率和性能。

## 1. Diff 算法概念

- **作用**：比较 **两棵虚拟 DOM 树** 的差异，找出最小的更新操作。
- **核心原则**：
  1. 只比较 **同层级节点**；
  2. 标签名不同 → **直接替换**；
  3. 标签名 + key 相同 → **局部更新**；
  4. 使用 **深度优先遍历**，优先更新子节点（递归调用 `updateChildren`）。

## 2. Diff 遍历策略

- **深度优先遍历（DFS）**：
  1. 先对子节点递归处理；
  2. 再处理相邻节点。
- **子节点 diff**：
  - 如果子节点存在差异 → 局部更新；
  - 如果子节点不存在 → 添加或删除节点。

------

## 3. Patch 函数（核心入口）

`patch(oldVnode, vnode)` 作用：

1. **oldVnode 不存在** → 直接创建新节点。
2. **oldVnode 存在** → 调用 `patchVNode(oldVnode, vnode)`：
   - 调用 `sameVNode(oldVnode, vnode)` 判断是否是同一个节点：
     - 如果 **相同** → 局部 diff；
     - 如果 **不同** → 替换节点，删除老节点。

- 4. patchVNode 方法（局部更新）

    `patchVNode(oldVnode, vnode)` 步骤：

    1. **文本节点更新**
       - 如果 `oldVnode.text !== vnode.text` → 替换文本节点。
    2. **子节点更新**
       - 如果 vnode 没有文本节点 → 进入子节点 diff。
       - 如果 oldCh 和 ch 都存在 → 调用 `updateChildren(oldCh, ch, parentElm)`。
       - 如果 oldCh 不存在，ch 存在 → 清空文本并添加新节点。
       - 如果 oldCh 存在，ch 不存在 → 删除旧节点。
    3. **文本节点清理**
       - oldVnode 有文本，而 vnode 没有 → 清空文本。

  ------

    ## 5. updateChildren 方法（子节点 diff 核心）

    - 核心思想：通过 **双端索引 + key 映射** 最小化 DOM 操作。
    - 步骤：
      1. 给 `oldCh` 和 `ch` 分别分配 `startIndex` 和 `endIndex`。
      2. 遍历 oldCh 和 ch：
         - 比较头尾节点 (`startVnode` / `endVnode`) 是否相同；
         - 相同 → `patchVNode` 递归更新；
         - 不同 → 查找 key 是否存在 → 节点移动或创建；
      3. 当任意一端遍历结束 → 停止 diff 过程；
      4. 剩余节点：
         - oldCh 剩余 → 删除节点；
         - ch 剩余 → 创建节点。

  ------

    ## 6. Diff 算法优化点

    - **key 的作用**：
      - 帮助 Vue 快速找到节点对应关系，避免大量 DOM 重建。
    - **同层比较**：
      - Diff 只在同层节点进行，不会跨层比较，降低算法复杂度（O(n)）。
    - **双端比较**：
      - 从头和尾同时开始匹配，减少移动和查找开销。
    - **最小化 DOM 操作**：
      - 通过 patch + updateChildren 只修改必要节点。

  ------

    ## 7. 面试常考点总结

    | 考点                    | 说明                                   |
    | ----------------------- | -------------------------------------- |
    | diff 只比较同层节点     | 跨层节点不比较，减少复杂度             |
    | key 的作用              | 唯一标识节点，帮助复用和移动节点       |
    | patchVNode 逻辑         | 文本更新 → 子节点 diff → 添加/删除节点 |
    | updateChildren 核心流程 | 双端索引 + key 映射 + 剩余节点处理     |

  ------

    ✅ **一句话总结**：
     Vue 的 diff 算法通过 **同层比较 + key 优化 + 深度优先遍历**，在 `patchVNode` 和 `updateChildren` 中精确计算节点差异，从而实现 **最小化 DOM 更新**。

- ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209204451.png)

### 初始化Vue到最终渲染的整个过程

## 1️⃣ Vue 实例初始化（`new Vue()`）

1. **初始化配置**

   - Vue 构造函数中，会调用 `init` 方法：

     ```
     this._init(options)
     ```

   - `_init` 主要做的事情：

     - 合并用户配置（`options`）和默认配置。
     - 初始化生命周期（`_lifecycle`）、事件系统（`_events`）、响应式数据（`_data`）等。
     - 初始化 `props`、`methods`、`computed`、`watch` 等。

2. **挂载前钩子**

   - `beforeCreate` → `created` 生命周期钩子执行。

------

## 2️⃣ 响应式数据初始化（Observer + Dep）

1. Vue 会对 `data` 做 **数据劫持（Object.defineProperty）**
   - 每个数据属性会被 `Observer` 包装。
   - 数据变化时，会触发对应的 **依赖收集（Dep）**，更新视图。
   
2. **计算属性（computed）和 watch**
   
   - computed 会生成一个 **Watcher**，懒执行并缓存值。
   
     - **本质**：为某个表达式（依赖数据）创建一个 **惰性求值的 Watcher**。
     - **特点**：
       - **懒执行**：只有当访问 `this.xxx` 时，才会去计算 getter。
       - **缓存**：依赖不变时，取值会直接返回缓存，不会重复执行函数。
       - **依赖收集**：getter 内部访问的响应式数据会被追踪，数据变更时会标记 computed 脏（dirty = true），下次访问时才重新计算。
   
     - 原理简化代码
   
       🔑 总结：
   
       - `dirty = true` → 下次访问时重新计算。
       - `dirty = false` → 直接返回缓存。
       - `update()` → 依赖变化时触发，把 `dirty` 设为 true。
   
       ```js
       // ===== Watcher：核心类 =====
       class Watcher {
         constructor(getter, lazy = false) {
           this.getter = getter       // 计算函数（用户定义的 computed getter）
           this.lazy = lazy           // 是否惰性执行
           this.dirty = lazy          // dirty = true 表示需要重新计算
           this.value = undefined     // 缓存的值
           // 如果不是 lazy（普通 watcher），立即执行
           if (!lazy) {
             this.value = this.get()
           }
         }
         // 真正执行 getter，计算新值
         get() {
           return this.getter()
         }
         // 计算属性取值时调用
         evaluate() {
           if (this.dirty) {
             // 如果 dirty，重新计算，并更新缓存
             this.value = this.get()
             this.dirty = false
           }
           // 否则直接用缓存的 value
           return this.value
         }
         // 依赖变更时调用 -> 标记为 dirty
         update() {
           this.dirty = true
         }
       }
       // ===== 模拟 Vue 的 computed =====
       function defineComputed(getter) {
         const watcher = new Watcher(getter, true) // lazy = true，惰性执行
         return {
           get value() {
             // 访问 computed.value 时，走 evaluate，支持缓存
             return watcher.evaluate()
           },
           // 暴露 watcher，方便手动触发 update（模拟依赖变化）
           _watcher: watcher
         }
       }
       // ===== 使用示例 =====
       let state = { a: 1, b: 2 }
       // 定义一个计算属性 sum
       const sum = defineComputed(() => state.a + state.b)
       console.log(sum.value) // 3 -> 第一次访问，执行 getter，缓存 3
       console.log(sum.value) // 3 -> 第二次访问，直接返回缓存
       // 修改依赖
       state.a = 5
       sum._watcher.update()  // 模拟依赖变化通知 watcher
       console.log(sum.value) // 7 -> 因为 dirty = true，重新执行 getter，更新缓存
       console.log(sum.value) // 7 -> 再次访问，直接返回缓存
       ```
   
   - watch 也是一个 Watcher，监听数据变化。
   
     - **本质**：也是一个 **Watcher**，但它会在数据变化时触发回调函数。
   
     - **特点**：
   
       - **立即执行或异步执行**：默认异步（nextTick 执行），可设置 `{ immediate: true }`。
       - **无缓存**：依赖数据一旦变化就触发回调，不关心结果是否被使用。
       - **多用于副作用**：如发请求、操作 DOM、调用接口。
   
     - 原理简化代码
   
       ```js
       function watch(source, cb) {
         let oldValue
         const runner = new ReactiveEffect(() => source(), (newValue) => {
           cb(newValue, oldValue)
           oldValue = newValue
         })
         oldValue = runner.run()
       }
       ```
   
   - 区别对比
   
     | 特性         | computed                     | watch                           |
     | ------------ | ---------------------------- | ------------------------------- |
     | **是否缓存** | ✅ 有缓存                     | ❌ 无缓存                        |
     | **触发时机** | 依赖被访问时才重新计算       | 数据变化就回调                  |
     | **适用场景** | 依赖值 → 新值的 **映射关系** | 依赖值变化时执行 **副作用逻辑** |
     | **返回值**   | 一个值                       | 不返回值，只执行回调            |
     | **底层实现** | lazy 的 Watcher              | 普通 Watcher                    |

------

## 3️⃣ 模板编译（Template → Render Function）

1. **编译流程**：
   - `template` → `AST（抽象语法树）` → `Render 函数` → `VNode（虚拟 DOM）`。
   - Vue 2 的编译器把模板编译成 `render` 方法，这样每次渲染都生成 VNode 树。
2. **VNode（虚拟 DOM）**
   - 用 JS 对象表示 DOM 结构。
   - 包含标签、属性、子节点等信息。

------

## 4️⃣ Mount（挂载到 DOM）

1. 调用 `$mount(el)`：
   - 如果 `el` 存在，Vue 会把 VNode 渲染到真实 DOM 上。
   - 创建 **根 Watcher**（渲染 Watcher）：
     - Watcher 会调用 `render` 生成 VNode。
     - 然后通过 `patch` 方法把 VNode 转换成真实 DOM。

------

## 5️⃣ Virtual DOM Diff 与 Patch

1. **初次渲染**
   - VNode → DOM，直接挂载到页面。
2. **数据变化更新**
   - 数据变化触发对应 Watcher。
   - Watcher 调用 `render` 生成新的 VNode。
   - 新旧 VNode 通过 **diff 算法** 比较差异。
   - 只更新有变化的部分，减少 DOM 操作。

------

## 6️⃣ 最终渲染完成

- 页面显示为最终的真实 DOM。
- 后续数据变化，会触发 Watcher → 重新渲染 → diff → patch → DOM 更新。

------

### 🔑 总结流程

**Vue 2 从 new Vue() 到渲染的核心流程是：初始化配置和状态 → 建立响应式系统 → 编译模板生成 render 函数 → 创建渲染 Watcher → 执行 render 生成 Virtual DOM → patch 算法转换为真实 DOM 并挂载到页面。**

## 🎯 面试回答模板（30秒版本）

**"Vue 实例化后经历四个核心阶段：**

1. **状态初始化** - 处理 data、methods 等选项，建立响应式系统
2. **模板编译** - template 编译成 render 函数
3. **依赖收集** - 执行 render 函数生成 VNode，同时收集数据依赖
4. **DOM 渲染** - 通过 patch 算法将 VNode 转换为真实 DOM 挂载

**关键是响应式系统和渲染 Watcher 的配合：数据变化触发 setter → 通知 Watcher → 重新渲染"**

## 💡 加分回答（如果面试官深入问）

- **性能优化**：异步更新队列、Virtual DOM diff
- **依赖收集**：getter 时收集，setter 时通知
- **生命周期**：beforeCreate → created → beforeMount → mounted

```js
new Vue()
  └─ _init() 初始化
      ├─ 生命周期钩子 beforeCreate/created
      ├─ 初始化响应式 data/props/computed/watch
      └─ 事件系统初始化
  └─ template 编译 → render 函数 → VNode
  └─ $mount(el)
      ├─ 创建渲染 Watcher
      ├─ render → VNode
      └─ patch → 真正 DOM
  └─ 数据变化
      └─ Watcher 触发更新
          └─ 新旧 VNode diff → 更新 DOM
```

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220215214130.png)

## 1️⃣ MVVM & MVC

- **MVC（Model-View-Controller）**
  - Model：数据
  - View：视图
  - Controller：控制逻辑
  - 数据变化需要手动更新视图
- **MVVM（Model-View-ViewModel）**
  - Model：数据
  - View：视图
  - ViewModel：数据绑定逻辑
  - 数据变化自动驱动视图更新（双向绑定）

### Proxy & Object.defineProperty
- Proxy
	- Proxy可以直接监听对象而非属性；
	
	- 可以直接监听数组的变化
	
	  ```js
	  const handler = {
	    get(target, prop) {
	      // 拦截所有属性访问
	      return Reflect.get(target, prop);
	    },
	    set(target, prop, value) {
	      // 拦截所有属性设置
	      return Reflect.set(target, prop, value);
	    },
	    deleteProperty(target, prop) {
	      // 拦截属性删除
	      return Reflect.deleteProperty(target, prop);
	    }
	  };
	  
	  const proxy = new Proxy([], handler);
	  ```
	
	  ```js
	  function reactive(obj) {
	    return new Proxy(obj, {
	      get(target, key) {
	        track(target, key); // 依赖收集
	        return Reflect.get(target, key);
	      },
	      set(target, key, value) {
	        const oldValue = target[key];
	        const result = Reflect.set(target, key, value);
	        
	        // 特殊处理数组的 length 属性
	        if (key === 'length' && Array.isArray(target)) {
	          // 触发 length 相关更新
	        } else {
	          // 判断是新增还是修改
	          if (!target.hasOwnProperty(key)) {
	            trigger(target, 'add', key);
	          } else if (oldValue !== value) {
	            trigger(target, 'set', key);
	          }
	        }
	        return result;
	      },
	      deleteProperty(target, key) {
	        const hadKey = target.hasOwnProperty(key);
	        const result = Reflect.deleteProperty(target, key);
	        if (hadKey) {
	          trigger(target, 'delete', key);
	        }
	        return result;
	      }
	    });
	  }
	  ```
	
	- Proxy多达13种拦截方法；
	  get、set、has、deleteProperty、ownKeys、getOwnPropertyDescriptor、
	  defineProperty、preventExtensions、getPrototypeOf、isExtensible、
	  setPrototypeOf、apply、construct
	
	- Proxy返回一个新对象，我们只操作新对象；
	
	- Proxy持续优化；
	
	- 不支持IE；
	
	- Reflect 
	
	  - 1️⃣ Reflect 的作用
	    - 代替一些 `Object` 的方法，更“函数式”操作对象
	    - 返回布尔值表示操作是否成功，而不是抛出错误
	    - 常与 `Proxy` 配合，用于在拦截器里调用默认行为
	
	    Reflect 方法对照表
	    
	    | Reflect 方法               | 对应操作符                | 作用         |
	    | -------------------------- | ------------------------- | ------------ |
	    | `Reflect.get()`            | `obj.prop`                | 获取属性值   |
	    | `Reflect.set()`            | `obj.prop = value`        | 设置属性值   |
	    | `Reflect.has()`            | `key in obj`              | 检查属性存在 |
	    | `Reflect.deleteProperty()` | `delete obj.prop`         | 删除属性     |
	    | `Reflect.defineProperty()` | `Object.defineProperty()` | 定义属性     |
	    | `Reflect.ownKeys()`        | `Object.keys()`           | 获取所有键   |
	    
	  - 2️⃣ 常用方法
	
	| 方法                                               | 说明                                                  |
	| -------------------------------------------------- | ----------------------------------------------------- |
	| `Reflect.get(target, prop, receiver)`              | 获取属性值，类似 `target[prop]`                       |
	| `Reflect.set(target, prop, value, receiver)`       | 设置属性值，类似 `target[prop] = value`，返回是否成功 |
	| `Reflect.has(target, prop)`                        | 检查属性是否存在，类似 `prop in target`               |
	| `Reflect.deleteProperty(target, prop)`             | 删除属性，类似 `delete target[prop]`                  |
	| `Reflect.ownKeys(target)`                          | 获取对象自身的所有属性（包括 Symbol）                 |
	| `Reflect.getOwnPropertyDescriptor(target, prop)`   | 获取属性描述符                                        |
	| `Reflect.defineProperty(target, prop, descriptor)` | 定义属性，类似 `Object.defineProperty`                |
	| `Reflect.preventExtensions(target)`                | 阻止对象扩展，类似 `Object.preventExtensions`         |
	| `Reflect.isExtensible(target)`                     | 判断对象是否可扩展                                    |
	| `Reflect.getPrototypeOf(target)`                   | 获取原型，类似 `Object.getPrototypeOf`                |
	| `Reflect.setPrototypeOf(target, proto)`            | 设置原型，类似 `Object.setPrototypeOf`                |
	| `Reflect.apply(target, thisArg, args)`             | 调用函数，类似 `Function.prototype.apply`             |
	| `Reflect.construct(target, args, newTarget)`       | 构造函数调用，类似 `new target(...args)`              |
	
- Object.defineProperty
	- 支持IE9；
	
	- 只能遍历对象属性直接修改；
	
	- 不再优化；
	
	- 不能监听数组
	
	  - 为什么不监听数组下标
	
	    - 性能问题
	
	      - 数组包含大量元素，为每个索引都设置getter/setter会消耗大量内存
	      - 每次数组操作都要遍历整个数组，时间复制度为O(n)
	
	    - 下标不可控
	
	      - 数组长度动态变化，无法预先定义所有索引的响应式
	      - 数组操作（push/pop/shift/unshift）会改变索引位置
	
	    - 监听盲区
	
	      ```js
	      const arr = [1, 2, 3];
	      // Vue2 无法检测到这种直接索引赋值
	      arr[0] = 10; 
	      // Vue2 无法检测到数组长度变化
	      arr.length = 0;
	      ```
	
	    - 无法监听新增、删除
	
	      ```js
	      // 无法检测新增元素
	      arr[3] = 4;
	      // 无法检测元素删除
	      delete arr[0];
	      ```
## 对比总结

| 特性                    | `Object.defineProperty` | `Proxy`            |
| :---------------------- | :---------------------- | :----------------- |
| 数组索引访问/设置       | ❌ 无法监听              | ✅ 完全支持         |
| 数组方法操作 (push/pop) | ⚠️ 需重写方法            | ✅ 原生支持         |
| 数组长度变化            | ❌ 无法监听              | ✅ 支持 length 变更 |
| 新增/删除元素           | ❌ 无法监听              | ✅ 完全支持         |
| 性能表现                | ⚠️ 数组较大时性能差      | ✅ 高效             |
| 嵌套对象处理            | ⚠️ 需要递归初始化        | ✅ 惰性代理         |
| 浏览器兼容性            | ✅ IE9+                  | ❌ 不兼容 IE        |

### vue常用修饰符
- stop
	阻止冒泡
- prevent
	阻止默认事件（如：a标签的跳转）
- capture
	事件默认是由里往外冒泡；capture作用是由外往里捕获
- self
	点击事件绑定的本身才会触发事件
- once
	事件只执行一次
- passive
	相当于给onscroll事件添加一个.lazy修饰符（@scroll.passive="onScroll"）
- enter
- trim
	去除首尾空格
- number
	将v-model值转成数字
		22aa => 22
		aa22 => aa22（无效）
- lazy
	改变输入框的值时value不会改变；当光标离开输入框时，v-model绑定的值value才会改变
- sync
	配合this.$emit('update:xxx', data)
- native
	加在自定义组件的事件上，保证事件能执行

## 5️⃣ keep-alive

- **作用**：缓存组件，避免重复渲染
- **缓存机制**：`cache` 对象 + `keys` 队列
- **钩子**：`activated` / `deactivated`
- **原理**：基于 VNode 节点缓存组件实例
- **源码核心点**：`pruneCacheEntry` 清理缓存，监听 `include/exclude` 动态调整缓存
- **注意**：多层嵌套路由时，需每层 `router-view` 包裹 `keep-alive`

​	**源码核心**：

- 通过 key 标记组件实例
- 命中缓存 → 复用 vnode.componentInstance
- pruneCache 清理不满足 include/exclude 的缓存

- #### 源码 src/core/components/keep-alive.js

  ```js
  export default {
    name: 'keep-alive',
    abstract: true,
  
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number]
    },
  
    created () {
      this.cache = Object.create(null)
      this.keys = []
    },
  
    destroyed () {
      for (const key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys)
      }
    },
  
    mounted () {
      this.$watch('include', val => {
        pruneCache(this, name => matches(val, name))
      })
      this.$watch('exclude', val => {
        pruneCache(this, name => !matches(val, name))
      })
    },
  
    render() {
      /* 获取默认插槽中的第一个组件节点 */
      const slot = this.$slots.default
      const vnode = getFirstComponentChild(slot)
      /* 获取该组件节点的componentOptions */
      const componentOptions = vnode && vnode.componentOptions
  
      if (componentOptions) {
        /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */
        const name = getComponentName(componentOptions)
  
        const { include, exclude } = this
        /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */
        if (
          (include && (!name || !matches(include, name))) ||
          // excluded
          (exclude && name && matches(exclude, name))
        ) {
          return vnode
        }
  
        const { cache, keys } = this
        /* 获取组件的key值 */
        const key = vnode.key == null
          // same constructor may get registered as different local components
          // so cid alone is not enough (#3269)
          ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
          : vnode.key
       /*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance
          // make current key freshest
          remove(keys, key)
          keys.push(key)
        }
          /* 如果没有命中缓存，则将其设置进缓存 */
          else {
          cache[key] = vnode
          keys.push(key)
          // prune oldest entry
          /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode)
          }
        }
  
        vnode.data.keepAlive = true
      }
      return vnode || (slot && slot[0])
    }
  }
  ```

- #### 源码解析

  - this.cache

    是一个对象，用来存储需要缓存的组件，格式如下

    ```js
    this.cache = {
        'key1':'组件1',
        'key2':'组件2',
        // ...
    }
    ```

  - pruneCacheEntry

    在组件销毁的时候执行pruneCacheEntry函数

    ```js
    function pruneCacheEntry (cache: VNodeCache, key: string, keys: Array<string>, current?: VNode) {
      const cached = cache[key]
      /* 判断当前没有处于被渲染状态的组件，将其销毁*/
      if (cached && (!current || cached.tag !== current.tag)) {
        cached.componentInstance.$destroy()
      }
      cache[key] = null
      remove(keys, key)
    }
    ```

  - 监听include & exclude变化

    ```js
    mounted () {
        this.$watch('include', val => {
            pruneCache(this, name => matches(val, name))
        })
        this.$watch('exclude', val => {
            pruneCache(this, name => !matches(val, name))
        })
    }
    ```

    如果include或exclude发生变化，即表示定义（不）需要缓存的组件的规则发生了变化，则执行pruneCache函数

    ```js
    function pruneCache (keepAliveInstance, filter) {
      const { cache, keys, _vnode } = keepAliveInstance
      for (const key in cache) {
        const cachedNode = cache[key]
        if (cachedNode) {
          const name = getComponentName(cachedNode.componentOptions)
          if (name && !filter(name)) {
            pruneCacheEntry(cache, key, keys, _vnode)
          }
        }
      }
    }
    ```

# 📌 Vue Router + keep-alive 总结

## 1️⃣ 路由守卫类型

| 类型 | 守卫函数                                                    | 触发时机             | 是否可访问组件实例                     |
| ---- | ----------------------------------------------------------- | -------------------- | -------------------------------------- |
| 全局 | `beforeEach`、`afterEach`                                   | 每次路由切换         | beforeEach ❌，afterEach ❌              |
| 路由 | `beforeEnter`                                               | 进入路由时           | ❌                                      |
| 组件 | `beforeRouteEnter`、`beforeRouteUpdate`、`beforeRouteLeave` | 进入/更新/离开组件时 | Enter ❌（需 next(vm)）、Update/Leave ✅ |

- 全局守卫

```js
router.beforeEach((to, from, next) => {
  // 进入每个路由前执行
  next()
})
router.afterEach((to, from) => {
  // 路由切换后执行（无 next）
})
```

- 路由独享守卫

```js
const routes = [
  {
    path: '/user',
    component: User,
    beforeEnter: (to, from, next) => {
      // 只在进入 /user 路由时触发
      next()
    }
  }
]
```

- 组件内守卫

```js
export default {
  beforeRouteEnter(to, from, next) {
    // 进入组件前（不能访问 this）
    next(vm => {
      // 访问组件实例 vm
    })
  },
  beforeRouteUpdate(to, from, next) {
    // 当前组件被复用时路由参数变化触发
    next()
  },
  beforeRouteLeave(to, from, next) {
    // 离开组件时触发
    next()
  }
}
```

## 2️⃣ 路由模式

| 模式     | URL 示例  | 原理                                  | 备注                           |
| -------- | --------- | ------------------------------------- | ------------------------------ |
| hash     | `/#/home` | 监听 `hashchange`                     | 默认模式，兼容性好             |
| history  | `/home`   | `pushState/replaceState` + `popState` | 需服务器支持 Nginx `try_files` |
| abstract | 无 URL    | 内部维护一个栈                        | Node 环境/测试                 |

------

## 3️⃣ keep-alive 配合路由

- **作用**：缓存组件状态，避免重复渲染。
- **生命周期**：
  - 第一次进入组件：`created → mounted → activated`
  - 离开组件：`deactivated`
  - 再次进入组件：只触发 `activated`
- **原理**：
  - Vue 将 DOM 抽象为 VNode。
  - keep-alive 将符合条件的组件 VNode 存入 `cache` 对象。
  - 下次渲染时从 `cache` 取出 VNode，避免重新创建 DOM。
- **踩坑**：
  - 多级嵌套路由，只缓存到二级组件。
  - 解决办法：每层 `router-view` 都包一层 `keep-alive`。

------

## 4️⃣ 路由懒加载

- 动态加载路由组件，按需打包。
- **优点**：
  - 初始包体积更小，首屏加载快。
  - 后续路由访问时再加载对应 chunk，提高性能。

------

✅ 一句话总结：

> 路由懒加载按需加载组件分包，keep-alive 缓存组件 VNode，结合路由守卫可以控制组件的进入/离开逻辑，多级嵌套时每层 router-view 都需包裹 keep-alive 才能正确缓存。
