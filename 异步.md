# 异步

## 方案

### callback

### Promise

### generator

### async/await



### 相关题目

1. 红灯3s亮一次，绿灯1s亮一次，黄灯2s亮一次；如何让3个灯不断交替重复亮灯？

​		3个灯函数已存在

```javascript
function red() { console.log('red') }
function green() { console.log('green') }
function yellow() { console.log('yellow') }
```

- callback回调

```javascript
const task = (time, light, callback) => {
	setTimeout(() => {
		switch (light) {
			case 'red': red()
				break
			case 'green': green()
				break
			case 'yellow': yellow()
				break
		}
		callback()
	}, time)
}
const step = () => {
	task(3000, 'red', () => {
		task(1000, 'green', () => {
			task(2000, 'yellow', step)
		})
	})
}
step()
```

- promise实现

```javascript
const task = (time, light) => {
	return new Promise((resolve, reject) => {
		setTimeout(() => {
			switch (light) {
				case 'red': red()
					break
				case 'green': green()
					break
				case 'yellow': yellow()
					break
			}
			resolve()
		}, time)
	})
}
const step = () => {
	task(3000, 'red')
		.then(() => task(1000, 'green'))
		.then(() => task(2000, 'yellow'))
		.then(step)
}
step()
```

- async/await

```javascript
const task = (time, light) => {
	return new Promise((resolve, reject) => {
		setTimeout(() => {
			switch (light) {
				case 'red': red()
					break
				case 'green': green()
					break
				case 'yellow': yellow()
					break
			}
			resolve()
		}, time)
	})
}
step = async () => {
	await task(3000, 'red')
	await task(1000, 'green')
	await task(2000, 'yellow')
	step()
}
step()
```



## 真实场景案例

### 请求图片进行预先加载

​		假设预先有urlIds数组，数组每一项都可以按照规则拼接成一个完整的图片地址，根据这个数组，请求图片进行预加载。

```javascript
// 请求图片的方法
const loadImg = urlId => {
  const url = `https://www.image.com/${urlId}`
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.onload = function() {
      resolve(urlId)
    }
    img.onerror = function() {
      reject(urlId)
    }
    img.src = url
  })
}

// urlIds数组
const urlIds = [1,2,3,4,5] 
```

1. 依次请求图片：

- reduce方法 

```javascript
urlIds.reduce((prevPromise, urlId) => {
  return prevPromise().then(() => loadImg(urlId))
}, Promise().resolve())
```

- async/await实现

```javascript
const loadImgByOne = async () => {
	for(let i of urlIds) {
    await loadImg(urlIds[i])
  }
}
loadImgByOne()
```

- 面向过程实现

```javascript
const loadImgByOne = index => {
  const len = urlIds.length
  loadImg(urlIds[index]).then(() => {
    if (index === len - 1) {
      return
    }
    loadImgByOne(++index)
  })
}
loadImgByOne(0)
```

2. 批量请求图片，一次性全部发出

```javascript
const promiseArray = urlIds.map(urlId => loadImg(urlId))
Promise.all(promiseArray)
	.then(() => {
	  console.log('finish load all img')
	})
	.catch(() => {
  	console.log('promise all catch')
	})
```

3. 批量请求，控制最大并发数为3

```javascript
const loadByLimit = (urlIds, loadImg, limit) => {
  const urlIdsCopy = [...urlIds]
  // 如果数组数量小于最大并发数，直接请求全部数据
  if (urlIdsCopy.length <= limit) {
    const promiseArray = urlIds.map(urlId => loadImg(urlId))
    return Promise.all(promiseArray)
  }

  // 从下标为0开始，截取数组长度为最大并发数
  const promiseArray = urlIdsCopy.splice(0, limit).map(urlId => loadImg(urlId))
  
  // 遍历数组，执行请求函数
  urlIdsCopy.reduce((prevPromise, urlId) => {
    return prevPromise
   		// 利用Promise.race方法请求数据
      .then(() => Promise.race(promiseArray))
      .catch(error => { console.log(error) })
    	// 获取Promise.race第一个请求完成的数据id
      .then((resolvedId) => {
      	// 找出已经请求完成的数据id，将其移除promiseArray批量请求数组，并push下一个新的urlId
        let resolvedIdPosition = promiseArray.findIndex(id => resolvedId === id)
        promiseArray.splice(resolveIdPosition, 1)
        promiseArray.push(loadImg(urlId))
      })
  },
   	// reduce初始值
    Promise.resolve()
  ).then(() => Promise.all(promiseArray))
}
```



