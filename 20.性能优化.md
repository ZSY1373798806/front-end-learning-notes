## 前端性能优化方案
## 1. 缓存优化

- **HTTP 缓存**
  - 设置 `Cache-Control / Expires / ETag / Last-Modified`
  - 静态资源加 `hash`，版本更新时自动失效
- **浏览器缓存**
  - 本地数据存储 `localStorage / IndexedDB / sessionStorage`
- **Service Worker**
  - PWA 离线缓存

## 2. 移除控制台打印

- **Webpack 插件**

  ```
  new TerserPlugin({
    terserOptions: { compress: { drop_console: true } }
  })
  ```

- **Babel 插件**

  - 使用 `babel-plugin-transform-remove-console`

## 3. CDN 加速

- 静态资源（JS、CSS、图片）上传到 CDN
- **DNS 负载均衡**
  - 自动选择最近的节点
- **缓存更新策略**
  - 主动刷新（API 调用刷新节点缓存）
  - 被动拉取（过期自动回源）

## 4. 路由懒加载

- **Vue Router**

  ```js
  const Home = () => import('@/views/Home.vue')
  ```

## 5. 按需引入

- **组件库**

  - `babel-plugin-import`（AntD）
  - `babel-plugin-component`（ElementUI）

- **lodash**

  ```js
  import debounce from 'lodash/debounce'
  ```

## 6. CSS 雪碧图 & iconfont

- **工具**
  - `spritesmith` 自动生成雪碧图
  - `iconfont.cn` 使用字体图标代替小图

## 7. 小图片打包成 base64

- **Webpack Loader**

  ```js
  {
    test: /\.(png|jpg|gif)$/,
    loader: 'url-loader',
    options: { limit: 8192 } // 小于8kb转base64
  }
  ```

## 8. 图片上传压缩

- **Canvas 压缩**

  ```
  const canvas = document.createElement("canvas")
  const ctx = canvas.getContext("2d")
  ctx.drawImage(img, 0, 0, w, h)
  canvas.toBlob((blob) => { ... }, 'image/jpeg', 0.7)
  ```
  
- [D:\Data\前端学习笔记\前端面试知识点总结\canvas图片压缩.md](D:\Data\前端学习笔记\前端面试知识点总结\canvas图片压缩.md)

## 9. 大文件上传

- **分片上传**
  - `Blob.slice`
- **断点续传**
  - 进度保存 `LocalStorage + 服务端 DB`
- **秒传**
  - 上传前计算 `MD5`，存在即跳过
- **并发控制**
  - 限制 `3~5` 并发，提升速度

- #### 实现

  - ##### 一、切片文件标识方案

    每个切片需要包含以下核心标识信息：

    - **文件唯一指纹**

    - 使用 `文件内容哈希值`（如MD5/SHA1）作为文件唯一ID

    - 避免文件名重复导致冲突（示例：`8f4d87fd5a6d5a17e8e8234e7b1a2b3c`）

    - **切片序号**

    - 从0开始的连续编号（示例：`chunk-0023`）

    - **附加元信息**（可选）：

      ```js
      {
        "totalChunks": 45,       // 总切片数
        "fileName": "原始文件名.zip",
        "fileSize": 524288000,    // 文件总字节数
        "chunkSize": 10485760     // 单切片大小(10MB)
      }
      ```

  - ##### 二、进度记录实现方案

    - 客户端存储

      ```js
      // 保存进度到LocalStorage
      function saveProgress(fileHash, progress) {
        localStorage.setItem(`upload_${fileHash}`, JSON.stringify({
          timestamp: Date.now(),
          uploadedChunks: progress // 如 [0,1,2,3,5,6]
        }));
      }
      
      // 读取进度
      function loadProgress(fileHash) {
        const data = localStorage.getItem(`upload_${fileHash}`);
        return data ? JSON.parse(data).uploadedChunks : [];
      }
      ```

    - 服务端存储

      ```js
      // 数据库记录设计
      {
        file_id: "8f4d87fd5a6d5a17", // 文件哈希
        user_id: "user123",          // 用户ID
        chunks_done: [0,1,2,3,5,6], // 已传切片序号
        total_chunks: 45,
        last_updated: 1692086400000  // 最后更新时间戳
      }
      ```

  - ##### 三、断点续传工作流程

    ```mermaid
    sequenceDiagram
        participant Client
        participant Server
        Client->>Server: 1. 提交文件哈希请求续传
        Server-->>Client: 2. 返回缺失切片序号 [4,7,8...]
        loop 上传缺失切片
            Client->>Server: 3. 上传切片(chunk-0004)
            Server-->>Client: 4. 确认接收并更新进度
        end
        Client->>Server: 5. 请求合并文件
        Server->>Server: 6. 按序拼接所有切片
        Server-->>Client: 7. 返回最终文件URL
    ```

  - ##### 四、关键代码实现

    - 客户端上传逻辑

    ```js
    async function resumeUpload(file) {
      // 1. 生成文件哈希
      const fileHash = await calculateMD5(file);
      
      // 2. 获取上传进度
      const { missingChunks } = await fetch(`/api/progress?hash=${fileHash}`);
      
      // 3. 切片上传
      const chunkSize = 10 * 1024 * 1024; // 10MB
      for (const chunkIndex of missingChunks) {
        const start = chunkIndex * chunkSize;
        const chunk = file.slice(start, start + chunkSize);
        
        const formData = new FormData();
        formData.append('chunk', chunk);
        formData.append('hash', fileHash);
        formData.append('index', chunkIndex);
        formData.append('total', Math.ceil(file.size / chunkSize));
        
        await fetch('/api/upload', { method: 'POST', body: formData });
      }
      
      // 4. 合并请求
      await fetch(`/api/merge?hash=${fileHash}&filename=${file.name}`);
    }
    ```

    - 服务端接口示例（Node.js）

    ```js
    // 进度查询接口
    app.get('/api/progress', (req, res) => {
      const { hash } = req.query;
      const progress = db.getProgress(hash);
      
      // 计算缺失切片
      const allChunks = Array.from({length: progress.total}, (_,i)=>i);
      const missing = allChunks.filter(i => !progress.chunks_done.includes(i));
      
      res.json({ missingChunks: missing });
    });
    
    // 切片上传接口
    app.post('/api/upload', (req, res) => {
      const { index, hash } = req.body;
      const chunk = req.files.chunk;
      
      // 保存切片文件
      fs.writeFileSync(`./chunks/${hash}_${index}`, chunk.data);
      
      // 更新数据库进度
      db.updateProgress(hash, index);
      
      res.sendStatus(200);
    });
    ```

  - ##### 优化

    - 切片验证：
      每个切片上传时携带 `Content-MD5` 头，服务端校验完整性

    - 自动清理：
      服务端定期清理超过7天的未完成上传

    - 并发控制：
      客户端同时上传3-5个切片提升速度：

      ```js
      const parallelCount = 3;
      await Promise.allSettled(
        missingChunks.slice(0, parallelCount).map(uploadChunk)
      );
      ```

    - 恢复点保护：
      客户端异常关闭时通过 `beforeunload` 事件保存进度：

      ```js
      window.addEventListener('beforeunload', () => {
        saveProgress(fileHash, currentProgress);
      });
      ```


## 10. Gzip 压缩

- **设置header**

  ```js
  Accept-Encoding: gzip;
  ```

- **Webpack 插件**

  ```js
  new CompressionWebpackPlugin({ algorithm: 'gzip' })
  ```

- **Nginx**

  ```js
  gzip on;
  gzip_types text/css application/javascript;
  ```

### 11. 图片懒加载
- vue-lazyload

- 使用 `loading="lazy"`（原生方式）

  ```html
  <img src="image.jpg" loading="lazy" alt="Lazy Loaded Image">
  ```

- 使用 Intersection Observer API

```js
// 使用 IntersectionObserver 创建一个观察器，配置其行为（如视口、边距、阈值等）
const ob = new IntersectionObserver((entries) => {  
    //entries是一个数组，包含所有被观察的元素的状态信息
    for(const entry of entries){
        if(entry.isIntersecting){
            const img = entry.target;
            img.src = img.dataset.src; // 将图片的实际 URL 从 data-src 属性赋值给 src 属性
            ob.unobserve(img); // 取消观察
        }
    }
}, {  // 配置参数
    root:null,  // 默认为null，观察视口
    rootMargin:'0px', // 基于视口扩散或收缩的距离，默认为'0px'
    threshold:0  // 阈值 默认为0,即接触就运行回调，1为完整进入才运行回调
})

const imgs = document.querySelectorAll("img[data-src]"); // 拿到所有data-src的图片
imgs.forEach((img) => {  // 循环观察图片
    ob.observe(img); 
})
```
- 优点：只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。
## 12. 尽量用 CSS 代替图片

- 使用 `box-shadow / linear-gradient / border-radius`

## 13. 减少 ES6 ➜ ES5 冗余代码

- **Babel**
  - 使用 `@babel/plugin-transform-runtime`

```js
.babelrc 
"plugins": [
    "transform-runtime"
]
```
## 14. 减少重排重绘

- **样式修改**
  - 使用 `classList` 替换多次 `style`
- **批量操作**
  - 使用 `DocumentFragment`
- **动画优化**
  - 用 `transform / opacity` 代替 `top / left`

## 15. 使用事件委托

- 监听父节点，减少子元素绑定

  ```
  document.body.addEventListener("click", e => {
    if(e.target.matches(".btn")) { ... }
  })
  ```

## 16. 使用 requestAnimationFrame 实现动画

- 浏览器自动优化，避免掉帧

  ```js
  function animate() {
    requestAnimationFrame(animate)
    // 动画逻辑
  }
  animate()
  ```

`requestAnimationFrame`也是个定时器，不同于`setTimeout`，它的时间不需要我们人为指定，这个时间取决于当前电脑的刷新率，如果是 60Hz ，那么就是 16.7ms 执行一次，如果是 120Hz 那就是 8.3ms 执行一次

## 17. 使用 Web Workers

- 处理大计算任务，避免阻塞主线程

  ```js
  const worker = new Worker("worker.js")
  worker.postMessage(data)
  worker.onmessage = e => console.log(e.data)
  ```

### 18. 动画用 transform / opacity
- 优点 这两个属性更改不会触发重排和重绘；它们是有合成器单独处理的属性；只触发 GPU 合成
## 19. 使用 computed 缓存计算数据

- 避免在模板里写复杂表达式

## 20. 取消 sourceMap

- **生产环境**

  ```
  configureWebpack: { devtool: false }
  ```

## 21. 事件销毁

- **Vue 生命周期**

  ```js
  onUnmounted(() => {
    clearInterval(timer)
    window.removeEventListener('resize', handler)
  })
  ```

### 22. 插件按需引入
- 实现 babel-plugin-component
```js
.babelrc 
{
  "presets": [["es2015", { "modules": false }]],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ]
  ]
}
main.js
import Vue from 'vue';
import { Button, Select } from 'element-ui';
Vue.use(Button)
Vue.use(Select)
```
### Vue全局组件自动加载
	require.context
```js
import { createApp } from 'vue';
export function registerGlobalComponent(app: ReturnType<typeof createApp>): void {
  const files = (require as any).context('./global', true, /\.(vue|ts)$/)
  console.log(files)
  
  files.keys().forEach((key) => {
    files(key)
    const compName = key.replace(/^\.\//, '').replace(/.(vue|ts)$/, '')
    const config = files(key).default || files(key)
    app.component(compName, config)
  })
}
```

# 前端性能优化对照表

| 分类           | 优化点                | 解决方案                     | 工具/代码示例                                                |
| -------------- | --------------------- | ---------------------------- | ------------------------------------------------------------ |
| **构建优化**   | 移除控制台打印        | 构建时去掉 `console.log`     | `terser-webpack-plugin` → `drop_console: true`；`babel-plugin-transform-remove-console` |
|                | 按需引入              | 按需加载 UI 库组件           | `babel-plugin-import` (AntD)；`babel-plugin-component` (ElementUI) |
|                | 小图片转 base64       | 小图转 base64，减少请求      | `url-loader?limit=8192`                                      |
|                | 取消 sourceMap        | 生产环境去掉 map 文件        | `configureWebpack: { devtool: false }`                       |
|                | 减少 ES6 → ES5 冗余   | 复用 Babel helper 函数       | `@babel/plugin-transform-runtime`                            |
| **网络优化**   | CDN 加速              | 静态资源放 CDN，边缘节点缓存 | 配置 CDN，带版本 hash，主动刷新缓存                          |
|                | 缓存策略              | 浏览器缓存 + 服务端缓存      | `Cache-Control` / `ETag` / `Last-Modified`；Service Worker 离线缓存 |
|                | Gzip 压缩             | 压缩资源传输                 | `compression-webpack-plugin`；Nginx `gzip on;`               |
|                | 图片懒加载            | 延迟加载可视区图片           | `<img loading="lazy">`；`IntersectionObserver`               |
|                | 大文件上传优化        | 分片、断点续传、秒传、并发   | `Blob.slice`；进度保存 localStorage + DB；MD5 文件指纹；并发上传控制 |
|                | 图片上传压缩          | 前端压缩再上传               | `canvas.toBlob((b)=>{...}, 'image/jpeg', 0.7)`               |
| **渲染优化**   | 路由懒加载            | 路由组件按需加载             | `const Home = () => import('@/views/Home.vue')`              |
|                | CSS 雪碧图 & iconfont | 合并小图，减少请求           | `spritesmith`；阿里 iconfont                                 |
|                | 使用 CSS 代替图片     | 渐变/阴影替换图片            | `linear-gradient` / `box-shadow`                             |
|                | 减少重排重绘          | 批量修改样式 & DOM           | 用 `classList` 批量替换；`DocumentFragment` 批处理 DOM       |
|                | 动画优化              | 使用 GPU 加速属性            | `transform / opacity`；`requestAnimationFrame` 实现动画      |
| **运行时优化** | 使用事件委托          | 减少大量子节点监听           | 父级绑定事件 `e.target.matches()`                            |
|                | 使用 Web Workers      | 计算任务放到子线程           | `const worker = new Worker("worker.js")`                     |
|                | 使用 computed         | 缓存计算结果                 | Vue `computed()`                                             |
|                | 事件销毁              | 清理定时器和监听器           | Vue `onUnmounted(() => clearInterval(timer))`                |
|                | 全局组件自动加载      | 批量注册组件                 | `require.context` 或 `import.meta.glob`                      |