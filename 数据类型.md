# 数据类型

## 类型判断

###  基本数据类型

​		number string boolean bull undefined binint

### 复杂数据类型

​		object 包含（function、array、date等） symbol 

### 数据类型判断

#### typeof

1. 基本数据类型可使用typeof来判断：

```javascript
typeof 5 // 'number'
typeof 'js' // 'string'
typeof true // 'boolean'
typeof undefined // 'undefined'
typeof 99n // 'bigint'
```

2. 也有存在一些特例，比如类型为null时：

```javascript
typeof null === 'object'
```

3. 在用来判断复杂类型时：

```javascript
const foo = () => 1
typeof foo // 'function'
const foo = {}
typeof foo // 'oeject'
const foo = []
typeof foo // 'object'
const foo = new Date()
typeof foo // 'object'
typeof Symbol(1) // 'symbol'
```

因此我们可以得出:

###### 结论

​		使用typeof可以准确的判断出除null以外的所有基本类型、以及function类型和symbol类型；null类型会被判断为object

#### instanceof

​		使用 a instanceof A 用于判断a是否为A的实例，即a的原型链上是否存在A的构造函数

​		例：

```javascript
function Book(name) {this.name = name}
const book = new Book('javascript')
book instanceof Book // true
```

​		这里book是Book构造出来的实例，顺着book的原型链，可得Object的构造函数：

```javascript
book.__proto__.__proto__ === Obejct.prototype
```

​		因此：

```javascript
book instanceof Object // true
```

​		注意：

```javascript
2 instanceof Number // false
new Number(2) instanceof Number // true
```

​		手写instanceof方法

```javascript
instanceofFun = (data, type) => {
  if (typeof data !== 'object') {
    return false
  }

  while(true) {
    if (data === null) {
      return false
    } else {
      if (data.__proto__ === type.prototype) {
        return true
      } else {
        data = data.__proto__
      }
    }
  }
}
instanceofFun('', String) // false
instanceofFun(5, Number) // false
instanceofFun(new Number(5), Number) // true
instanceofFun({}, Object) // true
instanceofFun(new Date(), Object) // true
instanceofFun(book, Book) // true
```

#### Object.prototype.toString

​		称之为判断类型的万能方法，结果为'[object, Object]'格式：

```javascript
Object.prototype.toString.call(1) // '[object Number]'
Object.prototype.toString.call('javascript') // '[object String]'
Object.prototype.toString.call(undefined) // '[object Undefined]'
Object.prototype.toString.call(null) // '[object Null]'
Object.prototype.toString.call(99n) // [object BigInt]
Object.prototype.toString.call(Symbol(1)) // '[object Symbol]'
Object.prototype.toString.call([]) // '[object Array]'
Object.prototype.toString.call({}) // '[object Object]'
Object.prototype.toString.call(function(){}) // '[object Function]'
```

#### constructor

​	通过constructor查看目标构造函数来判断数据类型：

```javascript
const foo = 1
foo.constructor // ƒ Number() { [native code] }
const foo = 'javascript'
foo.constructor // ƒ String() { [native code] }
const foo = true
foo.constructor // ƒ Boolean() { [native code] }
const foo = 99n
foo.constructor // ƒ BigInt() { [native code] }
const foo = () => {}
foo.constructor // ƒ Function() { [native code] }
const foo = {}
foo.constructor // ƒ Object() { [native code] }
const foo = []
foo.constructor // ƒ Array() { [native code] }
const foo = new Date()
foo.constructor // ƒ Date() { [native code] }
const foo = Symbol(1)
foo.constructor // ƒ Symbol() { [native code] }
const foo = undefined
foo.constructor // Uncaught TypeError: Cannot read property 'constructor' of undefined
    at <anonymous>:1:5
const foo = null
foo.constructor // Uncaught TypeError: Cannot read property 'constructor' of null
    at <anonymous>:1:5
```



## 类型转换

### 隐式转换

​		关于数据类型的隐式转换，取决于javascript的特点决定的：

​			javascript是一种弱类型或者说动态语言。这意味着不需要提前声明变量的类型，在程序运行过程中，会自动确定变量的类型。

1. 基本类型相加：

```javascript
1 + '1' // 11
1 + true // 2
1 + false // 1
1 + undefined // NaN
1 + null // 1
'javascript' + undefined // javascriptundefined
'javascript' + false // javascriptfalse
```

###### 结论

​		当基本类型进行加法运算时，若表达式为'string'类型与其他类型相加，则都会转换成'string'类型进行相加；否则，都会转换成’number‘类型相加。

1. 复杂类型相加：  

```javascript
{} + true // [object Object]true
{} + [] // [object Object]
[] + true // true
```

###### 结论

​		当复杂类型进行加法运算时，会将复杂类型转换为基本类型后，再进行运算。

###### 提示

​		对象类型转基本类型的过程中，遵循一下规则：

> 对象类型转换基本类型时，会调用改对象上的toString和valueOf两个方法，该方法返回一个转换为基本类型后的结果；
>
> 具体调用哪一个，取决于ES规范所决定的：简单来说，这个对象倾向于转换成什么，就会优先调用那个方法；
>
> 如果倾向于Number类型，就优先调用valueOf；如果倾向于String类型，就会优先调用toString方法。



 valueOf和toString方法被重写，例如：

```javascript
const foo= {
	...
	toString() {
		return 'javscript'
	},
  valueOf() {
		return 99
	}
}

例：
// 这里执行了alert打印输出，倾向于转换成String，于是调用toString()方法
alert(foo) // javascript

// 进行了加法运算，倾向于转换成Number类型，调用valueOf()方法
1 + foo // 100
```

### 显式转换

​		Number、Boolean、String、parseInt等方法。

​		



## 相关题目

1. 请问 a == 1 && a == 2 && a== 3 可能为true吗？ 

   > 解题思路:
   >
   > 直观上分析，如果a是个基本的Number类型，本题是不可能成立的；
   >
   > 因此我们要从变量的类型转换入手

   1. 方案1：定义a为一个对象，并重写toString方法，因此每次调用a时都会将value自加1；同样，重写valueOf方法也能达到同样的效果。

      ```javascript
      const a = {
        value: 1,
        toString() {
          return this.value ++
        }
      }
      
      a == 1 && a == 2 && a== 3 // true
      ```

   2. 方案2：定义一个全局变量value，将a作为属性挂载在window对象中，并重写getter方法，每次调用a时将返回value加1的值。

      ```javascript
      let value = 1
      Object.defineProperty(window, 'a', {
         get: function() {
             return value++
         }
      })
      a == 1 && a == 2 && a== 3 // true
      ```

      