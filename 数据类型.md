# 数据类型（Data Types）

## 1. 类型分类

| 类型分类             | 类型                                                         |
| -------------------- | ------------------------------------------------------------ |
| 基本类型             | `number`、`string`、`boolean`、`undefined`、`null`、`bigint`、`symbol` |
| 复杂类型（引用类型） | `object`（包含 `Array`、`Function`、`Date` 等）              |

------

## 2. 数据类型判断方法

### 2.1 typeof

- 用于判断基本类型和函数、symbol

```
typeof 5           // 'number'
typeof 'js'        // 'string'
typeof true        // 'boolean'
typeof undefined   // 'undefined'
typeof 99n         // 'bigint'
typeof Symbol(1)   // 'symbol'
typeof function(){} // 'function'
typeof {}          // 'object'
typeof []          // 'object'
typeof null        // 'object'  // 特例
```

> 注意：`null` 会被识别为 `'object'`，这是历史遗留问题。

------

### 2.2 instanceof

- 判断对象是否为某个构造函数实例（检查原型链）

```
function Book(name) { this.name = name }
const book = new Book('js')

book instanceof Book    // true
book instanceof Object  // true
2 instanceof Number     // false
new Number(2) instanceof Number // true
```

- 手写 `instanceof` 函数

```
function instanceofFun(obj, type) {
  if (typeof obj !== 'object' || obj === null) return false
  let proto = Object.getPrototypeOf(obj)
  while (proto) {
    if (proto === type.prototype) return true
    proto = Object.getPrototypeOf(proto)
  }
  return false
}
```

------

### 2.3 Object.prototype.toString（万能方法）

```
Object.prototype.toString.call(1)        // '[object Number]'
Object.prototype.toString.call('js')     // '[object String]'
Object.prototype.toString.call(null)     // '[object Null]'
Object.prototype.toString.call([])       // '[object Array]'
Object.prototype.toString.call({})       // '[object Object]'
Object.prototype.toString.call(function(){}) // '[object Function]'
Object.prototype.toString.call(Symbol(1)) // '[object Symbol]'
```

> 能准确区分各种类型，包括 `null`、数组等复杂类型。

------

### 2.4 constructor

- 通过对象的构造函数判断类型

```
(1).constructor       // Number
'js'.constructor      // String
true.constructor      // Boolean
99n.constructor       // BigInt
[].constructor        // Array
({}).constructor      // Object
new Date().constructor // Date
(() => {}).constructor // Function
```

> 注意 `null` 和 `undefined` 没有 constructor，会报错。

------

## 3. 类型转换

### 3.1 隐式转换（Implicit Conversion）

- JS 是弱类型语言，会在运行时自动转换类型。

#### 基本类型相加

```
1 + '1'      // '11'
1 + true     // 2
1 + false    // 1
1 + undefined // NaN
1 + null     // 1
'js' + undefined // 'jsundefined'
```

> 原则：与字符串相加会转换为字符串，其余转为数字。

#### 复杂类型相加

```
{} + true // '[object Object]true'
{} + []   // '[object Object]'
[] + true // 'true'
```

> 对象类型会先调用 `toString` 或 `valueOf` 转为基本类型，再参与运算。

- 示例：

```
const foo = {
  toString() { return 'javascript' },
  valueOf() { return 99 }
}

alert(foo)   // 'javascript'  → 倾向 String，调用 toString
1 + foo      // 100           → 倾向 Number，调用 valueOf
```

------

### 3.2 显式转换（Explicit Conversion）

- `Number()`, `String()`, `Boolean()`, `parseInt()`, `parseFloat()` 等

```
Number('123') // 123
String(123)   // '123'
Boolean(0)    // false
```

------

## 4. 类型相关题目

### 题目：`a == 1 && a == 2 && a == 3` 为真

#### 方案1：对象重写 `toString` 或 `valueOf`

```
const a = { value: 1, toString() { return this.value++ } }
a == 1 && a == 2 && a == 3 // true
```

#### 方案2：全局变量 + getter

```
let value = 1
Object.defineProperty(window, 'a', {
  get() { return value++ }
})
a == 1 && a == 2 && a == 3 // true
```

> 核心：每次比较时 JS 会调用对象的类型转换方法，使值逐次变化。