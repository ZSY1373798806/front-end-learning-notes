## **1️⃣ 性能排序（从高到低）**

1. **Vue3 Template** ✅
2. Vue3 JSX
3. React JSX
4. Vue2 Template

**原因**：主要来自编译时优化、虚拟 DOM diff 算法、响应式系统效率三个核心因素。

## **2️⃣ 核心性能分析**

### **Vue3 Template 性能最优**

- **编译时优化**：
  - **静态节点提升**（Static Hoisting）：静态内容抽取为常量，跳过重复 diff。
  - **补丁标志 Patch Flags**：标记动态部分，只更新必要节点。
  - **树结构打平**：动态节点单独存储，减少遍历静态子树。
- **运行时优化**：
  - 虚拟 DOM diff 最小化，渲染函数高度优化。

### **Vue3 JSX **

- 没有模板编译时优化。
- 仍能受益于 Vue3 的 Proxy 响应式和高效 diff 算法。
- 性能略低于模板，但比 Vue2/React 高。

### **React JSX **

- JSX 编译为 `React.createElement`，生成完整虚拟 DOM。
- 性能依赖开发者手动优化（`React.memo`、`useMemo`）。
- Fiber 架构支持并发模式，提高用户体验，但基准性能仍低于 Vue3。

### **Vue2 Template**

- 静态节点缓存有限（只缓存静态根节点）。
- 无补丁标志，每次 diff 全量比对。

### Vue2 & Vue3 对比

### ⚙️ **一、响应式系统原理**

| **特性**         | **Vue 2**                          | **Vue 3**                        | **优势对比**                                                 |
| :--------------- | :--------------------------------- | :------------------------------- | :----------------------------------------------------------- |
| **实现机制**     | `Object.defineProperty` 劫持属性   | `Proxy` 代理整个对象             | Proxy 支持动态增删属性、数组索引修改等原生操作，无需 `Vue.set` |
| **数组监听**     | 重写数组方法（如 `push`/`splice`） | 直接监听数组索引和 `length` 变化 | 简化数组操作逻辑，避免 hack 处理                             |
| **深层响应**     | 初始化时递归遍历所有属性           | 惰性代理（访问嵌套属性时才代理） | 减少初始化开销，提升大型对象性能                             |
| **数据类型支持** | 仅支持 Object/Array                | 支持 Map/Set/WeakMap 等复杂类型  | 更适应现代 JS 数据结构                                       |

> 💡 **示例对比**
> **Vue 2 动态属性**：需 `this.$set(obj, 'newProp', value)`
> **Vue 3 动态属性**：直接 `obj.newProp = value`

### ⚡ **二、性能优化机制**

| **优化策略**     | **Vue 2**              | **Vue 3**                         | **性能提升效果**                   |
| :--------------- | :--------------------- | :-------------------------------- | :--------------------------------- |
| **编译优化**     | 无静态分析             | 静态提升（Hoisting） + PatchFlags | 减少 40% 虚拟 DOM 比对开销         |
| **Tree-shaking** | 不支持（全量引入）     | 基于 ESM 的按需编译               | 打包体积减少 30%（gzip 后约 10KB） |
| **虚拟 DOM**     | 全量 Diff（同层比较）  | 动态节点标记 + 区块树优化         | 渲染速度提升 1.5-2 倍              |
| **内存占用**     | 较高（递归响应式绑定） | 更低（惰性代理 + 缓存机制）       | 大型应用内存减少 50%               |

#### 关键优化技术：

- **静态提升**：将静态节点转为常量复用，避免重复创建
- **事件监听缓存**：避免重复生成事件函数
- **SSR 优化**：静态内容直出为 HTML 字符串，跳过虚拟 DOM



# Vue2/Vue3/React18 综合对比表格

| 特性维度           | Vue 2                                                        | Vue 3                                                        | React 18                                                     |
| :----------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **响应式原理**     | **基于 `Object.defineProperty`** 的 getter/setter。 • 递归转换数据对象的属性。 • 对**数组**的方法（push, pop等）进行 hack。 • **无法检测**属性的**添加和删除**，需使用 `Vue.set`/`Vue.delete`。 | **基于 `Proxy`** 的代理。 • 按需代理，性能更好。 • **直接支持**对对象和数组的**增、删、改**。 • 更好的性能，尤其对于大型对象/数组。 | **基于**不可变数据和**手动触发更新**。 • 使用 `setState` 或 `useState` setter 函数**显式**通知更新。 • 推荐使用新数据替换旧数据（不可变性），而非直接突变。 |
| **Diff 算法**      | 基于 **Snabbdom**<br />双端比较算法（双指针）<br />依赖 key 识别节点复用；递归对比子节点<br />无静态标记，全量遍历；列表更新 DOM 移动频繁 | **Block Tree**（带动态节点索引的 Virtual DOM 树，让 Vue3 diff 时只更新「该更新的地方」） + **PatchFlags**精准追踪动态节点；<br />静态节点提升（跳过 diff）；<br />列表 diff 双端对比<br /> 2. 最长递增子序列减少 DOM 移动 3.<br />JSX 场景静态分析弱于 template | 基于 Fiber 的链表遍历<br />通用 Virtual DOM 对比；<br />靠 key 做 child reconciliation；无编译时优化<br />Fiber 架构下的调和（单链表遍历，可中断）<br />无编译时优化，需全量遍历；依赖手动优化 |
| **Patch 策略**     | `patch(oldVnode, newVnode)` 递归更新；<br />依赖 `nextTick` 合并批量更新<br />同步执行，不可中断<br />递归遍历差异节点，直接调用 DOM API<br />无优先级控制，可能阻塞主线程<br />全量属性对比 | 根据 PatchFlags 精确更新（如仅更新 class/text）；静态树可直接跳过<br />同步执行（默认），可通过 nextTick 延迟<br />编译时确定更新范围，支持手动控制更新时机<br />最小化DOM移动操作 | **Commit 阶段**用 effect list 批量提交<br />调和阶段（diff）可中断，commit 阶段（patch）不可中断<br />生成 effect list，分阶段执行 DOM 操作<br />支持并发更新和优先级调度；通过 suspense 实现异步过渡 |
| **更新粒度**       | **中等 - 组件级** • 每个组件实例对应一个 **Watcher**。数据变化时，会精确通知到其所属的组件进行更新。 | **细粒度 - 组件级 & 块级** • 继承了 Vue 2 的组件级更新。 • 结合 **Tree Flattening** 和 **Patch Flags**，更新可以跳过整个静态块，直接定位到动态绑定的元素。 | **中等 - 组件级 (需手动优化)** • 默认：**状态变更会导致该组件**及其**所有子组件**全部重新渲染（执行 render 函数）。 • 需开发者手动使用 `React.memo`, `useMemo`, `useCallback` 来避免不必要的子组件重渲染，实现更细的粒度。 |
| **性能特点**       | • **中等性能**：组件级更新不错，但响应式系统和全量 Diff 在极端场景下会成为瓶颈。 • 存在一些 API 限制带来的性能陷阱（如未使用 `Vue.set`）。 | • **高性能**：Proxy 响应式、编译时优化和运行时高效 Diff 的结合，使其在**大多数基准测试中领先**。 • **更新效率最高**：能最精准地找到需要变化的节点，DOM 操作量最少。 | • **感知性能最佳**：**并发特性（Concurrency）** 是其最大优势，能保证浏览器在高负载渲染时仍能响应用户交互，避免卡顿。 • **默认更新策略**可能带来不必要的子组件渲染，性能更依赖开发者的优化水平。 |
| **生态与开发模式** | • **Options API** • 模板（主流）或 Render 函数 • 成熟的生态  | • **Composition API** (主推) + Options API (兼容) • 模板（编译优化最佳）或 JSX • 更好的 TypeScript 支持，更小的包体积（Tree-shaking） | • **Hooks** (函数组件主流) • **JSX** (唯一选择) • **强大的并发模型**（Suspense, Transitions） • 庞大且活跃的生态 |
| **综合性能排序**   | 🚫 最弱                                                       | ✅ 最强                                                       | ⭐ 中等（流畅度好于 Vue2，性能弱于 Vue3）                     |

## 核心差异总结

**Vue 2**: 成熟稳定，响应式有限制，性能中等，适合维护现有项目

 **Vue 3**: 编译时优化最强，响应式最完善，整体性能最佳，新项目优选

 **React 18**: 生态最丰富，并发特性独特，大型项目首选，学习成本较高

> **性能数据说明**: 具体数值会根据应用类型、代码质量、优化程度等因素有较大差异，建议根据实际项目需求选择。