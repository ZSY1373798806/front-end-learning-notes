## **1️⃣ 性能排序（从高到低）**

1. **Vue3 Template** ✅
2. Vue3 Render 函数 / JSX
3. Vue2 Template
4. React JSX / Render 函数
5. Vue2 JSX / Render 函数 ❌

**原因**：主要来自编译时优化、虚拟 DOM diff 算法、响应式系统效率三个核心因素。

## **2️⃣ 核心性能分析**

### **Vue3 Template 性能最优**

- **编译时优化**：
  - **静态节点提升**（Static Hoisting）：静态内容抽取为常量，跳过重复 diff。
  - **补丁标志 Patch Flags**：标记动态部分，只更新必要节点。
  - **树结构打平**：动态节点单独存储，减少遍历静态子树。
- **运行时优化**：
  - 虚拟 DOM diff 最小化，渲染函数高度优化。

### **Vue3 JSX / Render**

- 没有模板编译时优化。
- 仍能受益于 Vue3 的 Proxy 响应式和高效 diff 算法。
- 性能略低于模板，但比 Vue2/React 高。

### **Vue2 Template**

- 静态节点缓存有限（只缓存静态根节点）。
- 无补丁标志，每次 diff 全量比对。

### **React JSX / Render**

- JSX 编译为 `React.createElement`，生成完整虚拟 DOM。
- 性能依赖开发者手动优化（`React.memo`、`useMemo`）。
- Fiber 架构支持并发模式，提高用户体验，但基准性能仍低于 Vue3。

### **Vue2 JSX / Render**

- 无编译优化 + Vue2 响应式劣势 → 性能最差。

### **性能关键因素总结**

| 技术              | 编译时优化 | 运行时优化 | 虚拟 DOM 效率 |
| :---------------- | :--------- | :--------- | :------------ |
| **Vue3 Template** | ✅ 极致     | ✅ 高       | ✅ 最高        |
| **Vue3 JSX**      | ❌          | ✅ 高       | ⚠️ 中等        |
| **Vue2 Template** | ⚠️ 基础     | ⚠️ 中等     | ⚠️ 中等        |
| **React JSX**     | ❌          | ⚠️ 依赖手动 | ⚠️ 中等        |
| **Vue2 JSX**      | ❌          | ❌ 低       | ❌ 低          |

### Vue2 & Vue3 对比

### ⚙️ **一、响应式系统原理**

| **特性**         | **Vue 2**                          | **Vue 3**                        | **优势对比**                                                 |
| :--------------- | :--------------------------------- | :------------------------------- | :----------------------------------------------------------- |
| **实现机制**     | `Object.defineProperty` 劫持属性   | `Proxy` 代理整个对象             | Proxy 支持动态增删属性、数组索引修改等原生操作，无需 `Vue.set`124 |
| **数组监听**     | 重写数组方法（如 `push`/`splice`） | 直接监听数组索引和 `length` 变化 | 简化数组操作逻辑，避免 hack 处理                             |
| **深层响应**     | 初始化时递归遍历所有属性           | 惰性代理（访问嵌套属性时才代理） | 减少初始化开销，提升大型对象性能                             |
| **数据类型支持** | 仅支持 Object/Array                | 支持 Map/Set/WeakMap 等复杂类型  | 更适应现代 JS 数据结构                                       |

> 💡 **示例对比**
> **Vue 2 动态属性**：需 `this.$set(obj, 'newProp', value)`
> **Vue 3 动态属性**：直接 `obj.newProp = value`

### ⚡ **二、性能优化机制**

| **优化策略**     | **Vue 2**              | **Vue 3**                         | **性能提升效果**                   |
| :--------------- | :--------------------- | :-------------------------------- | :--------------------------------- |
| **编译优化**     | 无静态分析             | 静态提升（Hoisting） + PatchFlags | 减少 40% 虚拟 DOM 比对开销         |
| **Tree-shaking** | 不支持（全量引入）     | 基于 ESM 的按需编译               | 打包体积减少 30%（gzip 后约 10KB） |
| **虚拟 DOM**     | 全量 Diff（同层比较）  | 动态节点标记 + 区块树优化         | 渲染速度提升 1.5-2 倍              |
| **内存占用**     | 较高（递归响应式绑定） | 更低（惰性代理 + 缓存机制）       | 大型应用内存减少 50%               |

#### 关键优化技术：

- **静态提升**：将静态节点转为常量复用，避免重复创建
- **事件监听缓存**：避免重复生成事件函数
- **SSR 优化**：静态内容直出为 HTML 字符串，跳过虚拟 DOM



### Vue2 & Vue3 & React

### 一、Diff 算法对比

| 框架      | Diff 策略                       | 时间复杂度 | 特点                                                         |
| :-------- | :------------------------------ | :--------- | :----------------------------------------------------------- |
| **Vue2**  | 双端比较 (双指针)               | O(n)       | 头头、尾尾、头尾、尾头四种比较方式，优先复用相同位置的节点   |
| **Vue3**  | 动态规划 + 最长递增子序列 (LIS) | O(n)       | 先处理相同前缀/后缀 → 建立 key 映射 → 移动最少节点 → 新增/删除 |
| **React** | 基于 Fiber 的链表遍历           | O(n)       | 广度优先遍历，仅比较同层级节点，通过 key 复用节点            |

**核心区别**：

- Vue3 的 **LIS 算法** 能最小化节点移动操作（性能最优）
- React 的 **Fiber 架构** 支持可中断渲染，更适合大型应用
- Vue2 的双端比较在简单场景高效，但复杂列表操作弱于 Vue3

### 二、Patch 过程对比

| 框架      | Patch 策略                                | 优化手段                                                    |
| :-------- | :---------------------------------------- | :---------------------------------------------------------- |
| **Vue2**  | 全量比对 VNode                            | 静态节点跳过 diff                                           |
| **Vue3**  | **Block Tree** 动态追踪 + **Patch Flags** | 1. 静态提升 2. 靶向更新（按 patch flag 更新） 3. 树结构打平 |
| **React** | 生成 Effect List → 提交到渲染器           | 1. 双缓存机制 2. 批量更新 3. 时间切片（可中断渲染）         |

**核心优势**：

- **Vue3** 的 Patch Flags 实现**靶向更新**（如 `{ class: true }` 表示只更新 class）
- **React** 的 Fiber 架构实现**异步可中断渲染**（避免界面卡顿）
- **Vue2** 无编译时优化，性能最低

------

### 三、响应式原理对比

| 框架      | 核心机制                    | 触发时机               | 优缺点                                                       |
| :-------- | :-------------------------- | :--------------------- | :----------------------------------------------------------- |
| **Vue2**  | `Object.defineProperty`     | 同步触发               | ❌ 无法检测数组索引/长度变化 ❌ 无法检测对象属性新增/删除      |
| **Vue3**  | **Proxy** + **Reflect**     | 同步触发（可配置异步） | ✅ 全面检测对象/数组变化 ✅ 惰性依赖收集 ✅ 更好的内存管理      |
| **React** | **手动触发更新** (setState) | 异步批量更新           | ✅ 精确控制更新边界 ❌ 需手动优化（memo, useMemo） ❌ 依赖不可变数据 |