## 模块化
### 概念
	就是将一块独立功能的代码，封装成一个独立的文件，在其他模块中按需引入；
### 区别
- commonjs规范
	- 是在运行时加载的，在运行时导出对象；属于浅拷贝；
		运行时加载：
		- 在输入时先加载整个模块，生成一个对象；
		- 再从这个对象上面读取方法；
		- require()是同步加载模块
	- 场景：nodejs
	- 使用：module.exports/require
- es6模块
	- 编译时输出接口
		编译时加载：
		- 引用
		- es6模块不是对象，是通过export命令显式指定输出的代码；
		- import时采用静态命令的形式；
		- 即在import时可以指定加载某个输出值，而不是加载整个模块；
		- import命令时异步加载，有一个独立的模块依赖的解析阶段
	- 使用：export/import
- AMD（require.js）
	- 依赖前置，提前执行
```js
define(["a", "b", "c", "d", "e", "f"], function(a, b, c, d, e, f) { 
    // 等于在最前面声明并初始化了要用到的所有模块
    a.doSomething();
    if (false) {
    	// 即便没用到某个模块 b，但 b 还是提前执行了
    	b.doSomething()
	} 
});
```
- CMD（sea.js）
	- 依赖就近，延迟执行
```js
define(function(require, exports, module) {
    var a = require('./a'); //在需要时申明
    a.doSomething();
    if (false) {
        var b = require('./b');
        b.doSomething();
    }
});
```
- ES Modules
  - 在浏览器中直接使用模块的方式是给script标签设置type=module

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script type="module">
      var hi = "hello, world!";
      console.log(hi);
    </script>
  </body>
</html>
```



## 模块化循环引用

### 1️⃣ CommonJS 循环引用解决机制

- **核心机制**：CommonJS 模块在运行时加载，模块会先被加入 **缓存对象**，导出的 `exports` 是一个 **浅拷贝对象**。
- **关键点**：
  1. 当 A 模块 `require` B 模块时，B 模块开始执行。
  2. 如果 B 模块又 `require` A 模块，由于 A 已经在缓存中了，因此 B 获取的是 **当前 A 模块 `exports` 的引用**（可能是未完成初始化的状态）。
  3. 所以在循环引用的情况下，模块获得的是对方模块 **初始化过程中的“半成品”对象**。
  4. 最终所有模块执行完成后，缓存中对象被完整初始化。
- **示例**（你已有案例基础上补充执行顺序）：

```js
入口模块 index.js 加载 a.js
a.js 初始化 exports.a = '原始值-a模块内变量'
a.js  require('./b') -> 加载 b.js
b.js 初始化 exports.b = '原始值-b模块内变量'
b.js  require('./a') -> a 已在缓存中，获取到当前 exports {a: '原始值-a模块内变量'}
b.js 修改 exports.b = '修改值-b模块内变量'
b.js 完成
a.js 修改 exports.a = '修改值-a模块内变量'
a.js 完成
index.js 输出 a 模块
```

- **总结**：
  - CommonJS 使用 **模块缓存 + 引用对象** 的方式，保证循环引用不会死循环，但可能拿到不完整的模块。

------

### 2️⃣ ES Module 循环引用解决机制

- **核心机制**：ES Module 是 **编译时静态分析**，模块导出的是 **引用绑定（live bindings）**，而不是拷贝值。
- **关键点**：
  1. ES Module 在解析阶段就会知道模块间的依赖关系。
  2. 导出的变量是**动态绑定**（live binding），即引用指向模块内的真实变量，而不是导出的值的副本。
  3. 当出现循环引用时，访问模块导出的变量会得到 **当前最新值**（可能还未初始化完，但总是指向原始变量）。
  4. 因此，不会像 CommonJS 那样得到“半成品对象”，而是对变量的实时引用。
- **示例**：

```js
// a.mjs
export let a = '原始值-a模块内变量';
import { b } from './b.mjs';
console.log('a模块引用b模块:', b);
a = '修改值-a模块内变量';

// b.mjs
export let b = '原始值-b模块内变量';
import { a } from './a.mjs';
console.log('b模块引用a模块:', a);
b = '修改值-b模块内变量';

// index.mjs
import { a } from './a.mjs';
import { b } from './b.mjs';
console.log('入口模块引用a模块:', a);
console.log('入口模块引用b模块:', b);
```

- **执行结果**（因为是 live binding）：

```js
b模块引用a模块: 原始值-a模块内变量
a模块引用b模块: 原始值-b模块内变量
入口模块引用a模块: 修改值-a模块内变量
入口模块引用b模块: 修改值-b模块内变量
```

- **总结**：
  - ES Module 利用 **静态分析 + live binding**，天然解决循环引用问题。
  - 循环依赖不会产生“半成品对象”，访问到的是最新的变量值。
  - 所以 ES Module 更安全，也更适合前端模块化。

------

### 3️⃣ 对比总结

| 特性                   | CommonJS             | ES Module                                             |
| ---------------------- | -------------------- | ----------------------------------------------------- |
| 加载时机               | 运行时加载           | 编译时加载                                            |
| 导出方式               | 对象的拷贝（浅拷贝） | 引用绑定（live binding）                              |
| 循环引用获取的对象状态 | 可能是半成品对象     | 指向变量的实时引用                                    |
| 是否异步               | 同步                 | 异步加载，浏览器端可直接使用 `<script type="module">` |
| 场景                   | Node.js              | 浏览器、现代前端框架                                  |

------

💡 **优化理解方式**：

- CommonJS 更像“先生成对象再填充内容”，循环引用时可能看到半成品。
- ES Module 更像“生成变量引用绑定”，循环引用总是看到实时最新值。
- 面试中可通过“缓存 vs live binding”区分两者的循环引用处理策略。
