## 模块化对比总结

### 1. **CommonJS**

- **特点**

  - **运行时加载**（先执行模块文件，再导出对象）
  - 输出的是 **值的拷贝**（浅拷贝，后续修改不会影响已引用的值）
  - `require()` 是 **同步加载**

- **应用场景**：Node.js

- **语法**

  ```js
  // a.js
  module.exports = { x: 1 }
  
  // b.js
  const a = require('./a')
  console.log(a.x) // 1
  ```

------

### 2. **ES Module（ESM）**

- **特点**

  - **编译时确定依赖关系**（静态分析）
  - 输出的是 **值的引用**（动态绑定，值会随着模块内部变化而变化）
  - **import/export** 只能写在顶层
  - 浏览器和 Node.js（现代版本）都支持

- **应用场景**：现代前端工程、Node.js(ESM模式)

- **语法**

  ```js
  // a.js
  export let x = 1;
  export function inc() { x++ }
  
  // b.js
  import { x, inc } from './a.js'
  console.log(x) // 1
  inc()
  console.log(x) // 2
  ```

------

### 3. **AMD（Asynchronous Module Definition）**

- **特点**

  - **依赖前置**：必须在定义模块时声明所有依赖
  - **提前执行**：依赖会在一开始就加载并执行
  - **适合浏览器异步加载**

- **应用场景**：早期浏览器模块化（RequireJS）

- **语法**

  ```js
  define(['a', 'b'], function(a, b) {
    a.doSomething();
  });
  ```

------

### 4. **CMD（Common Module Definition）**

- **特点**

  - **依赖就近**：在需要时再 `require`
  - **延迟执行**：代码执行到 require 时才加载
  - 语法更贴近 CommonJS

- **应用场景**：SeaJS

- **语法**

  ```js
  define(function(require, exports, module) {
    var a = require('./a');
    a.doSomething();
  });
  ```

------

### 5. **UMD（Universal Module Definition）**

- **特点**

  - 兼容 AMD 和 CommonJS 的写法
  - 如果检测到 `exports` 就走 CommonJS，否则检测 `define` 走 AMD，否则挂到全局

- **应用场景**：库开发（比如 jQuery、Lodash 发布的 UMD 版本）

- **语法**

  ```js
  (function (root, factory) {
    if (typeof define === 'function' && define.amd) {
      define(['jquery'], factory); // AMD
    } else if (typeof exports === 'object') {
      module.exports = factory(require('jquery')); // CommonJS
    } else {
      root.myModule = factory(root.jQuery); // 全局
    }
  }(this, function ($) {
    return { hello: () => console.log('hi') }
  }));
  ```

## 核心区别表

| 特性       | CommonJS               | ES Module        | AMD               | CMD                 | UMD    |
| ---------- | ---------------------- | ---------------- | ----------------- | ------------------- | ------ |
| 加载方式   | 同步                   | 异步（静态分析） | 异步（依赖前置）  | 异步（依赖就近）    | 自适应 |
| 输出       | 值拷贝（浅拷贝）       | 引用（动态绑定） | 值拷贝            | 值拷贝              | 兼容   |
| 语法       | require/module.exports | import/export    | define([...], fn) | define(fn(require)) | 混合   |
| 使用场景   | Node.js                | 浏览器/Node.js   | 早期浏览器        | 早期浏览器          | 库发布 |
| 规范提出方 | Node.js                | ES6（ECMA）      | RequireJS         | SeaJS               | 社区   |

## 模块化循环引用

### 1️⃣ CommonJS 循环引用解决机制

- **核心机制**：CommonJS 模块在运行时加载，模块会先被加入 **缓存对象**，导出的 `exports` 是一个 **浅拷贝对象**。
- **关键点**：
  1. 当 A 模块 `require` B 模块时，B 模块开始执行。
  2. 如果 B 模块又 `require` A 模块，由于 A 已经在缓存中了，因此 B 获取的是 **当前 A 模块 `exports` 的引用**（可能是未完成初始化的状态）。
  3. 所以在循环引用的情况下，模块获得的是对方模块 **初始化过程中的“半成品”对象**。
  4. 最终所有模块执行完成后，缓存中对象被完整初始化。
- **示例**（你已有案例基础上补充执行顺序）：

```js
入口模块 index.js 加载 a.js
a.js 初始化 exports.a = '原始值-a模块内变量'
a.js  require('./b') -> 加载 b.js
b.js 初始化 exports.b = '原始值-b模块内变量'
b.js  require('./a') -> a 已在缓存中，获取到当前 exports {a: '原始值-a模块内变量'}
b.js 修改 exports.b = '修改值-b模块内变量'
b.js 完成
a.js 修改 exports.a = '修改值-a模块内变量'
a.js 完成
index.js 输出 a 模块
```

- **总结**：
  - CommonJS 使用 **模块缓存 + 引用对象** 的方式，保证循环引用不会死循环，但可能拿到不完整的模块。

------

### 2️⃣ ES Module 循环引用解决机制

- **核心机制**：ES Module 是 **编译时静态分析**，模块导出的是 **引用绑定（live bindings）**，而不是拷贝值。
- **关键点**：
  1. ES Module 在解析阶段就会知道模块间的依赖关系。
  2. 导出的变量是**动态绑定**（live binding），即引用指向模块内的真实变量，而不是导出的值的副本。
  3. 当出现循环引用时，访问模块导出的变量会得到 **当前最新值**（可能还未初始化完，但总是指向原始变量）。
  4. 因此，不会像 CommonJS 那样得到“半成品对象”，而是对变量的实时引用。
- **示例**：

```js
// a.mjs
export let a = '原始值-a模块内变量';
import { b } from './b.mjs';
console.log('a模块引用b模块:', b);
a = '修改值-a模块内变量';

// b.mjs
export let b = '原始值-b模块内变量';
import { a } from './a.mjs';
console.log('b模块引用a模块:', a);
b = '修改值-b模块内变量';

// index.mjs
import { a } from './a.mjs';
import { b } from './b.mjs';
console.log('入口模块引用a模块:', a);
console.log('入口模块引用b模块:', b);
```

- **执行结果**（因为是 live binding）：

```js
b模块引用a模块: 原始值-a模块内变量
a模块引用b模块: 原始值-b模块内变量
入口模块引用a模块: 修改值-a模块内变量
入口模块引用b模块: 修改值-b模块内变量
```

- **总结**：
  - ES Module 利用 **静态分析 + live binding**，天然解决循环引用问题。
  - 循环依赖不会产生“半成品对象”，访问到的是最新的变量值。
  - 所以 ES Module 更安全，也更适合前端模块化。

------

### 3️⃣ 对比总结

| 特性                   | CommonJS             | ES Module                                             |
| ---------------------- | -------------------- | ----------------------------------------------------- |
| 加载时机               | 运行时加载           | 编译时加载                                            |
| 导出方式               | 对象的拷贝（浅拷贝） | 引用绑定（live binding）                              |
| 循环引用获取的对象状态 | 可能是半成品对象     | 指向变量的实时引用                                    |
| 是否异步               | 同步                 | 异步加载，浏览器端可直接使用 `<script type="module">` |
| 场景                   | Node.js              | 浏览器、现代前端框架                                  |

------

💡 **优化理解方式**：

- CommonJS 更像“先生成对象再填充内容”，循环引用时可能看到半成品。
- ES Module 更像“生成变量引用绑定”，循环引用总是看到实时最新值。
- 面试中可通过“缓存 vs live binding”区分两者的循环引用处理策略。
