## 优化
### 缓存
### 移除控制台打印
### CDN（内容分发网络）加速

- #### CDN通过地理分布的边缘节点缓存静态资源来加速访问

  - DNS解析会将用户请求路由到最近的边缘节点，可以减少网络延迟，提高用户访问速度
  - CDN会考虑各个节点的负载情况，避免某个节点负载过高而影响情况

- #### 缓存机制和更新策略

  - 缓存机制
    - CDN节点会缓存网站的静态资源，如图片、CSS、JS文件等
    - 根据资源的类型、大小、访问频率等因素设置缓存策略，确定资源的缓存时间和更新方式
  - 缓存更新
    - 当原服务器上的资源发生变化时，CDN需要及时更新缓存
    - 实现缓存更新
      - 主动推送
        - 源服务器在资源发生变化时，主动通知CDN节点更新缓存
      - 被动拉取
        - CDN节点在发现用户请求的资源与缓存中的资源不一致时，自动从源服务器获取最新的资源

### 路由懒加载
### 按需引入
### css雪碧图 & iconfont
### 小图片打包编译成base64
- 实现：url-loader
- 优点：减少http资源请求
### 图片上传压缩
- 实现：canvas

  canvas图片压缩.md

### 大文件上传

- #### 解决方案

  - 分片上传

    将大文件分割成多个小块（chunks），分别上传到服务器，最后在服务器端合并。

  - 断点上传

    在分片上传的基础上，记录已上传的部分，断线后继续上传，避免重复上传。

  - 文件秒传

    在上传前计算文件的哈希值，检查服务器是否已存在该文件。

- #### 实现

  - ##### 一、切片文件标识方案

    每个切片需要包含以下核心标识信息：
  
    - **文件唯一指纹**
  
    - 使用 `文件内容哈希值`（如MD5/SHA1）作为文件唯一ID
  
    - 避免文件名重复导致冲突（示例：`8f4d87fd5a6d5a17e8e8234e7b1a2b3c`）
  
    - **切片序号**
  
    - 从0开始的连续编号（示例：`chunk-0023`）
  
    - **附加元信息**（可选）：
  
      ```js
      {
        "totalChunks": 45,       // 总切片数
        "fileName": "原始文件名.zip",
        "fileSize": 524288000,    // 文件总字节数
        "chunkSize": 10485760     // 单切片大小(10MB)
      }
      ```

  - ##### 二、进度记录实现方案
  
    - 客户端存储
  
      ```js
      // 保存进度到LocalStorage
      function saveProgress(fileHash, progress) {
        localStorage.setItem(`upload_${fileHash}`, JSON.stringify({
          timestamp: Date.now(),
          uploadedChunks: progress // 如 [0,1,2,3,5,6]
        }));
      }
      
      // 读取进度
      function loadProgress(fileHash) {
        const data = localStorage.getItem(`upload_${fileHash}`);
        return data ? JSON.parse(data).uploadedChunks : [];
      }
      ```
  
    - 服务端存储
  
      ```js
      // 数据库记录设计
      {
        file_id: "8f4d87fd5a6d5a17", // 文件哈希
        user_id: "user123",          // 用户ID
        chunks_done: [0,1,2,3,5,6], // 已传切片序号
        total_chunks: 45,
        last_updated: 1692086400000  // 最后更新时间戳
      }
      ```
  
  - ##### 三、断点续传工作流程
  
    ```mermaid
    sequenceDiagram
        participant Client
        participant Server
        Client->>Server: 1. 提交文件哈希请求续传
        Server-->>Client: 2. 返回缺失切片序号 [4,7,8...]
        loop 上传缺失切片
            Client->>Server: 3. 上传切片(chunk-0004)
            Server-->>Client: 4. 确认接收并更新进度
        end
        Client->>Server: 5. 请求合并文件
        Server->>Server: 6. 按序拼接所有切片
        Server-->>Client: 7. 返回最终文件URL
    ```
  
  - ##### 四、关键代码实现
  
    - 客户端上传逻辑
  
    ```js
    async function resumeUpload(file) {
      // 1. 生成文件哈希
      const fileHash = await calculateMD5(file);
      
      // 2. 获取上传进度
      const { missingChunks } = await fetch(`/api/progress?hash=${fileHash}`);
      
      // 3. 切片上传
      const chunkSize = 10 * 1024 * 1024; // 10MB
      for (const chunkIndex of missingChunks) {
        const start = chunkIndex * chunkSize;
        const chunk = file.slice(start, start + chunkSize);
        
        const formData = new FormData();
        formData.append('chunk', chunk);
        formData.append('hash', fileHash);
        formData.append('index', chunkIndex);
        formData.append('total', Math.ceil(file.size / chunkSize));
        
        await fetch('/api/upload', { method: 'POST', body: formData });
      }
      
      // 4. 合并请求
      await fetch(`/api/merge?hash=${fileHash}&filename=${file.name}`);
    }
    ```
  
    - 服务端接口示例（Node.js）
  
    ```js
    // 进度查询接口
    app.get('/api/progress', (req, res) => {
      const { hash } = req.query;
      const progress = db.getProgress(hash);
      
      // 计算缺失切片
      const allChunks = Array.from({length: progress.total}, (_,i)=>i);
      const missing = allChunks.filter(i => !progress.chunks_done.includes(i));
      
      res.json({ missingChunks: missing });
    });
    
    // 切片上传接口
    app.post('/api/upload', (req, res) => {
      const { index, hash } = req.body;
      const chunk = req.files.chunk;
      
      // 保存切片文件
      fs.writeFileSync(`./chunks/${hash}_${index}`, chunk.data);
      
      // 更新数据库进度
      db.updateProgress(hash, index);
      
      res.sendStatus(200);
    });
    ```
  
  - ##### 优化
  
    - 切片验证：
      每个切片上传时携带 `Content-MD5` 头，服务端校验完整性
  
    - 自动清理：
      服务端定期清理超过7天的未完成上传
  
    - 并发控制：
      客户端同时上传3-5个切片提升速度：
  
      ```js
      const parallelCount = 3;
      await Promise.allSettled(
        missingChunks.slice(0, parallelCount).map(uploadChunk)
      );
      ```
  
    - 恢复点保护：
      客户端异常关闭时通过 `beforeunload` 事件保存进度：
  
      ```js
      window.addEventListener('beforeunload', () => {
        saveProgress(fileHash, currentProgress);
      });
      ```
  

### 使用gzip压缩
- 实现
	- 方案一： 设置http请求头Accept-Encoding 为 gzip；同时服务端需要支持；
	- 方案二：webpack插件 compression-webpack-plugin
### 图片懒加载
- vue-lazyload

- 使用 `loading="lazy"`（原生方式）

  ```html
  <img src="image.jpg" loading="lazy" alt="Lazy Loaded Image">
  ```

- 使用 Intersection Observer API

```js
// 使用 IntersectionObserver 创建一个观察器，配置其行为（如视口、边距、阈值等）
const ob = new IntersectionObserver((entries) => {  
    //entries是一个数组，包含所有被观察的元素的状态信息
    for(const entry of entries){
        if(entry.isIntersecting){
            const img = entry.target;
            img.src = img.dataset.src; // 将图片的实际 URL 从 data-src 属性赋值给 src 属性
            ob.unobserve(img); // 取消观察
        }
    }
}, {  // 配置参数
    root:null,  // 默认为null，观察视口
    rootMargin:'0px', // 基于视口扩散或收缩的距离，默认为'0px'
    threshold:0  // 阈值 默认为0,即接触就运行回调，1为完整进入才运行回调
})

const imgs = document.querySelectorAll("img[data-src]"); // 拿到所有data-src的图片
imgs.forEach((img) => {  // 循环观察图片
    ob.observe(img); 
})
```
- 优点：只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。
### 尽量用css效果实现代替图片
### 减少 ES6 转为 ES5 的冗余代码
- 实现：babel-plugin-transform-runtime
```js
.babelrc 
"plugins": [
    "transform-runtime"
]
```
### 减少重排重绘
- 实现 用js修改样式时，不要直接写样式，通过替换class来实现；
- 对dom进行一些列操作时，先将元素脱离文档流，修改完成后，再将它带回文档（推荐使用display:none;和DocumentFragment）;
- CSS使用transform代替top
### 使用事件委托
### 使用requestAnimationFrame实现动画

`requestAnimationFrame`也是个定时器，不同于`setTimeout`，它的时间不需要我们人为指定，这个时间取决于当前电脑的刷新率，如果是 60Hz ，那么就是 16.7ms 执行一次，如果是 120Hz 那就是 8.3ms 执行一次

### 使用 Web Workers
### 使用 transform 和 opacity 属性更改来实现动画
- 优点 这两个属性更改不会触发重排和重绘；它们是有合成器单独处理的属性；
### 使用计算数据computed
### 取消sourceMap
### 事件销毁
	清除定时器
	移除事件监听
### 插件按需引入
- 实现 babel-plugin-component
```js
.babelrc 
{
  "presets": [["es2015", { "modules": false }]],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ]
  ]
}
main.js
import Vue from 'vue';
import { Button, Select } from 'element-ui';
Vue.use(Button)
Vue.use(Select)
```
### Vue全局组件自动加载
	require.context
```js
import { createApp } from 'vue';
export function registerGlobalComponent(app: ReturnType<typeof createApp>): void {
  const files = (require as any).context('./global', true, /\.(vue|ts)$/)
  console.log(files)
  
  files.keys().forEach((key) => {
    files(key)
    const compName = key.replace(/^\.\//, '').replace(/.(vue|ts)$/, '')
    const config = files(key).default || files(key)
    app.component(compName, config)
  })
}
```