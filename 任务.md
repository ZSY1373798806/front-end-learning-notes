# 任务



## 同步任务&异步任务

### 开篇案例

- 案例1

```javascript
setTimeout(() => {
	console.log('setTimeout block')
}, 100);
while (true) {}
console.log('end here')
```

> 观察以上代码，不存在任何输出
>
> while循环会一直循环代码块，主线程将会被占用

- 案例2

```javascript
setTimeout(() => {
	while (true) {}
}, 0);
console.log('end here')
```

> 输出结果为：'end here'
>
> 执行这段代码后，如果我们再执行任何语句，都不会再得到任何响应

###### 结论

​		javascript中所有的任务分为同步任务和异步任务

### 同步任务

​		当前主线程将要消化执行的任务，这些任务一起形成执行栈（execution content stack）

### 异步任务

​		不进入主线程，而是进入任务队列（task queue），即不会马上进行的任务

### 执行机制

​		当同步任务全部都被消化，主线程空闲时（即执行栈execution content stack为空时），将会执行任务队列（task queue）中的任务，即异步任务。

- 这样的机制保证了：

  > 虽然javascript是单线程的，当对于一些耗时的任务，我们可以将其丢入任务队列中；
  >
  > 这样一来，也就不会阻碍其他同步代码的执行；
  >
  > 等待异步任务完成之后，再去进行相关的逻辑操作。



## 案例讲解

- 案例1

```javascript
setTimeout(() => {
	console.log('setTimeout block')
}, 100);
while (true) {}
console.log('end here')
```

​		详解：

> 程序遇到setTimeout时，会将其放入任务队列（task queue）中；
>
> 继续执行同步任务，直到while循环；
>
> 进入while死循环，导致主线程同步任务被阻塞，主线程永远无法空闲；
>
> 因此console.log('end here')不会执行；
>
> 更不可能执行在同步任务结束后，执行任务队列中的console.log('setTimeout block')。

- 案例2

```javascript
const t1 = new Date()
setTimeout(() => {
	const t3 = new Date()
	console.log('setTimeout block')
	console.log('t3 - t1 = ', t3 - t1)
}, 100);
let t2 = new Date()
while(t2 - t1 < 200) {
	t2 = new Date()
}
console.log('end here')

// end here
// setTimeout block
// t3 - t1 =  200
```

​		详解：

> setTimeout定时器设置为100ms，同步任务中的while循环将执行200ms；
>
> 计时到时后仍然会先执行主线程中的同步任务；
>
> 只有当同步任务全部执行完毕， 'end here'输出，才开始执行任务队列中的任务；
>
> 此时t3和t1的时间差为200ms，而不是定时器设定的100ms。

### 关于setTimeout细节

- 题目1

```javascript
setTimeout(() => {
	console.log('here 100')
}, 100)
setTimeout(() => {
	console.log('here 0')
}, 0)
```

> 很显然，此刻会先输出'here 0'；大概100ms左右，输出'here 100'

- 题目2

```javascript
setTimeout(() => {
	console.log('here 1')
}, 1)
setTimeout(() => {
	console.log('here 2')
}, 0)
```

> 按道理来说，此处应该会先输出'here 2'， 再输出'here 1';
>
> 然后真正结果是：先输出'here 1', 再输出'here 2'；
>
> 针对这两个setTimeout，谁先进入任务队列，谁就先执行；不会按照1ms和0ms的区分；
>
> 1ms和0ms的延迟是等价的，类似于【最小延迟时间】，在最小延迟时间内，谁先进入任务队列，谁就会在主线程空闲时先被执行；
>
> MDN上给出的最小延迟时间为>=4ms，因此可能实际延时会比设定的值更久；
>
> 未被激活的tabs的最小延迟时间为>=1000ms
>
> 最大延迟：在浏览器中以一个32位带符号整数存储延时，这就导致如果延时大于$2^{32}-1$(即2147483647)时，定时器将会被立即执行。



## 宏任务&微任务

### 开篇案例

- 案例1

```javascript
console.log('start here')
new Promise((resolve, reject) => {
	console.log('first promise constructor')
	resolve()
}).then(() => {
	console.log('first promise then')
	return new Promise((resolve, reject) => {
		console.log('second promise')
		resolve()
	}).then(() => {
		console.log('second promise then')
	})
}).then(() => {
	console.log('another first promise then')
})
console.log('end here')

// start here
// first promise constructor
// end here
// first promise then
// second promise
// second promise then
// another first promise then
```

​		运行步骤：

> 1、首先输出'start here'；
>
> 2、接着一个Promise构造函数中，同步代码执行，输出'first promise constructor'；
>
> 3、继续执行同步代码，输出'end here'；
>
> 4、同步代码全部执行完毕，执行任务队列中的逻辑，输出'first promise then'以及'second promise'；
>
> 5、当在then方法中返回一个Promise时（line: 7），第一个promise的第二个完成处理函数（line: 13）会置于返回这个新promise的then（line: 10）后面；
>
> 6、此时将新的promise的then方法放入任务队列中，由于主线程处于空闲状态，执行队列中的该then方法，输出'second promise then'；
>
> 7、最后输出'another first promise then'。

###### 结论

​		我们可以看出：Promise回调函数then也会被放到任务队列中；但这个【任务队列】和前面提到的setTimeout相关的任务队列又有不同。

### 任务队列中的异步任务

#### 宏任务（macromask）

- setTimeout
- setInterval
- I/O
- 事件
- postMessage
- setImmediate（Node.js，浏览器端该api已废除）
- requestAnimationFrame
- UI渲染

#### 微任务（micromask）

- Promise.then
- MutationObserver
- process.nextTick(Node.js)
- async/await
  - async声明的函数，其返回值必定是promise对象；如果没有显式的返回promise对象，也会用Promise.resolve()对其结果进行包装，保证返回值为promise类型；
  - await会先执行其右侧表达逻辑（从右向左执行），并让出主线程，跳出async函数，而且继续执行async函数外的同步代码；
  - 如果await右侧表达逻辑是个promise：让出主线程，继续执行async函数外的同步代码，等待同步任务结束后，且该promise被resolve时继续执行await后的逻辑
  - 如果await右侧表达逻辑不是promise类型：那么仍然异步处理，将其理解包装为promise（通过Promise.resolve().then(() => {}），async函数外的同步代码执行完毕之后，会回到async函数内部，继续执行await之后的逻辑。

### 问题

- 问题1：当代码同时存在宏任务和微任务时，谁的优先级更高，先执行谁？

```javascript
const foo = () => (new Promise((resolve, reject) => {
	console.log('first promise constructor')
	let promise1 = new Promise((resolve, reject) => {
		console.log('second promise constructor')
		setTimeout(() => {
			console.log('setTimeout here')
			resolve()
		}, 0)
		resolve('promise1')
	})
	resolve('promise0')
	promise1.then(arg => {
		console.log(arg)
	})
}))
foo().then(arg => {
	console.log(arg)
})
console.log('end here')

// start here
// first promise constructor
// second promise constructor
// end here
// promise1
// promise0
// setTimeout here
```

###### 结论

​		微任务优先级大于宏任务。

- 问题2：分析以下运行结果

```javascript
async function async1() {
	console.log('async1 start')
	await async2()
	console.log('async1 end')
}
async function async2() {
	console.log('async2')
}
console.log('script start')
setTimeout(function () {
	console.log('setTimeout')
}, 0)
async1()
new Promise(function (resolve) {
	console.log('promise1')
	resolve()
}).then(function () {
	console.log('promise2')
})
console.log('script end')

// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

​		详解：

> 1、首先执行同步代码，输出script start;
>
> 2、遇到setTimeout，将其放入任务队列中的宏任务；
>
> ​		此时宏任务队列：[setTimeout]
>
> 3、遇到async1(),执行async1中的同步代码。输出'async1 start'；
>
> 4、继续执行async2，由于async2中没有await，输出'async2'；
>
> 5、按照async函数规则，async2函数仍然返回一个promise，作为async1函数中await表达式的值，相当于：Promise.resolve().then(() => {}),并将其放入为任务中；
>
> async1()方法相当于：
>
> ​		function async1() {
>
>  				console.log('async1 start')
>
>  				return new Promise((*resolve*) => {
>
>   				resolve(async2())
>
>  				}).then(() => { console.log('async1 end') })
>
> ​		}
>
> ​		此时微任务队列：[Promise.resolve().then(() => {})]
>
> 6、async1函数让出主线程，中断在await一行；
>
> 7、继续执行，输出Promise构造函数内的'promise1'，并将promise的then回调放入微任务中；
>
> ​		此时微任务队列：[Promise.resolve().then(() => {}), promise.then(function () {console.log('promise2')})]
>
> 8、执行最后一行代码，输出'script end'，此时同步代码已全部执行完毕；
>
> 9、执行微任务Promise.resolve().then(() => {})，不做任何操作；
>
> 10、async1()中的await中断失效，继续执行函数，输出'async1 end'；
>
> 11、执行微任务promise.then(function () {console.log('promise2')})，输出'promise2'；
>
> ​		此时微任务已全部执行完毕
>
> 12、执行宏任务setTimeout，输出'setTimeout'；
>
> ​		所有任务全部执行完毕

