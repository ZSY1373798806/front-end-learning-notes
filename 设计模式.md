# 设计模式总结与优化（附落地细节）

设计模式是解决特定场景问题的 “可复用解决方案”，核心价值是**降低耦合、提高代码可维护性和扩展性**。以下按 “创建型→结构型→行为型” 分类，结合你的总结补充关键细节：

## 一、创建型模式（解决 “对象创建” 问题）

### 1. 工厂模式

- **核心目标**：封装对象创建逻辑，避免直接 `new` 导致的耦合（尤其当创建逻辑复杂时）。

- 分类

  - 简单工厂（`switch-case` 实现，适合创建逻辑简单的场景）；
  - 工厂方法（为每个产品定义独立工厂类，支持扩展新产品）；
  - 抽象工厂（创建 “产品族”，如 “Windows 组件族”“Mac 组件族”）。

- 落地代码（简单工厂）

  ```javascript
  // 需求：根据类型创建不同的弹窗（警告/确认/提示）
  class AlertPopup { show() { console.log("警告弹窗") } }
  class ConfirmPopup { show() { console.log("确认弹窗") } }
  
  // 工厂函数：封装创建逻辑
  function PopupFactory(type) {
    switch (type) {
      case 'alert': return new AlertPopup();
      case 'confirm': return new ConfirmPopup();
      default: throw new Error("不支持的弹窗类型");
    }
  }
  
  // 使用：无需关心创建细节，只传类型
  const alert = PopupFactory('alert');
  alert.show(); // 警告弹窗
  ```

- **核心作用**：当需要新增弹窗类型（如 `PromptPopup`），只需修改工厂函数，无需修改调用处，符合 “开闭原则”。

### 2. 单例模式

- 核心约束

  1. 唯一实例（全局仅一个）；
  2. 全局访问点（避免随处 `new` 导致多实例）；
  3. 延迟创建（按需实例化，避免初始化过早消耗资源）。

- 落地代码（闭包 + 防篡改）

  ```javascript
  // 需求：全局唯一的弹窗实例（避免重复创建多个弹窗DOM）
  const SingletonPopup = (function() {
    let instance; // 闭包保存唯一实例
  
    // 真正的构造函数（封装创建逻辑）
    function createInstance() {
      const popup = document.createElement('div');
      popup.className = 'singleton-popup';
      return popup;
    }
  
    // 暴露全局访问方法
    return {
      getInstance: function() {
        if (!instance) {
          instance = createInstance(); // 延迟创建
        }
        return instance;
      }
    };
  })();
  
  // 使用：多次调用仍返回同一个实例
  const popup1 = SingletonPopup.getInstance();
  const popup2 = SingletonPopup.getInstance();
  console.log(popup1 === popup2); // true（唯一实例）
  ```

- **典型场景**：弹窗、全局状态管理（如 Vuex 的 `store`）、浏览器 `window` 对象。

- **注意**：避免滥用单例（如全局状态过多会导致耦合），仅用于 “必须唯一” 的场景。

## 二、结构型模式（解决 “对象组合” 问题）

### 3. 代理模式

- **核心目标**：控制对 “目标对象” 的访问，在访问前后添加额外逻辑（如权限校验、缓存、防抖）。

- 分类

  - 保护代理（控制访问权限，如 “仅管理员可操作”）；
  - 虚拟代理（延迟加载资源，如 “图片懒加载”）；
  - 事件代理（你的例子，利用事件冒泡减少事件绑定）。

- 落地代码（虚拟代理：图片懒加载）

  ```javascript
  // 需求：图片未加载完成时显示占位图，加载完成后替换
  class ImageLoader { // 目标对象：真正加载图片
    load(url, callback) {
      const img = new Image();
      img.onload = () => callback(img);
      img.src = url;
    }
  }
  
  class LazyImageProxy { // 代理对象：添加懒加载逻辑
    constructor() {
      this.loader = new ImageLoader(); // 持有目标对象引用
      this.placeholder = 'https://placeholder.com/100x100'; // 占位图
    }
  
    load(url, imgDom) {
      // 1. 先显示占位图
      imgDom.src = this.placeholder;
      // 2. 调用目标对象加载图片
      this.loader.load(url, (img) => {
        imgDom.src = img.src; // 加载完成后替换
      });
    }
  }
  
  // 使用：通过代理访问，无需关心懒加载细节
  const proxy = new LazyImageProxy();
  proxy.load('https://large-image.com/2000x1000.jpg', document.getElementById('img'));
  ```

- **核心作用**：将 “核心逻辑（加载图片）” 与 “附加逻辑（懒加载）” 分离，符合 “单一职责原则”。

### 4. 装饰器模式

- **核心目标**：动态给对象添加功能，且不修改原对象代码（比继承更灵活，避免类爆炸）。

- 关键特性

  - 装饰器与目标对象实现同一接口（保证使用方式一致）；
  - 装饰器可嵌套（如 “基础功能→防抖→节流→日志”）。

- 落地代码（给函数添加日志装饰器）

  ```javascript
  // 需求：给计算函数添加“执行日志”功能，不修改原函数
  // 原函数（目标对象）
  function add(a, b) {
    return a + b;
  }
  
  // 装饰器函数：接收目标函数，返回增强后的函数
  function logDecorator(fn) {
    return function(...args) {
      // 装饰逻辑：添加日志
      console.log(`执行函数 ${fn.name}，参数：${args}`);
      // 调用原函数
      const result = fn.apply(this, args);
      // 装饰逻辑：添加返回值日志
      console.log(`函数 ${fn.name} 返回：${result}`);
      return result;
    };
  }
  
  // 使用：装饰原函数
  const addWithLog = logDecorator(add);
  addWithLog(2, 3); 
  // 输出：
  // 执行函数 add，参数：2,3
  // 函数 add 返回：5
  ```

- ES6 语法糖：通过@装饰器 简化（需配置 Babel 或使用 TypeScript）：

  ```javascript
  @logDecorator
  function add(a, b) { return a + b; }
  ```

- **典型场景**：函数防抖 / 节流、日志记录、权限校验。

### 5. 适配器模式

- **核心目标**：解决 “接口不兼容” 问题，让原本无法一起工作的类能协同工作（类似 “转接头”）。

- 与装饰器的区别

  - 适配器：改变接口，不改变功能（如 “HDMI→VGA 转接头”）；
  - 装饰器：不改变接口，增强功能（如 “给手机加保护壳”）。

- 落地代码（数据适配）

  ```javascript
  // 需求：图表组件需要 {name: string, value: number} 格式，但接口返回 {label: string, count: number}
  // 图表组件（目标接口）
  class Chart {
    render(data) {
      data.forEach(item => {
        console.log(`渲染：${item.name} - ${item.value}`);
      });
    }
  }
  
  // 适配器：将接口数据转换为图表所需格式
  class DataAdapter {
    adapt(apiData) {
      return apiData.map(item => ({
        name: item.label, // 接口 label → 图表 name
        value: item.count // 接口 count → 图表 value
      }));
    }
  }
  
  // 使用：通过适配器连接接口和图表
  const apiData = [
    { label: "苹果", count: 100 },
    { label: "香蕉", count: 80 }
  ];
  const adapter = new DataAdapter();
  const chartData = adapter.adapt(apiData);
  
  const chart = new Chart();
  chart.render(chartData); 
  // 输出：
  // 渲染：苹果 - 100
  // 渲染：香蕉 - 80
  ```

- **核心作用**：当接口返回格式无法修改（如第三方接口），或图表组件无法修改时，用适配器解耦。

## 三、行为型模式（解决 “对象交互” 问题）

### 6. 策略模式

- **核心目标**：将 “算法 / 策略” 封装成独立对象，让算法可动态切换（避免 `if-else`/`switch` 堆积）。

- 核心组成

  - 策略类（封装具体算法，如 “人民币转美元”“人民币转欧元”）；
  - 环境类（持有策略对象，调用策略执行）。

- 落地代码（货币转换）

  ```javascript
  // 需求：支持人民币转换为不同货币，可动态切换汇率
  // 策略类：封装不同转换算法
  const ExchangeStrategy = {
    CNY_TO_USD: (amount) => amount * 0.14, // 人民币→美元
    CNY_TO_EUR: (amount) => amount * 0.13, // 人民币→欧元
    CNY_TO_JPY: (amount) => amount * 20    // 人民币→日元
  };
  
  // 环境类：持有策略，提供切换入口
  class CurrencyConverter {
    constructor(strategy) {
      this.strategy = strategy; // 初始策略
    }
  
    // 切换策略
    setStrategy(newStrategy) {
      this.strategy = newStrategy;
    }
  
    // 执行转换（委托给策略）
    convert(amount) {
      return this.strategy(amount);
    }
  }
  
  // 使用：动态切换策略
  const converter = new CurrencyConverter(ExchangeStrategy.CNY_TO_USD);
  console.log(converter.convert(1000)); // 140（美元）
  
  // 切换为欧元转换
  converter.setStrategy(ExchangeStrategy.CNY_TO_EUR);
  console.log(converter.convert(1000)); // 130（欧元）
  ```

- **典型场景**：表单验证（不同字段用不同验证策略）、支付方式切换（支付宝 / 微信 / 银联）。

### 7. 观察者模式

- 核心角色 Subject+Observer：

  - `Subject`（目标对象）：维护观察者列表，提供 “添加 / 移除观察者” 和 “通知所有观察者” 的方法；
  - `Observer`（观察者）：实现 `update` 方法，接收目标对象的通知并响应。

- 落地代码（响应式数据）

  ```javascript
  // 需求：数据变化时，自动更新页面DOM（类似Vue的响应式）
  // 1. 目标对象（Subject）：数据对象
  class DataSubject {
    constructor() {
      this.observers = []; // 观察者列表
      this.value = '';     // 被观察的数据
    }
  
    // 添加观察者
    addObserver(observer) {
      this.observers.push(observer);
    }
  
    // 移除观察者
    removeObserver(observer) {
      this.observers = this.observers.filter(o => o !== observer);
    }
  
    // 通知所有观察者
    notify() {
      this.observers.forEach(observer => observer.update(this.value));
    }
  
    // 设置数据（触发通知）
    setValue(newValue) {
      this.value = newValue;
      this.notify(); // 数据变化，通知观察者
    }
  }
  
  // 2. 观察者（Observer）：DOM更新器
  class DOMObserver {
    constructor(dom) {
      this.dom = dom;
    }
  
    // 实现update方法，响应通知
    update(value) {
      this.dom.textContent = value; // 更新DOM内容
    }
  }
  
  // 使用：
  const input = document.getElementById('input');
  const span = document.getElementById('span');
  
  // 创建目标对象和观察者
  const data = new DataSubject();
  const domObserver = new DOMObserver(span);
  
  // 关联关系
  data.addObserver(domObserver);
  
  // 输入变化时更新数据
  input.addEventListener('input', (e) => {
    data.setValue(e.target.value);
  });
  ```

- 特点

  - 目标与观察者是 “直接关联”（目标知道所有观察者）；
  - 适合 “紧密耦合” 的场景（如组件内部的状态同步）。

### 8. 发布 - 订阅模式

- **核心改进**：引入 “事件调度中心”（中介），发布者和订阅者**不直接通信**（解耦）。

- 核心角色

  - 发布者（Publisher）：向调度中心 “发布事件”（无需知道谁订阅）；
  - 订阅者（Subscriber）：向调度中心 “订阅事件”（无需知道谁发布）；
  - 调度中心（EventBus）：管理事件（注册 / 触发），转发消息。

- 落地代码（全局事件总线）

  ```javascript
  // 1. 事件调度中心（中介）
  class EventBus {
    constructor() {
      this.events = {}; // 存储事件：{ 事件名: [订阅者回调列表] }
    }
  
    // 订阅事件
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = [];
      }
      this.events[eventName].push(callback);
    }
  
    // 发布事件
    emit(eventName, ...args) {
      const callbacks = this.events[eventName] || [];
      callbacks.forEach(callback => callback(...args)); // 触发所有订阅者
    }
  
    // 取消订阅
    off(eventName, callback) {
      if (!this.events[eventName]) return;
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    }
  }
  
  // 2. 发布者1：用户登录组件
  class LoginComponent {
    constructor(eventBus) {
      this.eventBus = eventBus;
    }
  
    login(username) {
      // 登录逻辑...
      // 发布“用户登录”事件（无需知道谁订阅）
      this.eventBus.emit('user-login', username);
    }
  }
  
  // 3. 订阅者1：导航栏组件（登录后更新用户名）
  class NavComponent {
    constructor(eventBus) {
      this.eventBus = eventBus;
      // 订阅“用户登录”事件
      this.eventBus.on('user-login', (username) => {
        console.log(`导航栏更新：欢迎 ${username}`);
      });
    }
  }
  
  // 4. 订阅者2：消息通知组件（登录后拉取消息）
  class NotificationComponent {
    constructor(eventBus) {
      this.eventBus = eventBus;
      this.eventBus.on('user-login', (username) => {
        console.log(`消息组件：为 ${username} 拉取未读消息`);
      });
    }
  }
  
  // 使用：
  const eventBus = new EventBus();
  const loginComp = new LoginComponent(eventBus);
  const navComp = new NavComponent(eventBus);
  const notifyComp = new NotificationComponent(eventBus);
  
  // 触发登录：两个订阅者同时响应
  loginComp.login('Alice');
  // 输出：
  // 导航栏更新：欢迎 Alice
  // 消息组件：为 Alice 拉取未读消息
  ```

- 观察者 vs 发布 - 订阅（核心区别）

  | 维度     | 观察者模式                                                   | 发布 - 订阅模式                                              |
  | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 耦合程度 | 紧耦合（目标直接关联观察者）                                 | 松耦合（通过中介通信）                                       |
  | 通信方式 | 直接调用（目标→观察者）                                      | 间接转发（发布→中介→订阅）                                   |
  | 适用场景 | 组件内部 / 模块内同步                                        | 跨组件 / 跨模块异步通信                                      |
  | 例子     | Vue 组件内的 `watch`                                         | Vue 的 `EventBus`、Node 的 `EventEmitter`                    |
  |          | ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220212123518.png) | ![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220212123141.png) |

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220213212201.png)

## Vue 中两种模式的核心应用场景

| 模式            | Vue 核心应用场景                                             | 核心作用                                     |
| --------------- | ------------------------------------------------------------ | -------------------------------------------- |
| 观察者模式      | 1. Vue 2/Vue 3 响应式系统（`Dep` + `Watcher`/`ReactiveEffect`） 2. 计算属性、`watch` 依赖更新 | 数据变化主动触发依赖更新，支撑 “响应式” 核心 |
| 发布 - 订阅模式 | 1. 事件总线（EventBus）跨组件通信 2. Vuex/Pinia 全局状态管理 3. 组件内置 `$on`/`$emit` 通信 | 解耦模块 / 组件，实现跨层级、多              |

## 四、设计模式核心原则（落地指导）

1. **开闭原则**：对扩展开放，对修改关闭（如工厂模式新增产品无需改调用处）；
2. **单一职责**：一个类 / 函数只做一件事（如装饰器只加日志，不处理业务）；
3. **依赖倒置**：依赖抽象，不依赖具体（如策略模式依赖 “转换接口”，不依赖具体汇率）；
4. **最少知识**：减少对象间的直接交互（如发布 - 订阅用中介减少耦合）。

## 总结

设计模式不是 “银弹”，需**按需使用**：

- 简单场景（如创建一个弹窗）：用简单工厂 / 单例；
- 复杂交互（如跨组件通信）：用发布 - 订阅；
- 功能扩展（如给函数加日志）：用装饰器；
- 接口不兼容（如数据格式转换）：用适配器。
