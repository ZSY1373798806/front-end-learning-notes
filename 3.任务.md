## 2️⃣ 宏任务 & 微任务

### 案例

```
console.log('start here');

new Promise((resolve) => {
  console.log('first promise constructor');
  resolve();
}).then(() => {
  console.log('first promise then');
  return new Promise((resolve) => {
    console.log('second promise');
    resolve();
  }).then(() => {
    console.log('second promise then');
  });
}).then(() => {
  console.log('another first promise then');
});

console.log('end here');
```

**输出**：

```
start here
first promise constructor
end here
first promise then
second promise
second promise then
another first promise then
```

**解析**：

1. 同步执行：`start here` → `first promise constructor` → `end here`
2. 微任务执行：
   - `first promise then`
   - 创建新 promise → `second promise`
   - `second promise then`
   - `another first promise then`

> **结论**：Promise 的 `then` 回调属于微任务，优先级高于宏任务。

------

### 任务队列分类

| 类型               | 典型 API                                                     |
| ------------------ | ------------------------------------------------------------ |
| 宏任务 (MacroTask) | setTimeout, setInterval, setImmediate, I/O, UI渲染, requestAnimationFrame |
| 微任务 (MicroTask) | Promise.then, MutationObserver, process.nextTick (Node), async/await 的 await 后逻辑 |

------

### async/await 解析

```
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(() => console.log('setTimeout'), 0);

async1();

new Promise(resolve => {
  console.log('promise1');
  resolve();
}).then(() => console.log('promise2'));

console.log('script end');
```

**输出顺序**：

```
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

**分析**：

1. 执行同步代码：`script start` → `async1 start` → `async2` → `promise1` → `script end`
2. 微任务队列：
   - async1 中的 await 后逻辑 → 输出 `async1 end`
   - promise.then → 输出 `promise2`
3. 宏任务队列：
   - setTimeout → 输出 `setTimeout`

> **面试题点**：
>
> - 微任务优先于宏任务
> - async/await 本质是 Promise
> - await 右侧不是 Promise，会用 `Promise.resolve()` 包装

------

### 微任务优先级示例

```
const foo = () => new Promise(resolve => {
  console.log('first promise constructor');
  
  let promise1 = new Promise(res => {
    console.log('second promise constructor');
    setTimeout(() => {
      console.log('setTimeout here');
      res();
    }, 0);
    res('promise1');
  });
  
  resolve('promise0');
  promise1.then(arg => console.log(arg));
});

foo().then(arg => console.log(arg));
console.log('end here');
```

**输出**：

```
first promise constructor
second promise constructor
end here
promise1
promise0
setTimeout here
```

**解析**：

- 微任务 (`promise.then`) 优先于宏任务 (`setTimeout`)
- 执行顺序严格：同步 → 微任务 → 宏任务

------

## 3️⃣ 面试题整理

1. **同步任务 vs 异步任务**
   - 同步任务阻塞主线程
   - 异步任务进入任务队列，等待主线程空闲
2. **宏任务 vs 微任务**
   - 微任务优先级高于宏任务
   - Promise.then、async/await、MutationObserver 属于微任务
   - setTimeout、setInterval 属于宏任务
3. **setTimeout 最小延迟**
   - 浏览器 >= 4ms
   - 非活动标签页 >= 1000ms
   - 定时器值为 0 或 1ms 并不保证立即执行
4. **async/await 本质**
   - async 返回 Promise
   - await 会让出主线程
   - await 后逻辑进入微任务队列
5. **任务执行顺序示例**

```
同步代码
→ 微任务队列
→ 宏任务队列
```
