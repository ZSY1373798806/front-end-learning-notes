## 1. DOCTYPE

- 声明形式：`<!DOCTYPE html>`
- **作用**：告诉浏览器文档类型和解析模式（标准模式/兼容模式）。
- **位置**：文档第一行。

------

## 2. HTML 布局相关

### 2.1 BFC 深度面试指南

## 🎯 什么是 BFC？

BFC是块级格式化上下文，就像是一个**独立的容器**，里面的元素不会影响外面的元素，外面的元素也不会影响里面的元素。

------

## 🔧 如何创建 BFC？

### 触发 BFC 的条件（重要面试点）

| 触发方式         | CSS 属性   | 示例                                         | 使用场景   |
| ---------------- | ---------- | -------------------------------------------- | ---------- |
| **根元素**       | html       | `<html>`                                     | 页面默认   |
| **浮动**         | `float`    | `float: left/right`                          | 文字环绕   |
| **绝对定位**     | `position` | `position: absolute/fixed`                   | 脱离文档流 |
| **display 属性** | `display`  | `inline-block`, `table-cell`, `flex`, `grid` | 布局需求   |
| **overflow**     | `overflow` | `overflow: hidden/auto/scroll`               | **最常用** |

------

## 📋 BFC 的特性规则

### 核心特性（必知必会）

1. **内部盒子垂直排列**
   - BFC内部的块级盒子会在垂直方向一个接一个排列
2. **margin 合并规则**
   - 同一BFC内相邻块级元素的margin会合并
   - 不同BFC间的margin不会合并
3. **BFC区域不与float重叠**
   - BFC区域不会与浮动元素重叠
4. **计算BFC高度时包含浮动元素**
   - BFC容器会包含其内部的浮动元素高度
5. **BFC是独立容器**
   - 内部元素不会影响外部元素

------

## 🛠️ BFC 的实际应用场景

### 1. 清除浮动（高频面试题）

**问题：** 父元素高度塌陷

```html
<!-- 问题代码 -->
<div class="parent">
  <div class="child float-left">浮动子元素</div>
</div>

<style>
.float-left { float: left; }
.parent { 
  border: 1px solid red; 
  /* 父元素高度为0，发生高度塌陷 */
}
</style>
```

**解决方案：为父元素创建BFC**

```html
<!-- 解决方案 -->
<div class="parent clearfix">
  <div class="child float-left">浮动子元素</div>
</div>

<style>
.clearfix {
  overflow: hidden; /* 创建BFC */
  /* 或者其他BFC触发方式 */
}
.float-left { float: left; }
.parent { border: 1px solid red; }
</style>
```

### 2. 防止 margin 塌陷

**问题：** 相邻元素 margin 合并

```html
<!-- 问题：两个div的margin会合并成30px而不是60px -->
<div class="box1">第一个盒子</div>
<div class="box2">第二个盒子</div>

<style>
.box1 { margin-bottom: 30px; }
.box2 { margin-top: 30px; }
</style>
```

**解决方案：为其中一个元素创建独立BFC**

```html
<!-- 解决方案 -->
<div class="box1">第一个盒子</div>
<div class="bfc-wrapper">
  <div class="box2">第二个盒子</div>
</div>

<style>
.bfc-wrapper { overflow: hidden; } /* 创建BFC */
.box1 { margin-bottom: 30px; }
.box2 { margin-top: 30px; }
/* 现在总间距是60px */
</style>
```

### 3. 创建两栏布局（自适应布局）

```html
<div class="container">
  <div class="sidebar">侧边栏 (固定宽度)</div>
  <div class="main">主内容区 (自适应)</div>
</div>

<style>
.sidebar {
  width: 200px;
  float: left;
  background: #f0f0f0;
}

.main {
  overflow: hidden; /* 创建BFC，不与浮动元素重叠 */
  background: #fff;
  /* 自动适应剩余宽度 */
}
</style>
```

### 4. 防止元素被浮动元素遮挡

```html
<div class="container">
  <div class="float-box">浮动元素</div>
  <div class="content">
    这段文字很长，在没有BFC的情况下会被浮动元素遮挡...
  </div>
</div>

<style>
.float-box {
  width: 100px;
  height: 100px;
  float: left;
  background: red;
}

.content {
  overflow: hidden; /* 创建BFC，避免被浮动元素遮挡 */
  background: yellow;
}
</style>
```

------

## 💡 常见面试题解析

### 面试题1：BFC的作用和原理

**标准答案：**

- **作用：** 创建独立的渲染区域，解决浮动、margin合并、布局等问题
- **原理：** 通过特定CSS属性触发，使元素具有特殊的格式化规则

### 面试题2：如何清除浮动？为什么overflow:hidden能清除浮动？

**详细解答：**

```html
<!-- 演示代码 -->
<div class="parent">
  <div class="child">浮动子元素</div>
</div>

<style>
.parent {
  border: 2px solid red;
  /* overflow: hidden; */ /* 取消注释看效果 */
}
.child {
  width: 100px;
  height: 100px;
  float: left;
  background: blue;
}
</style>
```

**为什么 `overflow: hidden` 能清除浮动？**

1. `overflow: hidden` 触发了BFC
2. BFC的特性规定：**计算BFC高度时，浮动元素也参与计算**
3. 因此父元素的高度会包含浮动子元素的高度
4. 从而解决了高度塌陷问题

### 面试题3：还有哪些方法可以清除浮动？

**多种清除浮动的方法：**

```css
/* 方法1: BFC - overflow */
.clearfix1 { overflow: hidden; }

/* 方法2: BFC - display */
.clearfix2 { display: flow-root; } /* 专门为BFC设计 */

/* 方法3: 伪元素清除法（推荐） */
.clearfix3::after {
  content: "";
  display: block;
  clear: both;
  height: 0;
  visibility: hidden;
}

/* 方法4: 父元素也浮动 */
.clearfix4 { float: left; width: 100%; }
```

### 面试题4：margin塌陷和margin合并的区别

**详细对比：**

```html
<!-- margin 合并（水平相邻） -->
<div class="box" style="margin-bottom: 20px;">盒子1</div>
<div class="box" style="margin-top: 30px;">盒子2</div>
<!-- 实际间距是30px（取较大值），不是50px -->

<!-- margin 塌陷（父子关系） -->
<div class="parent">
  <div class="child" style="margin-top: 20px;">子元素</div>
</div>
<!-- 子元素的margin-top会传递给父元素 -->
```

**解决方案：**

```css
/* 解决margin合并 */
.separate-bfc {
  overflow: hidden; /* 为其中一个元素创建独立BFC */
}

/* 解决margin塌陷 */
.parent-bfc {
  overflow: hidden; /* 为父元素创建BFC */
  /* 或者 */
  padding-top: 1px;
  /* 或者 */
  border-top: 1px solid transparent;
}
```

------

## 🚀 面试加分项

### 1. 性能考虑

```css
/* 避免频繁触发BFC */
.performance-tips {
  /* ❌ 会创建新的层叠上下文，影响性能 */
  /* position: absolute; */
  
  /* ✅ 推荐使用 overflow 或 display: flow-root */
  overflow: hidden;
  
  /* ✅ 或者现代浏览器专用 */
  display: flow-root;
}
```

------

## 📝 面试题快速回答模板

### 问题："什么是BFC，如何触发，有什么作用？"

**完整回答结构：**

1. **定义：** BFC是块级格式化上下文，是CSS的一个渲染概念，创建独立的布局区域
2. **触发条件：**
   - overflow 不为 visible
   - position 为 absolute 或 fixed
   - display 为 inline-block、table-cell、flex 等
   - float 不为 none
3. **主要作用：**
   - 清除内部浮动（解决高度塌陷）
   - 防止margin合并
   - 创建自适应布局
   - 防止元素重叠
4. **实际应用：**
   - 最常用 `overflow: hidden` 清除浮动
   - 现代推荐使用 `display: flow-root`

### 问题："为什么overflow:hidden能清除浮动？"

**标准答案：** 因为 `overflow: hidden` 会触发BFC，而BFC有一个重要特性：**计算BFC高度时，内部的浮动元素也会参与计算**。所以父元素的高度会包含浮动子元素，从而解决高度塌陷问题。

------

## 💯 总结

BFC是前端面试中的高频考点，掌握以下几点就能应对大部分面试：

1. **概念理解**：独立的格式化上下文
2. **触发方式**：overflow、display、position、float
3. **核心特性**：包含浮动、防止重叠、margin规则
4. **实际应用**：清除浮动、布局、防重叠
5. **现代替代**：display: flow-root、flex、grid

记住：BFC本质上是为了解决CSS布局中的各种"意外情况"，理解了问题就能更好地理解解决方案！

------

## 3. CSS 相关

### 3.1 Flex 布局

- `flex:1` 等价于：

  ```
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: 0%;
  ```

- 属性解析：

  - **flex-grow**：是否允许元素在容器有剩余空间时按比例放大，默认 0。
  - **flex-shrink**：是否允许元素在容器空间不足时按比例缩小，默认 1。
  - **flex-basis**：以 “0 为基础” 计算空间分配（优先按内容大小，但最终会被 `flex-grow` 拉伸），默认 `auto`。

### 3.2 position: sticky

- **条件**：
  1. 父元素不能 `overflow:hidden/auto`
  2. 必须指定 `top/bottom/left/right` 中至少一个
  3. 父元素高度 ≥ sticky 元素高度
  4. sticky 元素只在父元素内生效

### 3.3 动画

- CSS 动画、过渡等可用 `transition` 和 `@keyframes` 实现

### 3.4 瀑布流布局

- 常见实现方式：`float` + JS 或 CSS Grid / Flex

### 3.5 重排（回流）与重绘

- **重排（Reflow）**：DOM 变化影响元素几何信息，需要重新计算布局。
- **重绘（Repaint）**：元素外观变化，但布局不变。
- **关系**：重排一定引起重绘，重绘不一定重排。

### 3.6 盒子模型

- **标准盒子模型**：`width` 指 content 宽度
- **IE 盒子模型**：`width` = content + padding + border

### 3.7 单位

- **px**：绝对单位
- **rem**：相对于根元素 `<html>` 的字体大小
- **em**：相对于父元素字体大小
- #### 1. 如何用 `rem` 实现响应式适配？

  - 核心：动态修改根元素 `font-size`（通过媒体查询或 JS 监听屏幕宽度），使 `rem` 随屏幕尺寸变化。

  - 示例（媒体查询方案）：

    ```css
    /* 屏幕宽度 < 768px 时，1rem = 12px */
    @media (max-width: 767px) {
      html { font-size: 12px; }
    }
    /* 屏幕宽度 ≥ 768px 时，1rem = 16px */
    @media (min-width: 768px) {
      html { font-size: 16px; }
    }
    
    .box { width: 10rem; } /* 小屏幕 120px，大屏幕 160px */
    ```

- #### 2. 移动端适配常用单位方案？

  - **方案 1（rem + JS）**：通过 JS 计算 `html.fontSize = 屏幕宽度 / 设计稿宽度 × 基准值`（如设计稿 750px，设置 1rem = 100px，则 `html.fontSize = window.innerWidth / 7.5`）。
  - **方案 2（vw）**：直接用 `vw` 定义尺寸（如设计稿 750px，1vw = 7.5px，元素在设计稿中 100px → CSS 中 `width: 13.333vw`）。
  - **方案 3（小程序 rpx）**：类似 `vw` 的理念，规定屏幕宽为 750rpx，自动适配不同设备（本质是 `vw` 的封装）。

### 3.8 Sass

- 支持变量、嵌套、Mixin 等高级功能
- 常用变量用于统一管理颜色、字体、间距等
