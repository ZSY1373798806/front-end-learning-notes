# **Webpack 深度解析**

## 1. Webpack 定义

- Webpack 是一个模块打包器（bundler），能将项目整体打包、优化输出。
- 默认只能处理 JS 文件，其他资源依赖 **Loader** 机制。

## 2. Webpack 构建流程（生命周期）

1. **初始化参数**
   - 解析webpack配置参数，合并 shell 参数与 `webpack.config.js` 配置，生成最终配置。
2. **开始编译**
   - 根据得到的参数，初始化 `compiler` 对象。
   - 注册插件，插件监听生命周期钩子。
   - 调用 `compiler.run()` 开始编译。
3. **确定入口**
   - 从 `entry` 入口解析文件，生成 AST。
   - 查找依赖，递归构建依赖图。
4. **编译模块**
   - 根据文件类型和 Loader 转换文件。
   - 再递归处理模块依赖。
   - 直到所有模块编译完成。
5. **完成模块编译并输出**
   - 构建模块依赖关系，生成 chunk。
6. **输出文件**
   - 将 chunk 输出到文件系统。

## 3. Hash 类型

| 类型          | 说明                                       |
| ------------- | ------------------------------------------ |
| `hash`        | 整个编译生成相同 hash                      |
| `chunkhash`   | 基于入口文件和 chunk，改动只影响关联 chunk |
| `contenthash` | 文件内容变化才变化，适合静态资源缓存       |

### 4.核心依赖
- @babel/parser：用于将源码生成AST
- @babel/traverse：对AST节点进行递归遍历
- @babel/preset-env：将获得的ES6的AST转化成ES5
## 5. 常用钩子（Hooks）

| 阶段       | 钩子                       | 描述                       |
| ---------- | -------------------------- | -------------------------- |
| 创建编译器 | `environment`/`initialize` | 读取环境 & 初始化 compiler |
| 编译前     | `run`/`compile`            | 编译器运行，处理缓存       |
| 编译中     | `make`                     | 核心编译流程               |
| 输出前     | `emit`                     | 输出资源                   |
| 编译完成   | `done`                     | 所有流程结束               |

### plugin生命周期

## **1. Compiler 生命周期**

`Compiler` 是整个 Webpack 构建的核心对象，负责管理全局的生命周期和入口配置。插件可以挂载在 `compiler.hooks` 上。

### **主要钩子（按执行顺序）**

| 钩子               | 阶段       | 说明                                              |
| ------------------ | ---------- | ------------------------------------------------- |
| `environment`      | 初始化     | 创建 `compiler` 时读取环境信息                    |
| `afterEnvironment` | 初始化     | environment 后执行，已准备好插件注册              |
| `initialize`       | 初始化     | 初始化 compiler 对象                              |
| `beforeRun`        | 编译前     | compiler.run 前触发                               |
| `run`              | 编译前     | 开始执行 run，准备编译                            |
| `watchRun`         | watch 模式 | 每次 watch 编译前触发                             |
| `beforeCompile`    | 编译前     | 编译开始前处理一些任务                            |
| `compile`          | 编译中     | 创建 compilation 对象前                           |
| `thisCompilation`  | 编译中     | compilation 对象创建时触发                        |
| `compilation`      | 编译中     | compilation 创建完成，可访问 module、chunk 等信息 |
| `afterCompile`     | 编译中     | compilation 编译完成，准备输出                    |

------

## **2. Compilation 生命周期**

`Compilation` 对象表示**一次完整的模块编译过程**，插件可以挂载在 `compilation.hooks` 上做细粒度操作。

### **主要钩子**

| 钩子                  | 阶段     | 说明                           |
| --------------------- | -------- | ------------------------------ |
| `buildModule`         | 构建模块 | 模块构建时触发，可修改模块源码 |
| `succeedModule`       | 构建模块 | 模块构建成功后                 |
| `failedModule`        | 构建模块 | 模块构建失败                   |
| `seal`                | 封装     | 准备生成 chunk 和资源          |
| `optimize`            | 优化     | 所有模块打包前优化阶段         |
| `optimizeModules`     | 优化     | 优化 module 集合               |
| `optimizeChunks`      | 优化     | 优化 chunk 集合                |
| `optimizeAssets`      | 优化     | 优化资源文件，如压缩、修改     |
| `afterOptimizeAssets` | 优化     | 资源优化完成                   |
| `afterSeal`           | 封装     | 所有优化完成，准备输出         |
| `emit`                | 输出     | 输出资源到 output 目录         |
| `afterEmit`           | 输出     | 输出完成，可做清理或统计       |

------

## **3. 总结执行顺序**

```
Compiler Hooks:
environment → afterEnvironment → initialize → beforeRun → run → beforeCompile → compile
  ↓
  Compilation Hooks:
  thisCompilation → compilation → buildModule → succeedModule → optimize → optimizeModules
  → optimizeChunks → optimizeAssets → afterOptimizeAssets → afterSeal → emit → afterEmit
Compiler Hooks continue:
done
```

- **Compiler** → 管理全局生命周期
- **Compilation** → 管理每次编译细节
- **emit** 钩子 → 输出资源阶段，插件最常用
- **done** 钩子 → 编译完全结束，可做日志统计

### plugin重要API

- #### compiler对象： 全局生命周期钩子

  - compiler.hooks：提供了一系列的钩子，用于插件挂载到webpack的整个编译过程；钩子包括：
    - compile、compilation：允许在编译器开始编译以及创建新的编译对象时挂载功能
    - emit、done：这些阶段更适合于生成资源、修改输出和记录状态

- #### compilation对象：模块级生命周期钩子

  - 提供乙烯类钩子，以更细粒度控制编译阶段；比如：
    - optimize、optimizeModule：用于优化阶段
    - buildModule：在构建模块时触发
    - moduleAssets：处理模块产出的资源

- #### tapable： 实现钩子系统

  - webpack依赖于tapable库来实现钩子系统
  - 使用tap()或tapAsync()方法来挂载这些钩子；这些方法通常接受两个参数：插件名称和一个回调函数

Plugin 核心方法

Plugin 是**Webpack 生命周期钩子机制的扩展器**，用于增强打包功能，不直接处理文件内容，而是监听 compiler/compilation 生命周期事件。

| 核心对象               | 方法/属性           | 作用                                 | 示例/说明                                                    |
| ---------------------- | ------------------- | ------------------------------------ | ------------------------------------------------------------ |
| `compiler`             | `compiler.hooks`    | 注册全局生命周期钩子                 | `js compiler.hooks.emit.tap('PluginName', compilation => {...});` |
| `compilation`          | `compilation.hooks` | 注册模块级生命周期钩子               | `js compilation.hooks.optimizeAssets.tap('PluginName', assets => {...});` |
| `tap(name, fn)`        | 方法                | 注册同步钩子                         | `js hook.tap('MyPlugin', () => {...});`                      |
| `tapAsync(name, fn)`   | 方法                | 注册异步钩子，回调完成后通知 webpack | `js hook.tapAsync('MyPlugin', (compilation, callback) => { callback(); });` |
| `tapPromise(name, fn)` | 方法                | 注册异步钩子，返回 Promise           | `js hook.tapPromise('MyPlugin', async (compilation) => {...});` |

#### 示例

- 使用异步钩子

  ```js
  class MyWebpackPlugin {
    apply(compiler) {
      // 监听 emit 钩子
      compiler.hooks.emit.tapAsync("MyWebpackPlugin", (compilation, callback) => {
        // 在这里可以处理 compilation 中的资源、模块等
        console.log("This is an example webpack plugin!");
        // 完成插件处理后调用 callback 通知 webpack
        callback();
      });
    }
  }
  ```

- 统计源码里面的 console.log 调用数量与调用路径

  - 定义插件类

    定义一个JavaScript类；在类的apply方法中，监听webpack的compilation钩子来访问处理模块的源代码

  - 监听适当的webpack钩子

    针对源代码的处理，选择监听compilation阶段的optimizeModule钩子；在这个阶段，模块的源代码可以被访问和修改

  - 处理源代码

    处理每个模块的源代码，可以使用简单的正则表达式来识别console.log的调用

  ```js
  class ConsoleLogStatsPlugin {
    constructor(options = {}) {
      this.options = {
        showAll: false, // 是否显示所有模块（包括没有 console.log 的）
        threshold: 0,  // 只显示超过此数量的模块
        ...options
      };
      this.stats = [];
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("ConsoleLogStatsPlugin", (compilation) => {
        compilation.moduleTemplates.javascript.hooks.render.tap("ConsoleLogStatsPlugin", (moduleSource, module) => {
          if (!module.resource) return moduleSource;
          const source = moduleSource.source();
          const consoleLogMatches = source.match(/console\.(log|info|warn|error)\(/g) || [];
          const count = consoleLogMatches.length;
          if (count > this.options.threshold || this.options.showAll) {
            this.stats.push({
              path: module.resource,
              count,
              warnings: consoleLogMatches.filter(c => c.includes('.warn')).length,
              errors: consoleLogMatches.filter(c => c.includes('.error')).length,
              logs: consoleLogMatches.filter(c => c.includes('.log')).length,
              infos: consoleLogMatches.filter(c => c.includes('.info')).length
            });
          }
          return moduleSource;
        });
        // 在编译完成后输出统计结果
        compilation.hooks.afterProcessAssets.tap("ConsoleLogStatsPlugin", () => {
          if (this.stats.length > 0) {
            const total = this.stats.reduce((sum, item) => sum + item.count, 0);
            console.log(`\n📊 Console Log Statistics (${total} calls in ${this.stats.length} modules):`);
            this.stats
              .sort((a, b) => b.count - a.count)
              .forEach(item => {
                const relativePath = item.path.replace(process.cwd(), '');
                const typeStats = [
                  item.logs > 0 ? `log: ${item.logs}` : '',
                  item.infos > 0 ? `info: ${item.infos}` : '',
                  item.warnings > 0 ? `warn: ${item.warnings}` : '',
                  item.errors > 0 ? `error: ${item.errors}` : ''
                ].filter(Boolean).join(', ');
                console.log(`  ${relativePath}: ${item.count} calls (${typeStats})`);
              });
          } else {
            console.log('\n✅ No console.log calls found in any modules.');
          }
        });
      });
    }
  }
  module.exports = ConsoleLogStatsPlugin;
  ```


### 常用插件
- webpack-dev-server
- webpack-merge
	合并webpack配置
- html-webpack-plugin
	多入口配置
- MiniCSSExtractPlugin
	抽离css文件
- transform-remove-console
  移除控制台打印
-  clean-webpack-plugin
  自动清理dist目录
- webpack-bundle-analyzer
  文件分析工具

### Loader

#### 核心API

| API 名称               | 类型 | 作用               | 使用场景                 |
| :--------------------- | :--- | :----------------- | :----------------------- |
| `this.async()`         | 方法 | 声明异步 loader    | 需要异步操作的 loader    |
| `this.callback()`      | 方法 | 返回多个结果的回调 | 返回 source map 或元数据 |
| `this.emitFile()`      | 方法 | 生成输出文件       | file-loader 等资源处理   |
| `this.getOptions()`    | 方法 | 获取 loader 配置   | 安全获取 loader 选项     |
| `this.cacheable()`     | 方法 | 控制缓存行为       | 优化构建性能             |
| `this.addDependency()` | 方法 | 添加文件依赖       | 监视文件变化             |
| `this.resourcePath`    | 属性 | 当前资源路径       | 获取文件绝对路径         |
| `this.resourceQuery`   | 属性 | 资源查询参数       | 处理带参数的资源         |
| `this.emitError()`     | 方法 | 抛出错误           | 处理转换错误             |
| `this.emitWarning()`   | 方法 | 发出警告           | 非关键问题提示           |

#### 详细API解析与实例

- this.async()

  声明loader为异步模式，返回一个回调函数

  ```js
  module.exports = function(source) {
    const callback = this.async();
    // 模拟异步操作
    setTimeout(() => {
      const result = source.replace('World', 'Loader API');
      callback(null, result);
    }, 100);
  };
  ```

- this.callback()

  返回多个结果（源码、sourceMap、元数据）

  ```js
  module.exports = function(source) {
    // 创建 source map
    const map = generateSourceMap(source);
    this.callback(
      null,          // 错误对象
      source,        // 处理后的源码
      map,           // source map
      { meta: 'data' } // 元数据
    );
  };
  ```

- this.emitFile()

  生成输出文件（常用于资源处理）

  ```js
  module.exports = function(content) {
    const filename = 'asset-[hash].txt';
    // 生成文件
    this.emitFile(filename, content);
    // 返回模块导出
    return `export default ${JSON.stringify(filename)};`;
  };
  ```

- this.getOptions()

  安全获取loader配置（支持JSON Schema验证）

  ```js
  const { validate } = require('schema-utils');
  const schema = {
    type: 'object',
    properties: {
      prefix: { type: 'string' }
    }
  };
  module.exports = function(source) {
    const options = this.getOptions(schema) || {};
    validate(schema, options, {
      name: 'Prefix Loader',
      baseDataPath: 'options'
    });
    return options.prefix + source;
  };
  ```

- this.cacheable()

  控制loader的缓存行为

  ```js
  module.exports = function(source) {
    // 默认启用缓存
    this.cacheable();
    // 如果有动态依赖，可禁用缓存
    if (hasDynamicDependencies) {
      this.cacheable(false);
    }
    return transform(source);
  };
  ```

- this.addDependency()

  添加文件依赖，webpack会监听这些文件的变化

  ```js
  const fs = require('fs');
  const path = require('path');
  
  module.exports = function(source) {
    const configPath = path.resolve('config.json');
    
    // 添加文件依赖
    this.addDependency(configPath);
    
    // 读取配置文件
    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    
    return applyConfig(source, config);
  };
  ```

- this.resourcePath

  获取当前处理文件的绝对路径

  ```js
  module.exports = function(source) {
    // 获取当前文件路径
    const filePath = this.resourcePath;
    // 添加文件头注释
    return `/* File: ${path.basename(filePath)} */\n${source}`;
  };
  ```

- this.resourceQuery

  获取资源URL中的查询参数

  ```js
  module.exports = function(source) {
    const query = new URLSearchParams(this.resourceQuery);
    if (query.has('minify')) {
      return minify(source);
    }
    return source;
  };
  ```

- this.emitError() & this.emitWarning()

  抛出错误和警告

  ```js
  module.exports = function(source) {
    if (source.includes('deprecatedFunction')) {
      this.emitWarning('Deprecated function used');
    }
    try {
      return transform(source);
    } catch (error) {
      this.emitError(error);
      return source; // 返回原始源码作为回退
    }
  };
  ```

## 7. Loader & Plugin 区别

| 类型   | 原理                            | 用途                                |
| ------ | ------------------------------- | ----------------------------------- |
| Loader | 文件加载器，接收文件 → 输出结果 | 转换文件（sass→css, ES6→ES5）       |
| Plugin | 生命周期钩子广播机制            | 扩展 Webpack 功能（优化、打包输出） |

### tree-shaking
- #### 原理

  - ##### 静态分析

    - 模块依赖分析
      - webpack构建过程中，会对项目中的模块进行依赖分析；解析每个模块的内容，确定模块之间的导入和导出关系
      - 通过分析，可以构建出一个模块依赖图，展示各个模块间的引用关系
    - 识别未使用的代码
      - 基于模块依赖图，确定哪些模块被实际引用，哪些模块未被使用
      - 对于 JavaScript 模块，它可以识别出未被调用的函数、未被访问的变量等。对于其他资源文件，如 CSS 和图片，也可以根据引用情况判断是否被使用

  - ##### 代码优化

    - 消除未使用的代码
      - webpack会在打包过程中将未使用的代码从最终的输出文件中移除
      - 可以显著减小打包文件的大小，提高应用的加载速度和性能
    - 作用域分析
      - 在消除代码时，还会进行作用域分析；确保在移除代码的过程中，不会影响到实际使用的代码正确性

  - ##### 实现条件

    - ES2015模块语法
      - Tree-Shaking主要依赖于ES2015模块语法（import、export）；这种模块语法是静态的，使得webpack能够在编译时确定模块的导入和导出关系
      - 相比之下，CommonJS模块语法（require、module.exports）是动态，难以在编译时进行准确的分析
    - 支持的模块类型
    - Webpack 不仅可以对 JavaScript 模块进行 Tree Shaking，还可以对一些其他类型的模块进行处理，如 CSS 模块（通过特定的加载器和插件）
    - 对于不同类型的模块，Webpack 可能会使用不同的技术和策略来实现 Tree Shaking
    - 禁止将模块转成 CommonJS

  - webpack5默认开启

- #### sideEffects

  - 如果所有代码都不包含副作用，可以直接设为false，告知可安全的删除未用到的export
```js
	{
      "name": "your-project",
      "sideEffects": false
    }
```
	- 有些代码存在副作用时，设置为数组

```js
    {
      "name": "your-project",
      "sideEffects": ["./src/some-side-effectful-file.js", "*.css"]
    }
```
- #### usedExports
```js
optimization: {
	usedExports: true
}
```
- #### sideEffects 更为有效 是因为它允许跳过整个模块/文件和整个文件子树。
- #### 前提
	
	- 使用es2015模块语法（即import，export）
	- 确保编译器没有把es2015模块转换成commonjs
### 通过 webpack 按需加载代码，提取第三库代码（splitChunk）
- 实现 提取第三方库 (webpack4的splitChunk)
	由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。
	这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。
```js
optimization: {
      runtimeChunk: {
        name: 'manifest' // 将webpack的runtime代码拆分为一个单独的 chunk。
    },
    splitChunks: {
        cacheGroups: {
            vendor: {
                name: 'chunk-vendors',
                test: /[\\/]node_modules[\\/]/,
                priority: -10,
                chunks: 'initial', // (all，async 和 initial)
            },
            common: {
                name: 'chunk-common',
                minChunks: 2,
                priority: -20,
                chunks: 'initial',
                reuseExistingChunk: true
            }
        },
    }
},
```
	test: 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String和Function;
	priority：表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算；
	reuseExistingChunk：表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。
	minChunks（默认是1）：在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）
	chunks (默认是async) ：initial、async和all
	name(打包的chunks的名字)：字符串或者函数(函数可以根据条件自定义名字)
### webpack执行顺序
![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220212144013.png)
### 面试题
- 将图片插入到页面中
	- 解决方案
		module 下配置 rules
        module: {
            rules: [
                {
                    test:/\.(png|jpg)$/,
                    loader: 'file-loader'
                }
            ]
        }
- 抽离css
- 抽离公共代码

# **Babel 深度解析**

## 1. 定义

- Babel 是 JS 编译器（工具链），用于 ES6+ → 向后兼容 JS。
- 本质就是在操作AST来完成代码的编译；

## 2. 核心流程

1. **解析 Parse**（@babel/parser）
   - 源码 → AST（https://astexplorer.net/）
2. **转换 Transform**
   - 使用插件修改 AST
   - ES6 → ES5 或优化 AST
3. **生成 Generate**（@babel/generator）
   - AST → JS 字符串 + SourceMap

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209103500.png)
![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209103521.png)

## 3. 核心库

| 库               | 作用               |
| ---------------- | ------------------ |
| babel-core       | 核心 API           |
| babel-parser     | 生成 AST           |
| babel-traverse   | 遍历 AST           |
| babel-generator  | AST → JS           |
| babel-types      | 节点构建/校验      |
| babel-template   | 字符串 → AST       |
| babel-runtime    | Polyfill / runtime |
| babel-plugin-xxx | 转换插件           |
| babel-preset-xxx | 插件集合           |

## 4. Babel 转 ES6 → ES5

- Loader 配置：

```
{
  test: /\.js$/,
  exclude: /node_modules/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: ['@babel/preset-env'],
      plugins: ['@babel/plugin-transform-runtime']
    }
  }
}
```

- Polyfill → `core-js` + `regenerator-runtime`

> webpack本身是一个模块打包器（bundler），并不直接负责将ES6代码编译为ES5；webpack主要功能是将项目中的所有模块打包成一个或多个bundle，以供浏览器加载
>
> webpack可以通过loader和plugin扩展功能，实现代码的转换和编译

#### 步骤

- babel转换

- loader配置

- babel预设

  Babel 使用预设（presets）来定义转换规则。`@babel/preset-env` 是一个常用的预设，它会自动配置 Babel 以兼容目标浏览器的版本

- polyfills

  ​	为了支持旧浏览器，Babel 还可以引入 polyfills，这些是提供现代 JavaScript 特性的第三方代码片段。例如，`core-js` 和 `regenerator-runtime` 是两个常用的 polyfill 库

- 转换过程

  - 解析
  - 转换
  - 生成

- Tree Shaking

- 代码分割

- 优化

### webpack-dev-server

webpack-dev-server 是一个开发服务器，它提供了一个快速开发的环境，并且配合Webpack使用

- #### 作用

  - 自动编译和打包
    - 监听源文件的变化，当文件发生改动时，会自动重新编译和打包
  - 热模块替换
  - 代理和反向代理
    - 配置代理Proxy，解决开发环境跨域问题
  - 路由处理
  - 静态文件服务
