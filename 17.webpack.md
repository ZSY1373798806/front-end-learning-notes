# **Webpack 深度解析**

## 1. Webpack 定义

- Webpack 是一个模块打包器（bundler），能将项目整体打包、优化输出。
- 默认只能处理 JS 文件，其他资源依赖 **Loader** 机制。

## 2. Webpack 构建流程（生命周期）

Webpack 构建流程遵循 “初始化 → 编译 → 输出” 的逻辑，每个阶段通过**钩子（Hooks）** 暴露扩展点，插件可通过钩子干预流程。

#### 完整流程拆解

##### （1）初始化阶段

- **参数合并**：整合 `webpack.config.js`、默认配置、CLI 命令参数（如 `--mode`），生成最终配置对象。
- **创建 Compiler 对象**：全局唯一的 “编译器”，负责管理整个构建生命周期，包含配置信息和钩子系统。
- **插件注册**：执行所有插件的 `apply(compiler)` 方法，插件通过 `compiler.hooks` 挂载钩子。

##### （2）编译阶段

- **确定入口**：从 `entry` 配置解析入口文件（如 `src/index.js`），生成抽象语法树（AST）。

- **模块解析**

  ：递归解析入口文件的依赖（import/require），对每个模块执行：

  - **Loader 转换**：非 JS 模块（如 `.css`、`.vue`）通过对应 Loader 转为 JS 模块（如 `css-loader` 处理 CSS 依赖）。
  - **依赖收集**：记录模块间的依赖关系，构建 “模块依赖图”。

- **创建 Compilation 对象**：单次编译的 “执行者”，包含当前编译的模块、chunk、资源等信息，暴露更细粒度的钩子（`compilation.hooks`）。

##### （3）输出阶段

- **生成 Chunk**：根据依赖图和 `splitChunks` 配置，将模块拆分为多个 chunk（代码块，如入口 chunk、公共 chunk）。
- **优化处理**：执行内置优化（Tree-Shaking、Scope Hoisting）和插件优化（如压缩、注入变量）。
- **写入文件**：将 chunk 渲染为最终文件（如 JS、CSS），输出到 `output.path` 目录（如 `dist`）。
- **完成构建**：触发 `done` 钩子，输出构建统计信息（耗时、文件列表等）。

#### 核心对象关系

- `Compiler`：全局生命周期管理者，一个构建过程只实例化一次。
- `Compilation`：单次编译的细节管理者，文件变化触发重新编译时会创建新实例。

## 3. Hash 类型

| 类型          | 说明                                       |
| ------------- | ------------------------------------------ |
| `hash`        | 整个编译生成相同 hash                      |
| `chunkhash`   | 基于入口文件和 chunk，改动只影响关联 chunk |
| `contenthash` | 文件内容变化才变化，适合静态资源缓存       |

### 4.核心依赖
- @babel/parser：用于将源码生成AST
- @babel/traverse：对AST节点进行递归遍历
- @babel/preset-env：将获得的ES6的AST转化成ES5
## 5. 常用钩子（Hooks）

| 阶段       | 钩子                       | 描述                       |
| ---------- | -------------------------- | -------------------------- |
| 创建编译器 | `environment`/`initialize` | 读取环境 & 初始化 compiler |
| 编译前     | `run`/`compile`            | 编译器运行，处理缓存       |
| 编译中     | `make`                     | 核心编译流程               |
| 输出前     | `emit`                     | 输出资源                   |
| 编译完成   | `done`                     | 所有流程结束               |

### plugin生命周期

## **1. Compiler 生命周期**

`Compiler` 是整个 Webpack 构建的核心对象，负责管理全局的生命周期和入口配置。插件可以挂载在 `compiler.hooks` 上。

### **主要钩子（按执行顺序）**

| 钩子               | 阶段       | 说明                                              |
| ------------------ | ---------- | ------------------------------------------------- |
| `environment`      | 初始化     | 创建 `compiler` 时读取环境信息                    |
| `afterEnvironment` | 初始化     | environment 后执行，已准备好插件注册              |
| `initialize`       | 初始化     | 初始化 compiler 对象                              |
| `beforeRun`        | 编译前     | compiler.run 前触发                               |
| `run`              | 编译前     | 开始执行 run，准备编译                            |
| `watchRun`         | watch 模式 | 每次 watch 编译前触发                             |
| `beforeCompile`    | 编译前     | 编译开始前处理一些任务                            |
| `compile`          | 编译中     | 创建 compilation 对象前                           |
| `thisCompilation`  | 编译中     | compilation 对象创建时触发                        |
| `compilation`      | 编译中     | compilation 创建完成，可访问 module、chunk 等信息 |
| `afterCompile`     | 编译中     | compilation 编译完成，准备输出                    |

------

## **2. Compilation 生命周期**

`Compilation` 对象表示**一次完整的模块编译过程**，插件可以挂载在 `compilation.hooks` 上做细粒度操作。

### **主要钩子**

| 钩子                  | 阶段     | 说明                           |
| --------------------- | -------- | ------------------------------ |
| `buildModule`         | 构建模块 | 模块构建时触发，可修改模块源码 |
| `succeedModule`       | 构建模块 | 模块构建成功后                 |
| `failedModule`        | 构建模块 | 模块构建失败                   |
| `seal`                | 封装     | 准备生成 chunk 和资源          |
| `optimize`            | 优化     | 所有模块打包前优化阶段         |
| `optimizeModules`     | 优化     | 优化 module 集合               |
| `optimizeChunks`      | 优化     | 优化 chunk 集合                |
| `optimizeAssets`      | 优化     | 优化资源文件，如压缩、修改     |
| `afterOptimizeAssets` | 优化     | 资源优化完成                   |
| `afterSeal`           | 封装     | 所有优化完成，准备输出         |
| `emit`                | 输出     | 输出资源到 output 目录         |
| `afterEmit`           | 输出     | 输出完成，可做清理或统计       |

------

## **3. 总结执行顺序**

```
Compiler Hooks:
environment → afterEnvironment → initialize → beforeRun → run → beforeCompile → compile
  ↓
  Compilation Hooks:
  thisCompilation → compilation → buildModule → succeedModule → optimize → optimizeModules
  → optimizeChunks → optimizeAssets → afterOptimizeAssets → afterSeal → emit → afterEmit
Compiler Hooks continue:
done
```

- **Compiler** → 管理全局生命周期
- **Compilation** → 管理每次编译细节
- **emit** 钩子 → 输出资源阶段，插件最常用
- **done** 钩子 → 编译完全结束，可做日志统计

### plugin重要API

- #### compiler对象： 全局生命周期钩子

  - compiler.hooks：提供了一系列的钩子，用于插件挂载到webpack的整个编译过程；钩子包括：
    - compile、compilation：允许在编译器开始编译以及创建新的编译对象时挂载功能
    - emit、done：这些阶段更适合于生成资源、修改输出和记录状态

- #### compilation对象：模块级生命周期钩子

  - 提供乙烯类钩子，以更细粒度控制编译阶段；比如：
    - optimize、optimizeModule：用于优化阶段
    - buildModule：在构建模块时触发
    - moduleAssets：处理模块产出的资源

- #### tapable： 实现钩子系统

  - webpack依赖于tapable库来实现钩子系统
  - 使用tap()或tapAsync()方法来挂载这些钩子；这些方法通常接受两个参数：插件名称和一个回调函数

Plugin 核心方法

Plugin 是**Webpack 生命周期钩子机制的扩展器**，用于增强打包功能，不直接处理文件内容，而是监听 compiler/compilation 生命周期事件。

| 核心对象               | 方法/属性           | 作用                                 | 示例/说明                                                    |
| ---------------------- | ------------------- | ------------------------------------ | ------------------------------------------------------------ |
| `compiler`             | `compiler.hooks`    | 注册全局生命周期钩子                 | `js compiler.hooks.emit.tap('PluginName', compilation => {...});` |
| `compilation`          | `compilation.hooks` | 注册模块级生命周期钩子               | `js compilation.hooks.optimizeAssets.tap('PluginName', assets => {...});` |
| `tap(name, fn)`        | 方法                | 注册同步钩子                         | `js hook.tap('MyPlugin', () => {...});`                      |
| `tapAsync(name, fn)`   | 方法                | 注册异步钩子，回调完成后通知 webpack | `js hook.tapAsync('MyPlugin', (compilation, callback) => { callback(); });` |
| `tapPromise(name, fn)` | 方法                | 注册异步钩子，返回 Promise           | `js hook.tapPromise('MyPlugin', async (compilation) => {...});` |

#### 示例

- 使用异步钩子

  ```js
  class MyWebpackPlugin {
    apply(compiler) {
      // 监听 emit 钩子
      compiler.hooks.emit.tapAsync("MyWebpackPlugin", (compilation, callback) => {
        // 在这里可以处理 compilation 中的资源、模块等
        console.log("This is an example webpack plugin!");
        // 完成插件处理后调用 callback 通知 webpack
        callback();
      });
    }
  }
  ```

### 常用插件

- webpack-dev-server
- webpack-merge
	合并webpack配置
- html-webpack-plugin
	多入口配置
- MiniCSSExtractPlugin
	抽离css文件
- transform-remove-console
  移除控制台打印
-  clean-webpack-plugin
  自动清理dist目录
- webpack-bundle-analyzer
  文件分析工具

### Loader

#### 核心API

| API 名称               | 类型 | 作用               | 使用场景                 |
| :--------------------- | :--- | :----------------- | :----------------------- |
| `this.async()`         | 方法 | 声明异步 loader    | 需要异步操作的 loader    |
| `this.callback()`      | 方法 | 返回多个结果的回调 | 返回 source map 或元数据 |
| `this.emitFile()`      | 方法 | 生成输出文件       | file-loader 等资源处理   |
| `this.getOptions()`    | 方法 | 获取 loader 配置   | 安全获取 loader 选项     |
| `this.cacheable()`     | 方法 | 控制缓存行为       | 优化构建性能             |
| `this.addDependency()` | 方法 | 添加文件依赖       | 监视文件变化             |
| `this.resourcePath`    | 属性 | 当前资源路径       | 获取文件绝对路径         |
| `this.resourceQuery`   | 属性 | 资源查询参数       | 处理带参数的资源         |
| `this.emitError()`     | 方法 | 抛出错误           | 处理转换错误             |
| `this.emitWarning()`   | 方法 | 发出警告           | 非关键问题提示           |

#### 详细API解析与实例

- this.async()

  声明loader为异步模式，返回一个回调函数

  ```js
  module.exports = function(source) {
    const callback = this.async();
    // 模拟异步操作
    setTimeout(() => {
      const result = source.replace('World', 'Loader API');
      callback(null, result);
    }, 100);
  };
  ```

- this.callback()

  返回多个结果（源码、sourceMap、元数据）

  ```js
  module.exports = function(source) {
    // 创建 source map
    const map = generateSourceMap(source);
    this.callback(
      null,          // 错误对象
      source,        // 处理后的源码
      map,           // source map
      { meta: 'data' } // 元数据
    );
  };
  ```

- this.emitFile()

  生成输出文件（常用于资源处理）

  ```js
  module.exports = function(content) {
    const filename = 'asset-[hash].txt';
    // 生成文件
    this.emitFile(filename, content);
    // 返回模块导出
    return `export default ${JSON.stringify(filename)};`;
  };
  ```

- this.getOptions()

  安全获取loader配置（支持JSON Schema验证）

  ```js
  const { validate } = require('schema-utils');
  const schema = {
    type: 'object',
    properties: {
      prefix: { type: 'string' }
    }
  };
  module.exports = function(source) {
    const options = this.getOptions(schema) || {};
    validate(schema, options, {
      name: 'Prefix Loader',
      baseDataPath: 'options'
    });
    return options.prefix + source;
  };
  ```

- this.cacheable()

  控制loader的缓存行为

  ```js
  module.exports = function(source) {
    // 默认启用缓存
    this.cacheable();
    // 如果有动态依赖，可禁用缓存
    if (hasDynamicDependencies) {
      this.cacheable(false);
    }
    return transform(source);
  };
  ```

- this.addDependency()

  添加文件依赖，webpack会监听这些文件的变化

  ```js
  const fs = require('fs');
  const path = require('path');
  
  module.exports = function(source) {
    const configPath = path.resolve('config.json');
    
    // 添加文件依赖
    this.addDependency(configPath);
    
    // 读取配置文件
    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    
    return applyConfig(source, config);
  };
  ```

- this.resourcePath

  获取当前处理文件的绝对路径

  ```js
  module.exports = function(source) {
    // 获取当前文件路径
    const filePath = this.resourcePath;
    // 添加文件头注释
    return `/* File: ${path.basename(filePath)} */\n${source}`;
  };
  ```

- this.resourceQuery

  获取资源URL中的查询参数

  ```js
  module.exports = function(source) {
    const query = new URLSearchParams(this.resourceQuery);
    if (query.has('minify')) {
      return minify(source);
    }
    return source;
  };
  ```

- this.emitError() & this.emitWarning()

  抛出错误和警告

  ```js
  module.exports = function(source) {
    if (source.includes('deprecatedFunction')) {
      this.emitWarning('Deprecated function used');
    }
    try {
      return transform(source);
    } catch (error) {
      this.emitError(error);
      return source; // 返回原始源码作为回退
    }
  };
  ```

### tree-shaking
- #### 原理

  - ##### 静态分析

    - 模块依赖分析
      - webpack构建过程中，会对项目中的模块进行依赖分析；解析每个模块的内容，确定模块之间的导入和导出关系
      - 通过分析，可以构建出一个模块依赖图，展示各个模块间的引用关系
    - 识别未使用的代码
      - 基于模块依赖图，确定哪些模块被实际引用，哪些模块未被使用
      - 对于 JavaScript 模块，它可以识别出未被调用的函数、未被访问的变量等。对于其他资源文件，如 CSS 和图片，也可以根据引用情况判断是否被使用

  - ##### 代码优化

    - 消除未使用的代码
      - webpack会在打包过程中将未使用的代码从最终的输出文件中移除
      - 可以显著减小打包文件的大小，提高应用的加载速度和性能
    - 作用域分析
      - 在消除代码时，还会进行作用域分析；确保在移除代码的过程中，不会影响到实际使用的代码正确性

  - ##### 实现条件

    - ES2015模块语法
      - Tree-Shaking主要依赖于ES2015模块语法（import、export）；这种模块语法是静态的，使得webpack能够在编译时确定模块的导入和导出关系
      - 相比之下，CommonJS模块语法（require、module.exports）是动态，难以在编译时进行准确的分析
    - 支持的模块类型
    - Webpack 不仅可以对 JavaScript 模块进行 Tree Shaking，还可以对一些其他类型的模块进行处理，如 CSS 模块（通过特定的加载器和插件）
    - 对于不同类型的模块，Webpack 可能会使用不同的技术和策略来实现 Tree Shaking
    - 禁止将模块转成 CommonJS

  - webpack5默认开启

- #### sideEffects

  - 如果所有代码都不包含副作用，可以直接设为false，告知可安全的删除未用到的export
```js
	{
      "name": "your-project",
      "sideEffects": false
    }
```
	- 有些代码存在副作用时，设置为数组

```js
    {
      "name": "your-project",
      "sideEffects": ["./src/some-side-effectful-file.js", "*.css"]
    }
```
- #### usedExports
```js
optimization: {
	usedExports: true
}
```
- #### sideEffects 更为有效 是因为它允许跳过整个模块/文件和整个文件子树。
- #### 前提
	
	- 使用es2015模块语法（即import，export）
	- 确保编译器没有把es2015模块转换成commonjs
### 通过 webpack 按需加载代码，提取第三库代码（splitChunk）
- 实现 提取第三方库 (webpack4的splitChunk)
	由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。
	这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。
```js
optimization: {
      runtimeChunk: {
        name: 'manifest' // 将webpack的runtime代码拆分为一个单独的 chunk。
    },
    splitChunks: {
        cacheGroups: {
            vendor: {
                name: 'chunk-vendors',
                test: /[\\/]node_modules[\\/]/,
                priority: -10,
                chunks: 'initial', // (all，async 和 initial)
            },
            common: {
                name: 'chunk-common',
                minChunks: 2,
                priority: -20,
                chunks: 'initial',
                reuseExistingChunk: true
            }
        },
    }
},
```
	test: 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String和Function;
	priority：表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算；
	reuseExistingChunk：表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。
	minChunks（默认是1）：在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）
	chunks (默认是async) ：initial、async和all
	name(打包的chunks的名字)：字符串或者函数(函数可以根据条件自定义名字)
### webpack执行顺序
![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220212144013.png)
### 面试题
- 将图片插入到页面中
	- 解决方案
		module 下配置 rules
        module: {
            rules: [
                {
                    test:/\.(png|jpg)$/,
                    loader: 'file-loader'
                }
            ]
        }
- 抽离css
- 抽离公共代码

# **Babel 深度解析**

## 1. 定义

- Babel 是 JS 编译器（工具链），用于 ES6+ → 向后兼容 JS。
- 本质就是在操作AST来完成代码的编译；

## 2. 核心流程

1. **解析 Parse**（@babel/parser）
   - 源码 → AST（https://astexplorer.net/）
2. **转换 Transform**
   - 使用插件修改 AST
   - ES6 → ES5 或优化 AST
3. **生成 Generate**（@babel/generator）
   - AST → JS 字符串 + SourceMap

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209103500.png)
![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220209103521.png)

## 3. 核心库

| 库               | 作用               |
| ---------------- | ------------------ |
| babel-core       | 核心 API           |
| babel-parser     | 生成 AST           |
| babel-traverse   | 遍历 AST           |
| babel-generator  | AST → JS           |
| babel-types      | 节点构建/校验      |
| babel-template   | 字符串 → AST       |
| babel-runtime    | Polyfill / runtime |
| babel-plugin-xxx | 转换插件           |
| babel-preset-xxx | 插件集合           |

## 4. Babel 转 ES6 → ES5

- Loader 配置：

```js
{
  test: /\.js$/,
  exclude: /node_modules/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: ['@babel/preset-env'],
      plugins: ['@babel/plugin-transform-runtime']
    }
  }
}
```

- Polyfill → `core-js` + `regenerator-runtime`

> webpack本身是一个模块打包器（bundler），并不直接负责将ES6代码编译为ES5；webpack主要功能是将项目中的所有模块打包成一个或多个bundle，以供浏览器加载
>
> webpack可以通过loader和plugin扩展功能，实现代码的转换和编译

#### 步骤

- babel转换

- loader配置

- babel预设

  Babel 使用预设（presets）来定义转换规则。`@babel/preset-env` 是一个常用的预设，它会自动配置 Babel 以兼容目标浏览器的版本

- polyfills

  ​	为了支持旧浏览器，Babel 还可以引入 polyfills，这些是提供现代 JavaScript 特性的第三方代码片段。例如，`core-js` 和 `regenerator-runtime` 是两个常用的 polyfill 库

- 转换过程

  - 解析
  - 转换
  - 生成

- Tree Shaking

- 代码分割

- 优化

### webpack-dev-server

webpack-dev-server 是一个开发服务器，它提供了一个快速开发的环境，并且配合Webpack使用

- #### 作用

  - 自动编译和打包
    - 监听源文件的变化，当文件发生改动时，会自动重新编译和打包
  - 热模块替换
  - 代理和反向代理
    - 配置代理Proxy，解决开发环境跨域问题
  - 路由处理
  - 静态文件服务

# 🔑 Loader & Plugin 区别

## 1. **Loader（加载器）**

### 定义

- Loader 是一个 **转换器**，它告诉 Webpack **如何处理某类文件**。
- 本质是一个函数，输入源文件内容，输出处理后的内容。

### 使用场景

- 转换非 JS 文件，让 Webpack 能理解它们：
  - `babel-loader` → 把 ES6+ 转成 ES5
  - `css-loader` → 处理 CSS 中的 `@import` 和 `url()`
  - `file-loader / url-loader` → 处理图片、字体等资源
  - `ts-loader` → 处理 TypeScript

### 特点

- **针对某一类文件**
- **作用于文件级别**（在模块加载时处理源代码）
- **是一个转换函数** `(source) => transformedSource`

### 简单示例

```
// my-loader.js
module.exports = function (source) {
  return source.replace('hello', 'hi');
};
```

Webpack 配置：

```
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/, 
        use: './my-loader.js'
      }
    ]
  }
}
```

------

## 2. **Plugin（插件）**

### 定义

- Plugin 是一个 **扩展器**，它基于 Webpack 的 **事件流机制**，可以在编译的不同阶段注入逻辑。
- 本质是一个包含 `apply(compiler)` 方法的对象。

### 使用场景

- 更底层、更广泛的功能扩展：
  - 优化输出（`TerserWebpackPlugin` 压缩 JS）
  - 注入变量（`DefinePlugin`）
  - 自动生成 HTML（`HtmlWebpackPlugin`）
  - 拷贝静态资源（`CopyWebpackPlugin`）
  - 自定义日志、打包完成通知等

### 特点

- **作用范围更广**（整个编译周期都能介入）
- **通过 compiler / compilation 的 hooks 与 Webpack 交互**
- **不是处理文件内容，而是干预构建流程**

### 简单示例

```
// my-plugin.js
class MyPlugin {
  apply(compiler) {
    compiler.hooks.done.tap('MyPlugin', (stats) => {
      console.log('🎉 Build finished!');
    });
  }
}

module.exports = MyPlugin;
```

Webpack 配置：

```
const MyPlugin = require('./my-plugin.js');

module.exports = {
  plugins: [
    new MyPlugin()
  ]
}
```

------

## 3. 对比总结表

| 对比项       | Loader                            | Plugin                                      |
| ------------ | --------------------------------- | ------------------------------------------- |
| **本质**     | 文件转换器（函数）                | 构建流程扩展器（类 / 对象，含 apply 方法）  |
| **作用时机** | 模块加载阶段（打包前）            | 整个编译生命周期                            |
| **作用范围** | 单个文件类型                      | 全局构建过程                                |
| **输入输出** | 输入：源文件 → 输出：转换后代码   | 通过 hooks 操作 compiler / compilation 对象 |
| **典型用途** | 转换文件内容（JS、CSS、图片、TS） | 优化、注入变量、生成文件、压缩、日志        |
| **示例**     | babel-loader、css-loader          | HtmlWebpackPlugin、DefinePlugin             |

------

## 4. 一个类比帮助理解

- **Loader** 像“翻译员” → 把源码从 A 语言翻译成 JS 语言，Webpack 才能理解。
- **Plugin** 像“导演” → 控制整个打包流程的不同阶段，比如什么时候开机、加特效、导出结果。

------

👉 总结一句话：
 **Loader 解决“文件怎么处理”，Plugin 解决“构建流程怎么扩展”。**
