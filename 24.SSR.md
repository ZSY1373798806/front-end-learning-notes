# 一、SSR 基本概念

- **SSR（Server-Side Rendering）**：在服务器端把前端组件渲染成 HTML 字符串，再返回给浏览器。
- **意义**：
  1. **首屏渲染更快**（不必等待 JS 加载完再生成 DOM）
  2. **更利于 SEO**（搜索引擎爬虫直接拿到 HTML）
  3. **减少白屏时间**
- **缺点**：
  1. 服务端压力更大
  2. 开发和部署复杂
  3. 需要处理客户端/服务端数据同步问题

------

# 二、Vue2 SSR

### 1. 原理

- Vue 提供 `vue-server-renderer` 把 Vue 组件渲染为字符串
- 客户端再通过 `new Vue({ el: '#app', ... })` 接管服务端渲染的内容（称为 hydration）

### 2. 核心代码示例

#### server.js

```
const Vue = require('vue');
const express = require('express');
const renderer = require('vue-server-renderer').createRenderer();

const server = express();

server.get('*', (req, res) => {
  const app = new Vue({
    data: {
      url: req.url
    },
    template: `<div>访问的 URL 是：{{ url }}</div>`
  });

  renderer.renderToString(app, (err, html) => {
    if (err) {
      res.status(500).end('Server Error');
      return;
    }
    res.end(`
      <!DOCTYPE html>
      <html lang="zh-CN">
        <head><title>Vue2 SSR</title></head>
        <body>${html}</body>
      </html>
    `);
  });
});

server.listen(8080);
```

#### client.js

```
import Vue from 'vue';
import App from './App.vue';

new Vue({
  render: h => h(App)
}).$mount('#app');
```

------

# 三、React18 SSR

### 1. 原理

- 使用 `react-dom/server` 提供的 `renderToString` 或 `renderToPipeableStream`
- React18 推荐 `renderToPipeableStream`，支持 **流式渲染**（更快的首屏）

### 2. 核心代码示例

#### server.js

```
import express from 'express';
import React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import App from './App';

const server = express();

server.get('*', (req, res) => {
  const { pipe } = renderToPipeableStream(
    <App url={req.url} />,
    {
      onShellReady() {
        res.statusCode = 200;
        res.setHeader('Content-type', 'text/html');
        res.write(`<!DOCTYPE html><html><head><title>React18 SSR</title></head><body><div id="root">`);
        pipe(res);
        res.write(`</div><script src="/client.js"></script></body></html>`);
      }
    }
  );
});

server.listen(3000);
```

#### client.js

```
import { hydrateRoot } from 'react-dom/client';
import App from './App';

hydrateRoot(document.getElementById('root'), <App />);
```

------

# 四、Vue2 vs React18 SSR 对比

| 对比项          | Vue2 SSR                       | React18 SSR                        |
| --------------- | ------------------------------ | ---------------------------------- |
| API             | vue-server-renderer            | react-dom/server                   |
| 数据获取        | `asyncData` / `serverPrefetch` | 手动在服务端拉取数据，传 props     |
| 同构（hydrate） | `new Vue().$mount('#app')`     | `hydrateRoot`                      |
| 流式渲染        | 支持（需额外实现）             | 原生支持（renderToPipeableStream） |
| 框架支持        | Nuxt.js                        | Next.js                            |

------

# 五、面试常见问题

### 1. SSR 的优缺点？

- 优点：首屏快、SEO 好
- 缺点：服务器压力大、复杂度高、开发调试更难

------

### 2. Vue2 SSR 如何实现数据预取？

- Vue2 SSR 可以在组件中定义 `asyncData` 或 `serverPrefetch`，在服务端先拉取数据，再把数据注入到 store，返回 HTML 时带上 `<script>` 注入客户端。

------

### 3. React18 SSR 新特性？

- `renderToPipeableStream` 支持流式渲染
- 可以 **分片传输 HTML**，不必等整个 React 树渲染完才返回

------

### 4. SSR 如何防止客户端/服务端渲染不一致？

- 确保 **数据源一致**（服务端获取数据后通过 `<script>` 注入客户端）
- 避免在服务端使用 `window / document`（不存在）
- 确保随机数、时间戳等在两端一致

------

### 5. SSR 和 CSR 的区别？

- CSR（客户端渲染）：首次加载慢，SEO 差，但交互快
- SSR：首次快，SEO 好，但服务端压力大