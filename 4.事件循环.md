## **1️⃣ 浏览器中的事件循环（Event Loop）**

### **核心概念**

事件循环（**Event Loop**）是 **js执行机制的核心**，它负责协调 **执行栈（Call Stack）**、**任务队列（Task Queue）** 和 **浏览器渲染**，保证 **异步任务** 能够有序执行

- JavaScript 是单线程的，所有同步任务在 **执行栈（Call Stack）** 执行。
- 异步任务不会阻塞主线程，而是交给 **浏览器环境（Web APIs）** 处理。
- 异步任务分为：
  - **宏任务（Macrotask）**：`setTimeout`、`setInterval`、`setImmediate`（Node）、`I/O`、`requestAnimationFrame`、requestIdleCallback
  - **微任务（Microtask）**：`Promise.then`、`MutationObserver`、`queueMicrotask`

> 🔑 特点：**微任务优先于宏任务执行**，在一次事件循环（tick）中，先清空微任务，再执行宏任务。

------

### **任务队列与执行顺序**

1. **执行栈**：同步代码依次入栈执行。
2. **异步任务**：遇到异步函数，将回调交给 **Web APIs**，等待事件完成。
3. **微任务队列**：回调放入微任务队列，如 `Promise.then`。
4. **宏任务队列**：回调放入宏任务队列，如 `setTimeout`。
5. **事件循环流程**：

```
循环步骤：
1️⃣ 执行栈中的同步代码
2️⃣ 同步代码执行完，清空微任务队列
3️⃣ 执行宏任务队列中的第一个任务
4️⃣ 宏任务执行完，再次清空微任务队列
5️⃣ 重复宏任务 -> 微任务 -> 宏任务循环
```

> 🔹 示例代码：

```js
console.log('script start');

setTimeout(() => console.log('setTimeout'), 0);

Promise.resolve().then(() => console.log('promise1')).then(() => console.log('promise2'));

console.log('script end');
```

**输出顺序：**

```
script start
script end
promise1
promise2
setTimeout
```

> ✅ 理解关键点：
>
> - 同步代码最先执行
> - 微任务总在当前宏任务结束后立即执行
> - 每个宏任务开始前，微任务队列一定是空的

![](https://i-coder.oss-cn-beijing.aliyuncs.com/files/20220208235541.png)

### **MutationObserver 示例**

```js
const targetNode = document.getElementById('some-id');
const config = { attributes: true, childList: true, subtree: true };
const observer = new MutationObserver((mutationsList) => {
  console.log('DOM变化了', mutationsList);
});
observer.observe(targetNode, config);

// 停止观察
// observer.disconnect();
```

- 它属于微任务，优先级高于宏任务。

### requestIdleCallback

`requestIdleCallback` 是浏览器提供的一个**宏任务调度 API**，但它有些特别，不同于普通的 `setTimeout` 或 `setInterval`。我们仔细分析一下：

------

## **1️⃣ 基本概念**

- 用途：在浏览器**空闲时间**执行一些低优先级任务（例如，日志收集、预加载、非紧急计算）。
- 语法：

```js
requestIdleCallback(callback, options);
```

- **参数**：
  - `callback(deadline)`：当浏览器空闲时执行的函数，`deadline` 对象提供剩余空闲时间。
    - `deadline.timeRemaining()`：返回当前空闲时间（ms），可用于决定是否继续执行耗时操作。
    - `deadline.didTimeout`：表示是否因为超时而被执行。
  - `options`：
    - `timeout`：可选，强制在指定时间后执行回调，即使浏览器仍然忙碌。

------

## **2️⃣ 执行机制**

- **类型**：宏任务（Macrotask）
- 但是有特点：
  - 它不会立即执行，而是**等待浏览器空闲**。
  - 当浏览器有空闲帧时才执行。
  - 优先级低于普通宏任务（如 `setTimeout`），不会阻塞页面渲染。

> 🔹 类比：
>
> - `setTimeout(fn, 0)` → 尽快执行
> - `requestIdleCallback(fn)` → 在浏览器空闲时执行

------

## **3️⃣ 示例**

```js
requestIdleCallback((deadline) => {
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    const task = tasks.shift();
    task();
  }
}, { timeout: 2000 }); // 最多等2秒
```

- 当浏览器空闲时，会批量处理任务。
- 如果空闲时间不足，可以等下一次空闲再继续。

------

## **4️⃣ 注意事项**

- 不是每个浏览器都支持（IE 不支持）。
- 不保证立即执行，所以不能用来做关键业务逻辑。
- 更适合执行非关键、可延迟的操作。

## **2️⃣ Node.js 中的事件循环**

### **核心原理**

- Node 使用 **V8 引擎** 执行 JS。
- I/O 采用 **libuv**，是跨平台的事件驱动库。
- Node 的事件循环阶段比浏览器更复杂，分为多个阶段，每个阶段处理特定任务：

| 阶段                  | 作用                                        | 任务类型 |
| --------------------- | ------------------------------------------- | -------- |
| **timers**            | 处理 `setTimeout` 和 `setInterval` 到期回调 | 宏任务   |
| **pending callbacks** | 执行一些系统操作回调                        | 宏任务   |
| **idle, prepare**     | 内部使用                                    | -        |
| **poll**              | 获取新的 I/O 事件，并执行与 I/O 相关的回调  | 宏任务   |
| **check**             | 执行 `setImmediate` 回调                    | 宏任务   |
| **close callbacks**   | 处理 `close` 事件回调                       | 宏任务   |
| **microtasks**        | `process.nextTick` 优先于 Promise 微任务    | 微任务   |

> 🔑 Node 特点：
>
> - `process.nextTick` 优先级最高，**会在当前操作完成后立即执行，不受事件循环阶段影响**
> - 微任务（Promise）在每个阶段结束后执行
> - 宏任务按阶段顺序执行