### 统计源码里面的 console.log 调用数量与调用路径

- 定义插件类

  定义一个JavaScript类；在类的apply方法中，监听webpack的compilation钩子来访问处理模块的源代码

- 监听适当的webpack钩子

  针对源代码的处理，选择监听compilation阶段的optimizeModule钩子；在这个阶段，模块的源代码可以被访问和修改

- 处理源代码

  处理每个模块的源代码，可以使用简单的正则表达式来识别console.log的调用

```js
class ConsoleLogStatsPlugin {
  constructor(options = {}) {
    this.options = {
      showAll: false, // 是否显示所有模块（包括没有 console.log 的）
      threshold: 0,  // 只显示超过此数量的模块
      ...options
    };
    this.stats = [];
  }
  apply(compiler) {
    compiler.hooks.compilation.tap("ConsoleLogStatsPlugin", (compilation) => {
      compilation.moduleTemplates.javascript.hooks.render.tap("ConsoleLogStatsPlugin", (moduleSource, module) => {
        if (!module.resource) return moduleSource;
        const source = moduleSource.source();
        const consoleLogMatches = source.match(/console\.(log|info|warn|error)\(/g) || [];
        const count = consoleLogMatches.length;
        if (count > this.options.threshold || this.options.showAll) {
          this.stats.push({
            path: module.resource,
            count,
            warnings: consoleLogMatches.filter(c => c.includes('.warn')).length,
            errors: consoleLogMatches.filter(c => c.includes('.error')).length,
            logs: consoleLogMatches.filter(c => c.includes('.log')).length,
            infos: consoleLogMatches.filter(c => c.includes('.info')).length
          });
        }
        return moduleSource;
      });
      // 在编译完成后输出统计结果
      compilation.hooks.afterProcessAssets.tap("ConsoleLogStatsPlugin", () => {
        if (this.stats.length > 0) {
          const total = this.stats.reduce((sum, item) => sum + item.count, 0);
          console.log(`\n📊 Console Log Statistics (${total} calls in ${this.stats.length} modules):`);
          this.stats
            .sort((a, b) => b.count - a.count)
            .forEach(item => {
              const relativePath = item.path.replace(process.cwd(), '');
              const typeStats = [
                item.logs > 0 ? `log: ${item.logs}` : '',
                item.infos > 0 ? `info: ${item.infos}` : '',
                item.warnings > 0 ? `warn: ${item.warnings}` : '',
                item.errors > 0 ? `error: ${item.errors}` : ''
              ].filter(Boolean).join(', ');
              console.log(`  ${relativePath}: ${item.count} calls (${typeStats})`);
            });
        } else {
          console.log('\n✅ No console.log calls found in any modules.');
        }
      });
    });
  }
}
module.exports = ConsoleLogStatsPlugin;
```



### 获取登录token的webpack插件

```js
import request from 'request';
import colors from 'colors';
import type { Compiler, Compilation, WebpackError, Stats } from 'webpack';
import type { InnerCallback } from 'tapable';
// 定义回调函数类型
type Callback<T> = (err?: null | WebpackError, result?: T) => void;
// 插件配置选项接口
interface Options {
  url: string;                    // 登录接口的 URL
  params: any;                   // 登录请求的参数（用户名、密码等）
  tokenKeyName: string | undefined;      // 响应数据中 token 字段的名称
  localStorageKey: string | undefined;   // 存储到 localStorage 的键名
  extraObj: {} | undefined;      // 额外需要合并进 localStorage 的对象
}
/**
 * LoginWebpackPlugin - 自动登录插件
 * 
 * 功能说明：
 * 1. 在 webpack 编译前自动调用登录接口
 * 2. 获取登录 token 或其他认证信息
 * 3. 将认证信息注入到 HTML 页面的 localStorage 中
 * 4. 主要用于开发环境，避免每次刷新都需要重新登录
 */
class LoginWebpackPlugin {
  // 插件配置选项，包含默认值
  private options: Options = {
    url: "",                      // 登录接口 URL
    extraObj: undefined,          // 额外对象
    params: {},                   // 登录参数
    tokenKeyName: undefined,      // token 字段名
    localStorageKey: undefined    // localStorage 键名
  };
  // 存储登录接口返回的数据
  private obj: null | {};
  /**
   * 构造函数 - 初始化插件配置
   * @param options 用户传入的配置选项
   */
  constructor(options: Options) {
    // 验证必需参数
    if (!options.url) {
      throw new Error('login-webpack-plugin: url is required');
    }
    if (!options.params) {
      throw new Error('login-webpack-plugin: params is required');
    }
    // 设置配置选项，提供默认值
    this.options.url = options.url;
    this.options.extraObj = options.extraObj;
    this.options.tokenKeyName = options?.tokenKeyName ?? 'token';        // 默认 token 字段名为 'token'
    this.options.localStorageKey = options?.localStorageKey ?? 'token';  // 默认 localStorage 键名为 'token'
    this.options.params = options.params;
    
    // 初始化登录数据为 null
    this.obj = null;
  }
  /**
   * 调用登录接口
   * @param cb 回调函数，用于通知 webpack 异步操作完成
   */
  callLoginApi(cb: (params: any) => void) {
    // 发送 HTTP POST 请求到登录接口
    request({
      url: this.options.url,        // 登录接口 URL
      method: 'POST',               // 使用 POST 方法
      headers: {
        'Content-type': 'application/json'  // 设置请求头为 JSON 格式
      },
      timeout: 5000,                // 设置超时时间为 5 秒
      json: this.options.params,    // 发送的登录参数（会自动序列化为 JSON）
    }, (err, response, body) => {
      // 处理请求错误
      if (err) {
        console.log(colors.red.underline(err));  // 红色下划线显示错误
        cb(err);
        return;
      }
      // 检查业务逻辑是否成功（假设 code === 0 表示成功）
      if (body.code === 0) {
        // 处理登录成功的情况
        if (this.options.extraObj) {
          // 如果有额外对象需要合并
          const originalObj = typeof body.data[this.options.tokenKeyName || 'token'] === 'string' 
            ? {
                // 如果 token 是字符串，创建对象包装它
                [this.options.tokenKeyName as string]: body.data[this.options.tokenKeyName || 'token']
              } 
            : body.data[this.options.tokenKeyName || 'token'];  // 如果 token 已经是对象，直接使用
          // 合并原始数据和额外对象
          this.obj = { ...originalObj, ...this.options.extraObj };
        } else {
          // 直接使用接口返回的 token 数据
          this.obj = body.data[this.options.tokenKeyName || 'token'];
        }
        cb(null);  // 通知 webpack 异步操作成功完成
      } else {
        // 登录失败，显示错误信息
        console.log(colors.red.bold(body?.msg ?? "登录接口错误"));
        cb(new Error(body?.msg ?? body?.message));
      }
    });
  }
  /**
   * apply 方法 - webpack 插件的核心方法
   * @param compiler webpack 编译器实例
   */
  apply(compiler: Compiler) {
    // 获取 HtmlWebpackPlugin，用于操作 HTML 模板
    const HtmlWebpackPlugin = require('html-webpack-plugin');
    /**
     * 1. beforeCompile 钩子 - 在编译开始前执行
     * 目的：确保在编译前完成登录，获取到认证信息
     */
    compiler.hooks.beforeCompile.tapAsync(
      'LoginWebpackPlugin', 
      (compilation: Compilation['params'], cb: InnerCallback<Error, void>) => {
        // 如果还没有登录数据，则调用登录接口；否则直接继续
        this.obj === null ? this.callLoginApi(cb) : cb();
      }
    );
    /**
     * 2. compilation 钩子 - 在每次编译时执行
     * 目的：注册 HTML 处理钩子，向 HTML 中注入登录信息
     */
    compiler.hooks.compilation.tap('LoginWebpackPlugin', (compilation: Compilation) => {
      // 获取 HtmlWebpackPlugin 的钩子
      const hooks = HtmlWebpackPlugin.getHooks(compilation);
      /**
       * afterTemplateExecution 钩子 - 在 HTML 模板执行后
       * 目的：向生成的 HTML 中注入 JavaScript 代码，将登录信息存储到 localStorage
       */
      HtmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tapAsync(
        'LoginWebpackPlugin', 
        (htmlPluginData: {html: any}, callback: Callback<{html: any}>) => {
          // 仅在开发环境下注入登录信息
          if (process.env.NODE_ENV === 'development') {
            
            // 根据数据类型生成不同的注入脚本
            if (typeof this.obj === 'object') {
              // 如果登录数据是对象类型
              htmlPluginData.html += `
              <script>
                // 将登录数据对象化
                const a = ${JSON.stringify(this.obj)};
                // 将整个对象存储到 localStorage
                window.localStorage.setItem(${JSON.stringify(this.options.localStorageKey)}, JSON.stringify(a));
              </script>`;
            } else if (typeof this.obj === 'string') {
              // 如果登录数据是字符串类型（通常是 token）
              htmlPluginData.html += `
              <script>
                // 获取字符串形式的 token
                const a = ${JSON.stringify(this.obj)};
                // 直接存储字符串到 localStorage
                window.localStorage.setItem(${JSON.stringify(this.options.localStorageKey)}, a);
              </script>`;
            }
          }
          // 调用回调，继续 webpack 编译流程
          callback(null, htmlPluginData);
        }
      );
    });
    /**
     * 3. done 钩子 - 编译完成后执行
     * 目的：输出插件执行结果，用于调试和确认
     */
    compiler.hooks.done.tapAsync(
      'LoginWebpackPlugin', 
      (compilation: Stats, cb: InnerCallback<Error, void>) => {
        // 以绿色粗体显示获取到的登录信息
        console.log(colors.green.bold(`\nlogin-webpack-plugin:${JSON.stringify(this.obj)}\n`));
        cb();  // 通知 webpack 异步操作完成
      }
    );
  }
}
// 导出插件类
export = LoginWebpackPlugin;
```

