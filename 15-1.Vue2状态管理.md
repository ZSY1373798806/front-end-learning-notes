## 一、Vuex 原理概述

Vuex 是 **专为 Vue.js 应用程序开发的状态管理模式**，核心目标是 **集中管理组件共享的状态**，并保证状态以一种可预测的方式发生变化。

### 1. 核心概念

- **State（状态）**：存放应用的共享数据。
- **Getter（计算属性）**：对 State 的衍生数据进行封装。
- **Mutation（变更）**：唯一允许修改 state 的方法，且必须是同步操作。
- **Action（动作）**：可以包含异步操作，然后通过 `commit` 调用 mutation。
- **Module（模块）**：用于拆分大型 store，支持模块化管理 state、mutation、action、getter。

------

### 2. Vuex 的原理机制

#### (1) 利用 Vue 的响应式系统

Vuex 的 `state` 通过 `Vue.observable()`（Vue 2）或者 Vue 3 的 `reactive()` 变为响应式对象。

- **效果**：当 state 变化时，依赖 state 的组件会自动更新。

示例：

```js
import Vue from 'vue'
const state = Vue.observable({ count: 0 })
const mutations = {
  increment() {
    state.count++
  }
}
export default { state, mutations }
```

这里的 `state.count` 变化会触发视图更新。

------

#### (2) Mutation 与 Action 的工作流程

1. **Mutation**
   - 只能同步操作
   - Vuex 通过 `commit('mutationName', payload)` 触发 mutation
   - mutation 内部直接修改 state，保证状态变更可追踪
2. **Action**
   - 可以异步操作
   - 内部通过 `context.commit` 调用 mutation 修改 state

> 核心思路：**mutation 用来修改 state，action 用来封装异步逻辑**。

------

#### (3) Store 的实现核心

Vuex 的 Store 大体结构如下：

```js
class Store {
  constructor(options) {
    // 响应式 state
    this._state = Vue.observable(options.state || {})
    this._mutations = options.mutations || {}
    this._actions = options.actions || {}
    this._getters = options.getters || {}
    
    // 绑定 commit 和 dispatch
    this.commit = this.commit.bind(this)
    this.dispatch = this.dispatch.bind(this)
  }

  commit(type, payload) {
    const mutation = this._mutations[type]
    if (mutation) mutation(this._state, payload)
  }

  dispatch(type, payload) {
    const action = this._actions[type]
    if (action) return action({ state: this._state, commit: this.commit }, payload)
  }

  get state() {
    return this._state
  }
}
```

#### (4) Getter 的实现

Getter 类似 Vue 的计算属性：

- 对 state 做加工处理
- 具有缓存功能（依赖 state，state 不变时不重新计算）

------

#### (5) 模块化

Vuex 支持模块 Module，每个模块有独立的 state、mutation、action、getter，通过 `namespaced: true` 可以实现命名空间。

- **作用**：大规模项目避免命名冲突，方便管理。

------

### 3. Vuex 响应式更新原理

1. Store 的 state 是响应式对象
2. Vue 组件通过 `mapState`、`mapGetters` 等访问 state
3. 当 mutation 修改 state 时，Vue 响应式系统检测到变化，自动触发视图更新

------

## 二、Vuex 相关面试题

### 面试题 1：Vuex 的作用是什么？

**答案要点**：

- 集中管理组件共享状态
- 状态变更可追踪、可预测
- 提高大型应用的可维护性

------

### 面试题 2：Vuex 的 state、getter、mutation、action 有何区别？

| 属性     | 用途                | 特点                          |
| -------- | ------------------- | ----------------------------- |
| state    | 存储共享状态        | 响应式                        |
| getter   | 对 state 的衍生计算 | 类似计算属性                  |
| mutation | 修改 state          | 同步操作，记录日志可追踪      |
| action   | 异步操作或复杂逻辑  | 内部通过 commit 调用 mutation |

------

### 面试题 3：为什么 mutation 必须同步？

- Vuex 依赖 devtools 追踪状态变更
- 异步操作会打乱记录顺序，导致调试困难
- 异步操作应放在 action 中

------

### 面试题 4：Vuex 的响应式是如何实现的？

- Vuex state 是 Vue 的响应式对象（`Vue.observable()` / `reactive()`）
- 组件依赖 state，state 改变触发组件更新

------

### 面试题 5：Vuex 中 action、mutation、getter 的调用方式？

```
store.commit('mutationName', payload) // 修改 state
store.dispatch('actionName', payload) // 调用 action
store.getters['getterName']            // 获取 getter
```

------

### 面试题 6：Vuex 模块化有什么用？如何实现？

- **作用**：分模块管理 state，提高可维护性
- **实现**：在 store 中配置 modules，并可使用 `namespaced: true`

```js
const moduleA = {
  namespaced: true,
  state: { count: 0 },
  mutations: { increment(state) { state.count++ } },
}

const store = new Vuex.Store({
  modules: { a: moduleA }
})
```

## 一、常用 Vuex 辅助函数

### 1. `mapState`

- **作用**：把 store 的 state 映射到组件的计算属性。
- **用法**：

```js
import { mapState } from 'vuex'

export default {
  computed: {
    ...mapState(['count']), // 直接映射 state.count
    ...mapState({
      doubleCount: state => state.count * 2 // 自定义映射
    })
  }
}
```

- **效果**：组件中可以直接用 `this.count` 或 `this.doubleCount`，不必写 `this.$store.state.count`。

------

### 2. `mapGetters`

- **作用**：把 store 的 getter 映射到组件的计算属性。
- **用法**：

```js
import { mapGetters } from 'vuex'

export default {
  computed: {
    ...mapGetters(['doneTodosCount']), // 映射 getter
    ...mapGetters({
      doneCount: 'doneTodosCount' // 自定义命名
    })
  }
}
```

- **效果**：组件可以直接用 `this.doneCount`，等价于 `this.$store.getters.doneTodosCount`。

------

### 3. `mapMutations`

- **作用**：把 store 的 mutation 映射到组件的方法中。
- **用法**：

```js
import { mapMutations } from 'vuex'

export default {
  methods: {
    ...mapMutations(['increment']), // 映射 mutation
    ...mapMutations({
      add: 'increment' // 自定义方法名
    })
  }
}
```

- **调用方式**：`this.increment(payload)` 或 `this.add(payload)`，内部会 `commit` mutation。

------

### 4. `mapActions`

- **作用**：把 store 的 action 映射到组件的方法中。
- **用法**：

```js
import { mapActions } from 'vuex'

export default {
  methods: {
    ...mapActions(['fetchData']),
    ...mapActions({
      getData: 'fetchData' // 自定义方法名
    })
  }
}
```

- **调用方式**：`this.fetchData(payload)`，内部会 `dispatch` action。

------

### 5. `mapModules` / `createNamespacedHelpers`（模块辅助）

- **作用**：在命名空间模块中使用 map 辅助函数。
- **用法**：

```js
import { createNamespacedHelpers } from 'vuex'

const { mapState, mapGetters, mapActions, mapMutations } = createNamespacedHelpers('moduleA')

export default {
  computed: {
    ...mapState(['count']),
    ...mapGetters(['doneCount'])
  },
  methods: {
    ...mapActions(['fetchData']),
    ...mapMutations(['increment'])
  }
}
```

- **效果**：避免在模块命名空间中重复写 `'moduleA/xxx'`。

------

### 二、总结对比

| 辅助函数                | 映射对象 | 类型         | 调用方式          |
| ----------------------- | -------- | ------------ | ----------------- |
| mapState                | state    | 计算属性     | this.xxx          |
| mapGetters              | getter   | 计算属性     | this.xxx          |
| mapMutations            | mutation | 方法         | this.xxx(payload) |
| mapActions              | action   | 方法         | this.xxx(payload) |
| createNamespacedHelpers | 模块专用 | 所有上述类型 | 自动带命名空间    |

------

💡 **注意点**：

- `mapState` 和 `mapGetters` 映射到 **计算属性**，不能写副作用逻辑。
- `mapMutations` 和 `mapActions` 映射到 **methods**，可接收参数并触发 commit/dispatch。
- 模块化时强烈建议使用 `createNamespacedHelpers` 避免手动拼接模块名。