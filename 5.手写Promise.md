```javascript
/**
 * 自定义Promise实现
 * 符合Promise/A+规范的基本实现
 */
class MyPromise {
  /**
   * 构造函数
   * @param {Function} executor - 执行器函数，接收resolve和reject两个参数
   */
  constructor(executor) {
    // 初始化实例属性
    this.initValue()
    // 绑定this指向，确保resolve和reject在任何情况下都指向正确的实例
    this.initBind()

    // 使用try...catch捕获executor执行时抛出的异常
    try {
      // 立即执行executor，传入resolve和reject方法
      executor(this.resolve, this.reject)
    } catch (error) {
      // 如果executor抛出异常，直接reject
      this.reject(error)
    }
  }

  /**
   * 初始化实例属性
   */
  initValue() {
    this.PromiseResult = null           // Promise的结果值
    this.PromiseState = 'pending'       // Promise的状态：pending/fulfilled/rejected
    this.onFulfilledCallbacks = []      // 保存成功状态的回调函数数组
    this.onRejectedCallbacks = []       // 保存失败状态的回调函数数组
  }

  /**
   * 绑定this指向
   * 防止resolve和reject方法在作为参数传递时丢失this指向
   */
  initBind() {
    this.resolve = this.resolve.bind(this)
    this.reject = this.reject.bind(this)
  }

  /**
   * resolve方法 - 将Promise状态改为fulfilled
   * @param {*} value - 成功的值
   */
  resolve(value) {
    // 状态只能从pending转换到其他状态，且不可逆转
    if (this.PromiseState !== 'pending') {
      return
    }
    
    // 更新状态和结果值
    this.PromiseState = 'fulfilled'
    this.PromiseResult = value

    // 异步执行所有保存的成功回调
    // 使用while循环确保按顺序执行所有回调
    while (this.onFulfilledCallbacks.length) {
      this.onFulfilledCallbacks.shift()(this.PromiseResult)
    }
  }

  /**
   * reject方法 - 将Promise状态改为rejected
   * @param {*} reason - 失败的原因
   */
  reject(reason) {
    // 状态只能从pending转换到其他状态，且不可逆转
    if (this.PromiseState !== 'pending') {
      return
    }
    
    // 更新状态和结果值
    this.PromiseState = 'rejected'
    this.PromiseResult = reason

    // 异步执行所有保存的失败回调
    while (this.onRejectedCallbacks.length) {
      this.onRejectedCallbacks.shift()(this.PromiseResult)
    }
  }

  /**
   * then方法 - 注册成功和失败的回调函数
   * @param {Function} onFulfilled - 成功时的回调函数
   * @param {Function} onRejected - 失败时的回调函数
   * @returns {MyPromise} 返回新的Promise实例，支持链式调用
   */
  then(onFulfilled, onRejected) {
    // 创建新的Promise实例用于链式调用
    const thenPromise = new MyPromise((resolve, reject) => {
      // 使用微任务确保异步执行（这里简化使用setTimeout）
      // 在真实实现中应该使用queueMicrotask或MutationObserver
      setTimeout(() => {
        /**
         * 统一处理Promise解析逻辑
         * @param {Function} callback - 要执行的回调函数
         */
        const resolvePromise = (callback) => {
          try {
            // 执行回调函数获取返回值
            const result = callback(this.PromiseResult)
            
            // 防止循环引用：then返回的Promise不能是自己
            if (result === thenPromise) {
              throw new Error('Chaining cycle detected for promise')
            }
            
            // 如果返回值是Promise实例
            if (result instanceof MyPromise) {
              // 等待返回的Promise状态确定，然后用其结果resolve/reject当前Promise
              result.then(resolve, reject)
            } else {
              // 如果返回值不是Promise，直接resolve
              resolve(result)
            }
          } catch (error) {
            // 如果回调执行过程中抛出异常，reject当前Promise
            reject(error)
          }
        }

        // 参数标准化：确保onFulfilled和onRejected是函数
        // 如果不是函数，则提供默认的透传函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }

        // 根据当前Promise的状态执行相应的逻辑
        if (this.PromiseState === 'fulfilled') {
          // 状态已确定为成功，直接执行成功回调
          resolvePromise(onFulfilled)
        } else if (this.PromiseState === 'rejected') {
          // 状态已确定为失败，直接执行失败回调
          resolvePromise(onRejected)
        } else if (this.PromiseState === 'pending') {
          // 状态未确定，将回调保存到相应数组中，等待状态改变时执行
          this.onFulfilledCallbacks.push(() => resolvePromise(onFulfilled))
          this.onRejectedCallbacks.push(() => resolvePromise(onRejected))
        }
      }, 0)
    })

    return thenPromise
  }

  /**
   * catch方法 - 专门处理rejected状态
   * @param {Function} onRejected - 失败时的回调函数
   * @returns {MyPromise} 返回新的Promise实例
   */
  catch(onRejected) {
    return this.then(null, onRejected)
  }

  /**
   * finally方法 - 无论Promise状态如何都会执行的回调
   * @param {Function} onFinally - 最终执行的回调函数
   * @returns {MyPromise} 返回新的Promise实例
   */
  finally(onFinally) {
    return this.then(
      value => MyPromise.resolve(onFinally()).then(() => value),
      reason => MyPromise.resolve(onFinally()).then(() => { throw reason })
    )
  }

  /**
   * Promise.resolve静态方法
   * @param {*} value - 要解析的值
   * @returns {MyPromise} 返回resolved状态的Promise
   */
  static resolve(value) {
    // 如果传入的是Promise实例，直接返回
    if (value instanceof MyPromise) {
      return value
    }
    
    // 否则创建新的resolved状态的Promise
    return new MyPromise(resolve => resolve(value))
  }

  /**
   * Promise.reject静态方法
   * @param {*} reason - 拒绝的原因
   * @returns {MyPromise} 返回rejected状态的Promise
   */
  static reject(reason) {
    return new MyPromise((resolve, reject) => reject(reason))
  }

  /**
   * Promise.all静态方法
   * 接收一个Promise数组，数组中如有非Promise项，则此项当做成功
   * 如果所有Promise都成功，则返回成功结果数组
   * 如果有一个Promise失败，则返回这个失败结果
   * @param {Array} promises - Promise数组
   * @returns {MyPromise} 返回新的Promise实例
   */
  static all(promises) {
    return new MyPromise((resolve, reject) => {
      const result = []              // 存储结果的数组
      let completedCount = 0         // 已完成的Promise数量计数器
      
      // 处理空数组的情况
      if (promises.length === 0) {
        resolve(result)
        return
      }

      /**
       * 添加单个Promise的结果
       * @param {number} index - 结果在数组中的索引
       * @param {*} value - Promise的结果值
       */
      const addResult = (index, value) => {
        result[index] = value
        completedCount++
        // 当所有Promise都完成时，resolve整个结果数组
        if (completedCount === promises.length) {
          resolve(result)
        }
      }

      // 遍历处理每个Promise
      promises.forEach((promise, index) => {
        if (promise instanceof MyPromise) {
          // 如果是Promise实例，等待其完成
          promise.then(
            res => addResult(index, res),  // 成功时添加结果
            err => reject(err)             // 失败时立即reject整个all
          )
        } else {
          // 如果不是Promise，直接当作成功值处理
          addResult(index, promise)
        }
      })
    })
  }

  /**
   * Promise.race静态方法
   * 接收一个Promise数组，数组中如有非Promise项，则此项当做成功
   * 哪个Promise最快得到结果，就返回那个结果，无论成功失败
   * @param {Array} promises - Promise数组
   * @returns {MyPromise} 返回新的Promise实例
   */
  static race(promises) {
    return new MyPromise((resolve, reject) => {
      // 处理空数组的情况
      if (promises.length === 0) {
        return // race对于空数组会永远pending
      }

      // 遍历所有Promise
      promises.forEach(promise => {
        if (promise instanceof MyPromise) {
          // Promise实例：第一个settle的Promise决定race的结果
          promise.then(resolve, reject)
        } else {
          // 非Promise值：立即resolve
          resolve(promise)
        }
      })
    })
  }

  /**
   * Promise.allSettled静态方法
   * 接收一个Promise数组，数组中如有非Promise项，则此项当做成功
   * 把每一个Promise的结果，集合成数组，返回
   * @param {Array} promises - Promise数组
   * @returns {MyPromise} 返回新的Promise实例
   */
  static allSettled(promises) {
    return new MyPromise((resolve, reject) => {
      const result = []              // 存储结果的数组
      let completedCount = 0         // 已完成的Promise数量计数器
      
      // 处理空数组的情况
      if (promises.length === 0) {
        resolve(result)
        return
      }

      /**
       * 添加Promise的settle结果
       * @param {number} index - 结果在数组中的索引
       * @param {string} status - Promise的最终状态 'fulfilled' | 'rejected'
       * @param {*} value - Promise的结果值或失败原因
       */
      const addSettledResult = (index, status, value) => {
        const settledResult = { status }
        
        // 根据状态设置相应的属性名
        if (status === 'fulfilled') {
          settledResult.value = value
        } else {
          settledResult.reason = value
        }
        
        result[index] = settledResult
        completedCount++
        
        // 当所有Promise都settle时，resolve结果数组
        if (completedCount === promises.length) {
          resolve(result)
        }
      }

      // 遍历处理每个Promise
      promises.forEach((promise, index) => {
        if (promise instanceof MyPromise) {
          promise.then(
            res => addSettledResult(index, 'fulfilled', res),
            err => addSettledResult(index, 'rejected', err)
          )
        } else {
          // 非Promise值当作已fulfilled的Promise处理
          addSettledResult(index, 'fulfilled', promise)
        }
      })
    })
  }

  /**
   * Promise.any静态方法
   * 接收一个Promise数组，数组中如有非Promise项，则此项当做成功
   * 如果有一个Promise成功，则返回这个成功结果
   * 如果所有Promise都失败，则报错
   * @param {Array} promises - Promise数组
   * @returns {MyPromise} 返回新的Promise实例
   */
  static any(promises) {
    return new MyPromise((resolve, reject) => {
      let rejectedCount = 0          // 已失败的Promise数量计数器
      const errors = []              // 存储所有错误的数组
      
      // 处理空数组的情况
      if (promises.length === 0) {
        reject(new AggregateError([], 'All promises were rejected'))
        return
      }

      // 遍历处理每个Promise
      promises.forEach((promise, index) => {
        if (promise instanceof MyPromise) {
          promise.then(
            res => resolve(res),       // 任何一个成功就立即resolve
            err => {
              errors[index] = err
              rejectedCount++
              // 如果所有Promise都失败，则reject并抛出AggregateError
              if (rejectedCount === promises.length) {
                reject(new AggregateError(errors, 'All promises were rejected'))
              }
            }
          )
        } else {
          // 非Promise值：立即resolve
          resolve(promise)
        }
      })
    })
  }
}

// 使用示例和测试
console.log('=== MyPromise 使用示例 ===')

// 创建测试用的Promise函数
const createPromise = (value, delay = 1000, shouldReject = false) => {
  return new MyPromise((resolve, reject) => {
    setTimeout(() => {
      if (shouldReject) {
        reject(`Error: ${value}`)
      } else {
        resolve(value)
      }
    }, delay)
  })
}

// 测试基本功能
console.log('1. 测试基本then链式调用:')
createPromise('Hello', 100)
  .then(res => {
    console.log('第一个then:', res)
    return res + ' World'
  })
  .then(res => {
    console.log('第二个then:', res)
    return createPromise('!', 100)
  })
  .then(res => {
    console.log('第三个then:', res)
  })
  .catch(err => {
    console.error('catch捕获错误:', err)
  })

// 测试Promise.all
console.log('\n2. 测试Promise.all:')
const p1 = createPromise('Promise1', 300)
const p2 = createPromise('Promise2', 200)
const p3 = createPromise('Promise3', 100)

MyPromise.all([p1, p2, p3])
  .then(results => {
    console.log('Promise.all结果:', results)
  })
  .catch(err => {
    console.error('Promise.all错误:', err)
  })

// 测试Promise.race
console.log('\n3. 测试Promise.race:')
const r1 = createPromise('Fast', 100)
const r2 = createPromise('Slow', 500)

MyPromise.race([r1, r2])
  .then(result => {
    console.log('Promise.race结果:', result)
  })

// 测试Promise.any
console.log('\n4. 测试Promise.any:')
const a1 = createPromise('Success1', 200)
const a2 = createPromise('Error2', 100, true)
const a3 = createPromise('Success3', 300)

MyPromise.any([a1, a2, a3])
  .then(result => {
    console.log('Promise.any结果:', result)
  })
  .catch(err => {
    console.error('Promise.any错误:', err)
  })

// 测试Promise.allSettled
console.log('\n5. 测试Promise.allSettled:')
const s1 = createPromise('Success', 100)
const s2 = createPromise('Failure', 200, true)
const s3 = 'Direct Value'

MyPromise.allSettled([s1, s2, s3])
  .then(results => {
    console.log('Promise.allSettled结果:', results)
  })

// 导出MyPromise类（在Node.js环境中使用）
// module.exports = MyPromise
```

