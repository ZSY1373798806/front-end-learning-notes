# 面向对象和原型

## new操作符

## 1. `new` 操作符核心流程

1. **创建实例对象**

   ```
   const obj = Object.create(constructor.prototype)
   ```

2. **绑定构造函数的 `this` 并执行**

   ```
   const result = constructor.apply(obj, args)
   ```

3. **返回对象**

   - 如果构造函数显式返回对象，则返回它
   - 否则返回新建的 `obj`

> ⚠️ 注意：原型链是通过 `obj.__proto__ = constructor.prototype` 建立的，这决定了实例可以访问构造函数原型上的方法。

### 模拟new方法的实现

```javascript
function newFun(...args) {
  // 取出args的第一个参数，即目标的构造函数
  const constructor = args.shift() // [Function: Person]（Person为目标函数名称）
  // 创建一个空对象obj，且继承构造函数的prototype属性
  const obj = Object.create(constructor.prototype) // obj.__proto__ === constructor.prototype
  // 将构造函数内部this指向obj，并执行构造函数，返回结果
  const result = constructor.apply(obj, args)
	// 判断返回结果，如果为对象类型，则返回result；否则返回obj
  return (typeof result === 'object' && result !== null) ? result : obj
}
```

- 构造函数没有显式返回值，result为undefined

```javascript
function Person(name) {
  this.name = name
}
const person = new newFun(Person, 'zhangsan')
console.log(person)
3
// Person { name: 'zhangsan' }
```

- 构造函数存在显式返回值，且返回值result为对象类型{1: '1'}；则newFun返回result

```javascript
function Person(name) {
  this.name = name
  return {1: '1'}
}
const person = new newFun(Person, 'zhangsan')
console.log(person)

// { '1': '1' }
```



## 如何优雅的实现继承

### ES5相对可用的继承方案

- 一、继承方式优化总结

| 继承方式         | 核心实现                         | 优势                                            | 缺陷                                                         | 适用场景                     |
| ---------------- | -------------------------------- | ----------------------------------------------- | ------------------------------------------------------------ | ---------------------------- |
| 原型链继承       | `Child.prototype = new Parent()` | 同时继承实例属性和原型方法                      | 1. 父类引用类型属性被所有子类实例共享 2. 父类构造函数参数无法灵活传递 3.若 `Parent` 的实例属性是引用类型（如数组、对象），修改一个 `Child` 实例的该属性会影响所有 `Child` 实例 | 简单场景，无引用类型属性时   |
| 构造函数继承     | `Parent.call(this, args)`        | 1. 实例属性独立（无共享问题） 2. 可灵活传递参数 | 无法继承父类原型方法                                         | 仅需继承属性，无需继承方法时 |
| **组合继承**     | 结合上述两种方式                 | 1. 继承原型方法 + 独立实例属性 2. 支持参数传递  | 父类构造函数被调用两次（性能损耗）                           | 大多数场景的基础解决方案     |
| **寄生组合继承** | 优化原型赋值步骤                 | 保留组合继承优势，且父类构造函数只调用一次      | 实现稍复杂                                                   | 追求性能优化的场景           |

- 二、推荐实现：寄生组合继承（最优方案）

#### 核心思路：

1. **用构造函数继承**：通过 `Parent.call(this, ...args)` 继承实例属性，确保独立性和参数传递。

2. **用原型继承**：通过 `Object.create(Parent.prototype)` 继承原型方法，避免重复调用父类构造函数。

3. **修复构造函数指向**：保证 `child.constructor` 正确指向 `Child`。

   ```js
   function Parent(name) {
     // 父类实例属性
     this.name = name;
     this.hobbies = ['reading']; // 引用类型属性
   }
   // 父类原型方法（需要被子类继承）
   Parent.prototype.sayHi = function() {
     console.log(`Hi, I'm ${this.name}`);
   };
   // 子类构造函数（用构造函数继承实例属性）
   function Child(name, age) {
     // 调用父类构造函数，传递参数，确保每个实例有独立属性
     Parent.call(this, name); 
     // 子类自身属性
     this.age = age;
   }
   // 原型继承：继承父类原型方法（关键优化）
   // 用 Object.create 避免 new Parent() 导致的父类构造函数二次调用
   Child.prototype = Object.create(Parent.prototype);
   // 修复构造函数指向（否则 child.constructor 会指向 Parent）
   Child.prototype.constructor = Child;
   // 子类新增原型方法
   Child.prototype.sayAge = function() {
     console.log(`I'm ${this.age} years old`);
   };
   
   // 测试效果
   const child1 = new Child('Alice', 12);
   const child2 = new Child('Bob', 14);
   
   // 继承父类实例属性
   console.log(child1.name); // "Alice"
   console.log(child2.name); // "Bob"
   
   // 继承父类原型方法
   child1.sayHi(); // "Hi, I'm Alice"
   
   // 子类自身方法
   child2.sayAge(); // "I'm 14 years old"
   
   // 引用类型属性独立（无共享问题）
   child1.hobbies.push('coding');
   console.log(child1.hobbies); // ['reading', 'coding']
   console.log(child2.hobbies); // ['reading']（不受影响）
   
   // 原型链关系正确
   console.log(child1 instanceof Child); // true
   console.log(child1 instanceof Parent); // true
   console.log(child1.constructor === Child); // true（构造函数指向正确）
   ```

- 三、优化点解析

1. **解决共享引用类型问题**：
   通过 `Parent.call(this)` 为每个子类实例单独创建父类的引用类型属性（如 `hobbies`），避免实例间相互影响。
2. **高效继承原型方法**：
   使用 `Object.create(Parent.prototype)` 代替 `new Parent()` 赋值原型，避免父类构造函数被二次调用（一次在 `Child` 内，一次在原型赋值时），减少性能损耗。
3. **保持原型链完整性**：
   修复 `Child.prototype.constructor = Child`，确保 `instanceof` 判断和构造函数指向正确，符合 JavaScript 原型链规范。
4. **支持灵活传参**：
   子类构造函数可接收任意参数，并通过 `Parent.call(this, ...args)` 传递给父类，适配各种初始化需求。

#### 较为完整的继承实现

```javascript
function inherit(Child, Parent) {
  // 继承原型上的属性
  Child.prototype = Object.create(Parent.prototype)
  // 修复constructor
  Child.prototype.constructor = Child
  // 存储超类
  Child.super = Parent
  // 静态属性继承
  if (Object.setPrototypeOf) {
    // setPrototypeOf es6
    // 相当于Child.__proto__ = Parent
    Object.setPrototypeOf(Child, Parent)
  } else if (Child.__proto__) {
    // __proto__ es6引入，但是部分浏览器已支持
    Child.__proto__ = Parent
  } else {
    // 兼容IE10等陈旧浏览器
    // 将Parent上的静态属性和方法拷贝一份到Child上，不会覆盖Child的方法
    for (let k in Parent) {
      if(Parent.hasOwnProperty(k) && !(k in Child)) {
        Child[k] = Parent[k]
      }
    }
  }
}
```

### ES6继承方案

#### Date日期对象继承

```javascript
class DateConstructor extends Date {
  constructor() {
    super()
    this.foo = 'bar'
  }
  getMyTime() {
    return this.getTime()
  }
}
const date = new DateConstructor()
console.log(date.getMyTime())

// 1617802303136
```

#### ES6继承剖析

​		源代码

```javascript
class Person {
  constructor() {
    // 包含一个实例属性
    this.type = 'person'
  }
}
// 继承Person类
// 由此Student类继承了type为person这个属性
class Student extends Person {
  constructor() {
    super()
  }
} 
const stu = new Student()
console.log(stu)

// Student { type: 'person' }

// 原型链的关系
stu instanceof Student // true
stu instanceof Person // true
stu.hasOwnProperty('type') // true
```

​		通过babel，将源代码编译成es5代码

```javascript
'use strict'
var Person = function Person() {
  // 使用检测
  _classCallCheck(this, Person)
  this.type = 'person'
}

// 自执行函数，接受一个参数_Person（即要继承的父类），返回一个构造函数Student
var Student = (function (_Person) {
  // 实现对父类原型链属性的继承
  // 实现原理可归结为：
  // Student.prototype = Object.create(Person.prototype)
  // Object.setPrototypeOf(Student, Person)
  // 也可归结为：Person.call(this)
  _inherits(Student, _Person)
  function Student() {
    // 使用检测
    _classCallCheck(this, Student)
    // 返回父类构造函数
    return _possibleConstructorReturn(
      this,
      (Student.__proto__ || Object.getPrototypeOf(Student)).call(this)
    )
  }

  return Student
})(Person)

var stu = new Student()
```

​		相关函数

```javascript
function _possibleConstructorReturn(self, call) {
  // 判断this是否存在（执行super()）
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
  }
  return call && (typeof call === 'object' || typeof call === 'function') ? call : self
}

// 实现子类对父类原型链属性的继承
function _inherits(subClass, superClass) {
  // 父类需要为函数类型，否则会报错
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass)
  }
  // 继承原型上的属性, 且修复子类的constructor，相当于：
  // subClass.prototype = Object.create(superClass.prototype)
  // subClass.prototype.constructor = subClass
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true,
    },
  })
  if (superClass)
    // 判断Object.setPrototypeOf是否存在，如果不存在则使用__proto__的方式继承 （满足兼容性）
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass)
}

function _classCallCheck(instance, Constructor) {
  // 判断当前this是否为构造函数实例
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function')
  }
}
```



## 面向对象之jQuery的实现

### 开篇案例

```javascript
const divNodes = $('div')
```

​		 通过该表达式可得到一个数组divNodes，又可以通过

```javascript
divNodes.addClass('className')
```

​		给div添加对应的class名称

问题：

1. 数组上的addClass方法是如何实现的？

  2. $('div')、\$.ajax()是如何实现的？

     > 由此可知： $是一个对象，且有ajax的静态方法;

     类似于：

     ```javascript
     function $() {}
     $.ajax = function(){}
     ```

### jQuery源码

​		具体内容有删减和改动

```javascript
(function (global, factory) {
  'use strict';
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) :
      function (w) {
        if (!w.document) {
          throw new Error('jQuery require a window with document')
        }
        return factory(global)
      }
  } else {
    factory(global)
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var jQuery = function (selector, context) {
    return jQuery.fn.init(selector, context)
  }
  jQuery.fn = jQuery.prototype = {
    constructor: jQuery
  }
  jQuery.extend = jQuery.fn.extend = function () {
    //target 被扩展的对象
    //length 参数的数量
    //deep 是否深度操作
    var options, name, src, copy, copyIsArray, clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length
    deep = false
    // target为第一个参数，如果第一个参数是Boolean类型，则把target复制给deep
    // deep为true表示进行深层面的复制，否则只进行第一层的扩展
    // 然后把第二个参数赋值给target
    if (typeof target === 'boolean') {
      deep = target
      target = arguments[1] || {}
      // i=2，跳过前面两个参数
      i++
    }
    // target既不是对象也不是函数，则设为空对象
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {}
    }
    // 如果只有一个参数，则把jQuery对象赋值给target，即扩展到jQuery对象上
    if (length === i) {
      target = this
      // i减1，指向被扩展对象
      --i
    }
    // 遍历需要被扩展到target上的参数
    for (; i < length; i++) {
      // 处理第i个被扩展的对象（去除deep和target之外的对象）
      if ((options = arguments[i]) !== null) {
        // 遍历对象的所有可遍历属性
        for (name in options) {
          src = target[name]
          copy = options[name]
          // 防止闭环，例如 extend(true, target, {'target':target})
          if (target === copy) {
            continue
          }
          // 深度拷贝，实现递归合并；（判断copy是否为纯对象或数组）
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false
              clone = src && jQuery.isArray(src) ? src : []
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {}
            }
            // 递归调用，深度拷贝
            target[name] = jQuery.extend(deep, clone, copy)
          } else if (copy !== undefined) {
            // 浅拷贝
            target[name] = copy
          }
        }
      }
    }
    return target
  }
  jQuery.extend({
    ajax: function (url, options) { }
  })
  var init = jQuery.fn.init = function (selector, context, root) { }
  jQuery.fn.extend({
    addClass: function (value) { },
    removeClass: function (value) { },
    toggleClass: function (value, stareVal) { },
    hasClass: function (selector) { },
    // ...
  })
  if (typeof noGlobal === "undefined") {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery
})
```

> 顺着源码分析，当调用$('div')时，返回的结果是dom；
>
> dom.\__proto__指向$.fn，\$.fn是包含了多种方法的对象集合；
>
> 因此dom可以在原型链上找到addClass等方法。

> ajax是直接挂载在构造函数$上，是一个静态属性方法。

​		翻译成ES6 class，代码结构大致如下：

```javascript
class ${
  static ajax() {
    ...
  }
	constructor(selector, context) {
    this.selector = selector
    this.context = selector
    ...
  }
  addClass(value) {
    ...
  }
}
```

