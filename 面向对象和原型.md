# 面向对象和原型

## new操作符

### 执行过程

1. 创建一个空对象（obj），这个对象将会作为执行new 构造函数()之后，返回的对象实例；

   ​		const constructor = args.shift()

2. 将创建的空对象（obj）的原型（__ proto__），指向构造函数的prototype属性；

   ​		const obj.__ proto__ = Object.create(constructor.prototype)

3. 将构造函数内部的this指向这个空对象（obj），并执行构造函数逻辑；

   ​		const result = constructor.apply(obj, args)

4. 根据构造函数执行逻辑，返回第一部创建的对象或者构造函数的显式返回值。

   ​		return (typeof result  == = 'obj' && result !== null) ? result : obj

### 模拟new方法的实现

```javascript
function newFun(...args) {
  // 取出args的第一个参数，即目标的构造函数
  const constructor = args.shift() // [Function: Person]（Person为目标函数名称）
  // 创建一个空对象obj，且继承构造函数的prototype属性
  const obj = Object.create(constructor.prototype) // obj.__proto__ === constructor.prototype
  // 将构造函数内部this指向obj，并执行构造函数，返回结果
  const result = constructor.apply(obj, args)
	// 判断返回结果，如果为对象类型，则返回result；否则返回obj
  return (typeof result === 'object' && result !== null) ? result : obj
}
```

​		构造函数没有显式返回值，result为undefined

```javascript
function Person(name) {
  this.name = name
}
const person = new newFun(Person, 'zhangsan')
console.log(person)
3
// Person { name: 'zhangsan' }
```

​		构造函数存在显式返回值，且返回值result为对象类型{1: '1'}；则newFun返回result

```javascript
function Person(name) {
  this.name = name
  return {1: '1'}
}
const person = new newFun(Person, 'zhangsan')
console.log(person)

// { '1': '1' }
```



## 如何优雅的实现继承

### ES5相对可用的继承方案

- 原型链继承


```javascript
Child.prototype = new Parent()
```

> 不同的Child实例的__ proto__会引用同一个Parent实例

- 构造函数继承 

```javascript
function Child(args) {
	Parent.call(this, args)
}
```

> 只是实现了实例属性继承，Parent的原型方法在Child实例中并不可用

- 组合继承（原型链+构造函数）

```javascript
function Child(args1, args2) {
  this.args2 = args2
  Parent.call(this.args1)
}
Child.prototype = new Parent()
Child.prototype.constructor = Child
```

> Child实例会存在Parent的实例属性；
>
> 同时，Child.\__proto__  也会存在同样的Parent的实例属性，且所有的Child实例的__ proto__指向同一个内存地址；
>
> 没有实现对静态属性的继承。

#### 较为完整的继承实现

```javascript
function inherit(Child, Parent) {
  // 继承原型上的属性
  Child.prototype = Object.create(Parent.prototype)
  // 修复constructor
  Child.prototype.constructor = Child
  // 存储超类
  Child.super = Parent
  // 静态属性继承
  if (Object.setPrototypeOf) {
    // setPrototypeOf es6
    // 相当于Child.__proto__ = Parent
    Object.setPrototypeOf(Child, Parent)
  } else if (Child.__proto__) {
    // __proto__ es6引入，但是部分浏览器已支持
    Child.__proto__ = Parent
  } else {
    // 兼容IE10等陈旧浏览器
    // 将Parent上的静态属性和方法拷贝一份到Child上，不会覆盖Child的方法
    for (let k in Parent) {
      if(Parent.hasOwnProperty(k) && !(k in Child)) {
        Child[k] = Parent[k]
      }
    }
  }
}
```

#### Date日期对象继承

​		javascript的日期对象只能通过javascript Date作为构造函数来实例化得到

```javascript

```

### ES6继承方案

#### Date日期对象继承

```javascript
class DateConstructor extends Date {
  constructor() {
    super()
    this.foo = 'bar'
  }
  getMyTime() {
    return this.getTime()
  }
}
const date = new DateConstructor()
console.log(date.getMyTime())

// 1617802303136
```

#### ES6继承剖析

​		源代码

```javascript
class Person {
  constructor() {
    // 包含一个实例属性
    this.type = 'person'
  }
}
// 继承Person类
// 由此Student类继承了type为person这个属性
class Student extends Person {
  constructor() {
    super()
  }
} 
const stu = new Student()
console.log(stu)

// Student { type: 'person' }

// 原型链的关系
stu instanceof Student // true
stu instanceof Person // true
stu.hasOwnProperty('type') // true
```

​		通过babel，将源代码编译成es5代码

```javascript
'use strict'
var Person = function Person() {
  // 使用检测
  _classCallCheck(this, Person)
  this.type = 'person'
}

// 自执行函数，接受一个参数_Person（即要继承的父类），返回一个构造函数Student
var Student = (function (_Person) {
  // 实现对父类原型链属性的继承
  // 实现原理可归结为：
  // Student.prototype = Object.create(Person.prototype)
  // Object.setPrototypeOf(Student, Person)
  // 也可归结为：Person.call(this)
  _inherits(Student, _Person)
  function Student() {
    // 使用检测
    _classCallCheck(this, Student)
    // 返回父类构造函数
    return _possibleConstructorReturn(
      this,
      (Student.__proto__ || Object.getPrototypeOf(Student)).call(this)
    )
  }

  return Student
})(Person)

var stu = new Student()
```

​		相关函数

```javascript
function _possibleConstructorReturn(self, call) {
  // 判断this是否存在（执行super()）
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
  }
  return call && (typeof call === 'object' || typeof call === 'function') ? call : self
}

// 实现子类对父类原型链属性的继承
function _inherits(subClass, superClass) {
  // 父类需要为函数类型，否则会报错
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass)
  }
  // 继承原型上的属性, 且修复子类的constructor，相当于：
  // subClass.prototype = Object.create(superClass.prototype)
  // subClass.prototype.constructor = subClass
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true,
    },
  })
  if (superClass)
    // 判断Object.setPrototypeOf是否存在，如果不存在则使用__proto__的方式继承 （满足兼容性）
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass)
}

function _classCallCheck(instance, Constructor) {
  // 判断当前this是否为构造函数实例
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function')
  }
}
```



## 面向对象之jQuery的实现

### 开篇案例

```javascript
const divNodes = $('div')
```

​		 通过该表达式可得到一个数组divNodes，又可以通过

```javascript
divNodes.addClass('className')
```

​		给div添加对应的class名称

问题：

1. 数组上的addClass方法是如何实现的？

  2. $('div')、\$.ajax()是如何实现的？

     > 由此可知： $是一个对象，且有ajax的静态方法;

     类似于：

     ```javascript
     function $() {}
     $.ajax = function(){}
     ```

### jQuery源码

​		具体内容有删减和改动

```javascript
(function (global, factory) {
  'use strict';
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) :
      function (w) {
        if (!w.document) {
          throw new Error('jQuery require a window with document')
        }
        return factory(global)
      }
  } else {
    factory(global)
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var jQuery = function (selector, context) {
    return jQuery.fn.init(selector, context)
  }
  jQuery.fn = jQuery.prototype = {
    constructor: jQuery
  }
  jQuery.extend = jQuery.fn.extend = function () {
    //target 被扩展的对象
    //length 参数的数量
    //deep 是否深度操作
    var options, name, src, copy, copyIsArray, clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length
    deep = false
    // target为第一个参数，如果第一个参数是Boolean类型，则把target复制给deep
    // deep为true表示进行深层面的复制，否则只进行第一层的扩展
    // 然后把第二个参数赋值给target
    if (typeof target === 'boolean') {
      deep = target
      target = arguments[1] || {}
      // i=2，跳过前面两个参数
      i++
    }
    // target既不是对象也不是函数，则设为空对象
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {}
    }
    // 如果只有一个参数，则把jQuery对象赋值给target，即扩展到jQuery对象上
    if (length === i) {
      target = this
      // i减1，指向被扩展对象
      --i
    }
    // 遍历需要被扩展到target上的参数
    for (; i < length; i++) {
      // 处理第i个被扩展的对象（去除deep和target之外的对象）
      if ((options = arguments[i]) !== null) {
        // 遍历对象的所有可遍历属性
        for (name in options) {
          src = target[name]
          copy = options[name]
          // 防止闭环，例如 extend(true, target, {'target':target})
          if (target === copy) {
            continue
          }
          // 深度拷贝，实现递归合并；（判断copy是否为纯对象或数组）
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false
              clone = src && jQuery.isArray(src) ? src : []
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {}
            }
            // 递归调用，深度拷贝
            target[name] = jQuery.extend(deep, clone, copy)
          } else if (copy !== undefined) {
            // 浅拷贝
            target[name] = copy
          }
        }
      }
    }
    return target
  }
  jQuery.extend({
    ajax: function (url, options) { }
  })
  var init = jQuery.fn.init = function (selector, context, root) { }
  jQuery.fn.extend({
    addClass: function (value) { },
    removeClass: function (value) { },
    toggleClass: function (value, stareVal) { },
    hasClass: function (selector) { },
    // ...
  })
  if (typeof noGlobal === "undefined") {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery
})
```

> 顺着源码分析，当调用$('div')时，返回的结果是dom；
>
> dom.\__proto__指向$.fn，\$.fn是包含了多种方法的对象集合；
>
> 因此dom可以在原型链上找到addClass等方法。

> ajax是直接挂载在构造函数$上，是一个静态属性方法。

​		翻译成ES6 class，代码结构大致如下：

```javascript
class ${
  static ajax() {
    ...
  }
	constructor(selector, context) {
    this.selector = selector
    this.context = selector
    ...
  }
  addClass(value) {
    ...
  }
}
```

