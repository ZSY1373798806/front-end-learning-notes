### single-spa

- ## 1️⃣ 基座应用（Host / Container）

  ### 核心 API

  ```
  registerApplication(name, loadApp, activeWhen, customProps)
  start()
  ```

  - **name**：子应用唯一标识
  - **loadApp**：返回 Promise，解析出子应用生命周期 `{ bootstrap, mount, unmount }`
  - **activeWhen**：路由匹配函数，返回 true 激活子应用
  - **customProps**：传递给子应用的自定义对象
  - **start()**：激活 single-spa，开始加载子应用

​	**资源加载方式**

- 动态创建 `<script>` 标签加载子应用资源（需按顺序加载公共依赖与业务代码）

  ```js
  async function loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  ```

## 2️⃣ 子应用适配规范

### 生命周期必须导出

```js
export const bootstrap = async props => { ... }
export const mount = async props => { ... }
export const unmount = async props => { ... }
```

| 生命周期      | 作用                                               |
| ------------- | -------------------------------------------------- |
| **bootstrap** | 初始化，只执行一次，加载资源、初始化全局变量       |
| **mount**     | 挂载应用，每次进入路由时执行（渲染到 DOM）         |
| **unmount**   | 卸载应用，每次离开路由时执行（销毁组件、解绑事件） |
| **update**    | （可选）用于应用间通信时的更新                     |

### 应用加载流程

1. 监听路由变化（history API / hash）。
2. 匹配激活规则（activeWhen）。
3. 触发卸载上一个子应用（unmount）。
4. 加载新子应用的 bundle（SystemJS / script 标签）。
5. 调用 bootstrap → mount 渲染。

**核心原理？**

- 路由劫持 + 应用生命周期管理（bootstrap / mount / unmount）。

### Webpack 配置关键点

- **输出 UMD 模块**，挂载到 `window` 上

```js
output: {
  library: 'singleVue',
  libraryTarget: 'umd'
}
```

- **删除 splitChunks**，避免生成 `chunk-vendor.js`，保证基座直接 `System.import` 子应用
- **动态 publicPath**

```js
if (window.singleSpaNavigate) {
  __webpack_public_path__ = 'http://localhost:10000/';
}
```

### 路由隔离

- 子应用路由需设置 `base: '/appxxx'`
- 防止与基座冲突

## 3️⃣ 核心 webpack 变量

| 变量                       | 功能                                                         | 使用场景               |
| -------------------------- | ------------------------------------------------------------ | ---------------------- |
| `__webpack_public_path__`  | 动态设置资源基础路径（优先级最高：覆盖webpack.config.js中publicPath配置） | 多环境部署、CDN切换    |
| `__webpack_init_sharing__` | 初始化模块共享作用域                                         | 模块联邦加载远程模块前 |
| `__webpack_share_scopes__` | 存储共享模块信息                                             | 版本管理、单例依赖     |
| `__webpack_require__.l`    | 动态加载 JS                                                  | 异步加载、路由懒加载   |

- \__webpack_public_path__

  - 技术实现
  
    ```js
    // Webpack 运行时生成的代码
    __webpack_require__.p = __webpack_public_path__ || "";
    // 所有资源加载路径 = __webpack_require__.p + 相对路径
    ```

    - 使用场景
  
    ```js
    // 在应用入口设置
    __webpack_public_path__ = window.appConfig.cdnBaseUrl;
    // 根据环境动态设置
    if (process.env.NODE_ENV === 'production') {
      __webpack_public_path__ = 'https://cdn.example.com/app/';
    } else {
      __webpack_require__.p = '/dev/static/';
    }
    // 微前端场景
    __webpack_public_path__ = window.__MAIN_APP__  ? 'https://cdn.mainapp.com/subapp/' : '/local/';
    ```
  
- \__webpack_init_sharing__

  - 技术实现

    ```js
    function __webpack_init_sharing__(scope) {
      if (!__webpack_share_scopes__[scope]) {
        __webpack_share_scopes__[scope] = {};
      }
      // 注册当前应用的共享模块
      for (const [name, config] of Object.entries(sharedConfig)) {
        __webpack_share_scopes__[scope][name] = {
          version: config.version,
          get: config.getter,
          loaded: false
        };
      }
    }
    ```
  
  - 使用模式
  
    ```js
    // 加载远程模块前必须调用
    if (typeof __webpack_init_sharing__ !== 'undefined') {
      await __webpack_init_sharing__('default');
    }
    // 然后初始化容器
    await container.init(__webpack_share_scopes__.default);
    ```
  
- \__webpack_share_scopes__

  - ```js
    __webpack_share_scopes__ = {
      default: {
        'react': {
          version: '18.2.0',
          from: 'host_app',
          get: () => Promise.resolve(() => __webpack_require__('react')),
          loaded: true,
          singleton: true
        },
        'lodash': {
          version: '4.17.21',
          from: 'remote_app',
          get: () => import('lodash'),
          loaded: false
        }
      }
    }
    ```
    
  - 功能
  
    - 版本管理：存储模块的多个版本
    - 来源追踪：记录模块提供者
    - 状态跟踪：监控模块加载状态
    - 单例控制：确保关键库单实例
  
  - 应用
  
    ```js
    // 检查共享的React版本
    const reactInfo = __webpack_share_scopes__.default['react'];
    console.log(`React v${reactInfo.version} from ${reactInfo.from}`);
    // 手动触发共享模块加载
    await __webpack_share_scopes__.default['lodash'].get();
    ```
  
- \__webpack_require__.l

  - webpack的动态加载核心函数，负责异步加载代码分割的模块；是import()函数的底层实现

  - 功能

    - 动态创建\<script>标签加载模块
    - 处理加载状态（成功/失败）
    - 实现模块缓存
    - 支持JSONP回调

  - 实现

    ```js
    // 简化的实现逻辑
    __webpack_require__.l = function(url) {
      return new Promise((resolve, reject) => {
        // 1. 检查缓存
        if (installedChunks[chunkId]) return resolve();
        // 2. 创建脚本标签
        const script = document.createElement('script');
        script.src = __webpack_require__.p + url;
        script.async = true;
        // 3. 设置超时
        const timeout = setTimeout(() => {
          reject(new Error(`Timeout loading ${url}`));
        }, 120000);
        // 4. 定义回调函数
        window["webpackJsonp"] = function(data) {
          clearTimeout(timeout);
          resolve();
        };
        // 5. 加载脚本
        document.head.appendChild(script);
      });
    };
    ```

  - 使用示例

    ```js
    // 动态加载模块
    __webpack_require__.l('chunk-vendors.js').then(() => {
      const module = __webpack_require__('./src/module.js');
    });
    // 等效于
    import('./module').then(module => {
      // 使用模块
    });
    ```

- 协作流程

  1. 基座设置 `__webpack_public_path__`
  2. 调用 `__webpack_init_sharing__('default')`
  3. 基座通过 `__webpack_require__.l` 加载 remoteEntry.js
  4. 调用 `container.init(__webpack_share_scopes__.default)`
  5. 加载远程模块并渲染
  
  <img src="https://i-coder.oss-cn-beijing.aliyuncs.com/files/20250824100927.png" style="zoom:67%;" />

#### **三、核心问题与解决方案**

| **问题类型**     | **表现**                      | **解决方案**                                                 |
| :--------------- | :---------------------------- | :----------------------------------------------------------- |
| **样式隔离缺失** | 子应用样式污染全局            | 启用 Shadow DOM（`strictStyleIsolation: true`）或 CSS Modules |
| **JS 沙箱缺失**  | 多子应用 window 变量冲突      | Qiankun 的 ProxySandbox 代理 window                          |
| **路由跳转错误** | 子应用路由触发基座导航        | 子应用路由配置 `base` 属性，资源路径动态修正                 |
| **内存泄漏**     | 子应用卸载后未清理事件/定时器 | 在 `unmount` 生命周期中显式销毁资源                          |

#### **四、single-spa 的局限性**

1. **动态加载缺陷**
   - 无法按需加载 CSS 文件，需手动管理资源
2. **无内置隔离机制**
   - 缺少样式隔离与 JS 沙箱，需额外实现（如 Qiankun 的补强）
3. **多应用共存问题**
   - DOM 挂载点冲突：需为每个子应用分配独立容器（如 `#app1`, `#app2`）

#### **五、高频面试题**

1. **如何实现子应用独立运行？**
   在子应用入口添加逻辑判断：

   ```js
   if (!window.singleSpaNavigate) {
     delete appOptions.el;
     new Vue(appOptions).$mount('#app');
   }
   ```

   非微前端环境时独立初始化

2. **公共依赖重复加载如何优化？**

   - 基座引入公共库（如 React），子应用通过 `externals` 排除依赖：

     ```js
     externals: {
       'react': 'React',
       'react-dom': 'ReactDOM'
     }
     ```

     减少资源冗余

#### 六、代码实现

- #### 基座

  - Vue

    ```js
    import Vue from "vue";
    import App from "./App.vue";
    import router from "./router";
    import store from "./store";
    import { registerApplication, start } from "single-spa";
    const sys = window.System;
    let importMap = {
      imports: {
        app1: "http://localhost:3001/js/app.js",
        app2: "http://localhost:3002/js/app.js"
      },
    };
    if (process.env.NODE_ENV === "production") {
      importMap = {
        imports: {
          app1: "https://single-spa-demo-vue-app1.vercel.app/js/app.js",
          app2: "https://single-spa-demo-vue-app2.vercel.app/js/app.js",
        },
      };
    }
    // 你也可以根据自定义变量区分测试环境等
    // if (process.env.VUE_APP_ENV === "test") { ... }
    sys.addImportMap(importMap);
    console.log("window", window);
    Vue.config.productionTip = false;
    // 子应用列表
    const apps = [
      {
        // 子应用名称
        name: "app1",
        // 子应用加载函数，是一个promise
        app: () => sys.import("app1"),
        // 当路由满足条件时（返回true），激活（挂载）子应用
        activeWhen: (location) => location.pathname.startsWith("/app1"),
        // 传递给子应用的对象
        customProps: {},
      },
      {
        name: "app2",
        app: () => sys.import("app2"),
        activeWhen: (location) => location.pathname.startsWith("/app2"),
        customProps: {},
      },
    ];
    // 注册子应用
    for (let i = apps.length - 1; i >= 0; i--) {
      registerApplication(apps[i]);
    }
    new Vue({
      router,
      store,
      mounted() {
        // 启动
        start();
      },
      render: (h) => h(App),
    }).$mount("#root");
    ```

    ```vue
    <div class="micro-app-container">
        <h3 class="micro-app-title">当前加载的微应用</h3>
        <div id="microApp"></div>
        <div id="app3Root"></div>
        <div id="app4Root"></div>
    </div>
    ```

- #### 子应用

  - Vue

    ```js
    // /src/main.js
    import Vue from "vue";
    import App from "./App.vue";
    import router from "./router";
    import store from "./store";
    import singleSpaVue from "single-spa-vue";
    import singleSpaCss from "single-spa-css";
    Vue.config.productionTip = false;
    const appOptions = {
      el: "#microApp",
      router,
      store,
      render: (h) => h(App),
    };
    // 独立运行时，直接挂载到 #app
    if (!window.singleSpaNavigate) {
      delete appOptions.el;
      new Vue(appOptions).$mount("#app");
    }
    // 微前端模式下，导出生命周期
    const vueLifecycle = singleSpaVue({
      Vue,
      appOptions,
    });
    const cssUrl = window.singleSpaNavigate
      ? new URL("/css/app.css", process.env.VUE_APP_PUBLIC_PATH).toString()
      : null;
    const cssLifecycles = singleSpaCss({
      cssUrls: [cssUrl],
      webpackExtractedCss: false,
      shouldUnmount: true,
      timeout: 5000,
    });
    export const bootstrap = [vueLifecycle.bootstrap, cssLifecycles.bootstrap];
    export const mount = [vueLifecycle.mount, cssLifecycles.mount];
    export const unmount = [vueLifecycle.unmount, cssLifecycles.unmount];
    ```

    ```js
    // app1/vue.config.js
    const { defineConfig } = require("@vue/cli-service");
    const pkg = require("./package.json");
    const { BannerPlugin } = require("webpack");
    module.exports = defineConfig({
      // 告诉子应用在这个地址加载静态资源，否则会去基座应用的域名下加载
      publicPath: process.env.VUE_APP_PUBLIC_PATH,
      // 开发服务器
      devServer: {
        port: 3001,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",
          "Access-Control-Allow-Headers":
            "X-Requested-With, content-type, Authorization",
        },
      },
      configureWebpack: (config) => {
        config.entry = {
          app: "./src/main.js",
        };
        config.output = {
          ...config.output,
          filename: "js/[name].js",
          chunkFilename: "js/[name]-[chunkhash:6].js",
          library: pkg.name,
          libraryTarget: "umd",
        };
        config.plugins.push(
          new BannerPlugin({
            banner: new Date().toString(),
          })
        );
        // TODO 很重要，删除改配置，禁止打包生产chunk-vendor.js，这样基座只要System.import(app.js)就可以了
        // 否则也需要import chunk-vendor.js
        delete config.optimization.splitChunks;
      },
      css: {
        extract: {
          filename: "css/[name].css",
          chunkFilename: "css/[name].[contenthash:8].css",
        },
      },
    });
    ```

  - React

    ```js
    // app3\src\index.js
    import React, { Suspense, useEffect, useState } from 'react';
    import ReactDOMClient from 'react-dom/client';
    import './index.css'
    import { RouterProvider, Link, Navigate, createBrowserRouter, Outlet, useRouteError } from 'react-router-dom'
    import singleSpaReact from 'single-spa-react'
    // 子应用独立运行
    if (!window.singleSpaNavigate) {
      const root = ReactDOMClient.createRoot(document.getElementById('app3-root'));
      root.render(rootComponent());
    }
    // 生命周期
    const reactLifecycles = singleSpaReact({
      React,
      ReactDOMClient,
      rootComponent,
      errorBoundary (err, info, props) {
        return <div>
          This renders when a catastrophic error occurs
        </div>
      },
    })
    // 这里和vue不一样，props必须向下传递
    export const bootstrap = async props => {
      console.log('app3 bootstrap');
      return reactLifecycles.bootstrap(props)
    }
    export const mount = async props => {
      console.log('app3 mount');
      return reactLifecycles.mount(props)
    }
    export const unmount = async props => {
      console.log('app3 unmount');
      return reactLifecycles.unmount(props)
    }
    // 根组件
    function rootComponent () {
      const routes = [
        {
          path: "/",
          element: <Root />,
          errorElement: <ErrorPage />,
          children: [
            {
              index: true,
              element: <Navigate to="/home" replace />
            },
            ...
          ]
        }
      ];
      const router = createBrowserRouter(routes, {
        basename: process.env.REACT_APP_BASE_URL,
        fallbackElement: <div>Loading...</div>,
      });
      return <React.StrictMode>
        <RouterProvider router={router} fallbackElement="loading..." />
      </React.StrictMode>
    }
    function Root () {
      const [name, setName] = useState(window?.$Store?.state?.userInfo?.name);
      const click = async () => {
        // window.$Store.commit("setName", Math.random());
        const data = await window?.$Store?.dispatch("syncSetName", Math.random());
        console.log(data);
        console.log(window?.$Store?.state?.userInfo?.name);
      }
      useEffect(() => {
        const unsubscribe = window?.$Store?.subscribe?.((mutation, state) => {
          setName(window?.$Store?.state?.userInfo?.name);
          console.log("111111111111111", mutation, state);
        });
        return unsubscribe;
      }, []);
      return <div id='app'>
        <Link to="/home">Home</Link> |
        <Link to="/about"> About</Link>
        <Suspense fallback={<div>laoding...</div>}>
          <Outlet />
        </Suspense>
        <div>
          <p>name: {name}</p>
          <button onClick={click}>setName</button>
        </div>
      </div>
    }
    export default function ErrorPage () {
      const error = useRouteError();
      console.error('error', error);
      return (
        <div id="error-page">
          <h1>Oops!</h1>
          <p>Sorry, an unexpected error has occurred.</p>
          <p>
            <i>{error.statusText || error.message}</i>
          </p>
        </div>
      );
    }
    ```

    ```js
    app3\craco.config.js
    const path = require("path");
    const CracoEnvPlugin = require("craco-plugin-env");
    const CracoLessPlugin = require("craco-less");
    const dotenv = require("dotenv");
    const package = require('./package.json');
    const { BannerPlugin } = require('webpack');
    const isDev = process.env.NODE_ENV === "development"
    const modeIndex = process.argv.indexOf("--mode");
    const mode = modeIndex !== -1 ? process.argv[modeIndex + 1] : (isDev ? "development" : "production");
    envPath = `.env.${mode}`;
    dotenv.config({
      path: path.resolve(__dirname, envPath),
    });
    module.exports = {
      devServer: {
        port: 3003,
        open: false,
      },
      webpack: {
        alias: {
          "@": path.resolve(__dirname, "src/"),
        },
        plugins: {
          add: [
            new BannerPlugin({
              banner: new Date().toString(),
              entryOnly: true
            })
          ],
        },
        configure: (webpackConfig) => {
          webpackConfig.output = {
            ...webpackConfig.output,
            filename: 'js/app.js',
            chunkFilename: 'js/[name]-[chunkhash:6].js',
            publicPath: process.env.REACT_APP_PUBLIC_URL,
            library: package.name,
            libraryTarget: 'umd'
          };
          webpackConfig.devtool = isDev ? "source-map" : false;
          return webpackConfig;
        },
      },
      plugins: [
        {
          // 配置less
          plugin: CracoLessPlugin,
          options: {
            lessLoaderOptions: {
              lessOptions: {
                modifyVars: {},
                javascriptEnabled: true,
              },
            },
          },
        },
        {
          // 配置环境变量
          plugin: CracoEnvPlugin,
          options: {
            variables: {},
          },
        },
      ],
    };
    ```

### Module Federation

#### 一、核心概念

Module Federation是webpack5引入的功能，允许在运行时动态加载来自不同构建的代码

- 目的
  - 微前端架构：多个独立应用组合成统一产品
  - 代码共享：跨应用共享库、组件和模块
  - 独立部署：每个微应用可独立开发部署
  - 依赖去重：避免重复加载相同依赖，减少 bundle 体积

#### 二、工作原理

##### 如何实现跨应用模块共享

- 1. **Host（主应用Consumer，加载远程模块）**

  - 需要加载别的应用暴露出来的模块。

  - 配置 `remotes`：

    ```js
    new ModuleFederationPlugin({
      remotes: {
        app1: "app1@http://cdn.com/remoteEntry.js"
      }
    })
    ```

- 2. **Remote（远程应用Exposer，暴露模块）**

  - 对外暴露模块。

  - 配置 `exposes`：

    ```js
    new ModuleFederationPlugin({
      name: "app1",
      filename: "remoteEntry.js",
      exposes: {
        "./Button": "./src/Button"
      }
    })
    ```

  - 这会生成 `remoteEntry.js`，本质是一个 **容器入口文件**。

- 3. **Container（容器）**

  - 不是单独的角色，而是指 **Remote 应用打包生成的运行时容器**，也就是 `remoteEntry.js`。

  - 它负责在运行时接收 Host 的请求，并返回暴露出来的模块。

  - 换句话说：
    - `Container` = Remote 应用打出来的远程入口文件
    - Host 通过这个容器来拿到 Remote 的模块

- 共享依赖（Shared）

  ```js
  shared: {
    react: { singleton: true, eager: true },
    "react-dom": { singleton: true }
  }
  ```

- 运行时连接（Runtime Connection）

  ```js
  // 动态加载远程模块
  const Button = React.lazy(() => import("app1/Button"));
  ```

#### 三、核心配置详解

| 配置项     | 作用                                              | 示例值                           |
| :--------- | :------------------------------------------------ | :------------------------------- |
| `name`     | 模块唯一标识                                      | `'headerApp'`                    |
| `filename` | 入口文件名称                                      | `'remoteEntry.js'`               |
| `remotes`  | 声明使用的远程模块                                | `{ cart: 'cart@http...' }`       |
| `exposes`  | 暴露给其他应用的模块（必须使用相对路径：'./xxx'） | `{ './Header': './src/Header'}`  |
| `shared`   | 共享的依赖项                                      | `{ react: { singleton: true } }` |

共享依赖高级配置

```js
shared: {
  react: {
    singleton: true,    // 只允许单个版本
    eager: true,        // 立即加载而非异步
    requiredVersion: '^18.0.0', // 版本要求（requiredVersion：期望使用的依赖版本，strictVersion：共享模块的版本必须完全满足requiredVersion，否则报错）
    version: '18.2.0',  // 当前版本
    strictVersion: true // 严格版本检查
  }
}
```

#### 四、常见问题

##### 如何处理共享依赖版本冲突

- 使用 singleton: true强制单例模式
- 设置requiredVersion约束版本范围

#### 五、使用

- ##### 获取远程模块联邦的模块

  ```typescript
  import React, { Attributes, ComponentClass, FunctionComponent } from "react";
  import ReactDOM from "react-dom/client";
  import Vue, { Component as VueComponent, CreateElement as VueCreateElement } from "vue";
  /**
   * 获取远程模块联邦的模块
   *
   * @param remoteUrl - 远程入口文件URL (e.g. http://localhost:3333/remoteEntry.js)
   * @param mfName - 模块联邦容器名称 (e.g. ReactApp)
   * @param module - 要加载的模块路径 (e.g. ./ReactButton)
   * @returns 解析为远程模块的Promise
   */
  export const getRemoteScript = async (remoteUrl: string, mfName: string, module: string): Promise<unknown> => {
  	try {
  		// 1. 初始化共享作用域
  		if (typeof __webpack_init_sharing__ !== "undefined") {
  			await __webpack_init_sharing__("default");
  		}
  		// 2. 检查容器是否已加载
  		let scope = (window as any)[mfName];
  		if (!scope) {
  			// 3. 加载远程入口文件
  			console.debug(`[MF] 加载远程入口: ${remoteUrl}`);
  			scope = await loadRemoteEntry(remoteUrl, mfName, 6 * 1000);
  		} else {
  			console.debug(`[MF] 容器已加载: ${mfName}`);
  		}
  		// 4. 初始化容器共享作用域
  		if (scope.init) {
  			try {
  				const shareScope = typeof __webpack_share_scopes__ !== "undefined" ? __webpack_share_scopes__.default : {};
  				await scope.init(shareScope);
  			} catch (scopeError) {
  				console.warn(`[MF] 共享作用域初始化失败:`, scopeError);
  			}
  		}
  		// 5. 获取模块工厂函数
  		console.debug(`[MF] 获取模块: ${module}`);
  		const factory = await scope.get(module);
  		if (typeof factory !== "function") {
  			throw new Error(`模块工厂无效: ${module}`);
  		}
  		// 6. 创建模块实例
  		const remoteModule = factory();
  		// 7. 返回默认导出或整个模块
  		return remoteModule.default || remoteModule;
  	} catch (error) {
  		console.error(`[MF] 加载失败 [${mfName}/${module}]:`, error);
  		throw new Error(`加载远程模块失败: ${error instanceof Error ? error.message : String(error)}`);
  	}
  };
  /**
   * 动态加载远程入口脚本
   *
   * @param url - 远程入口脚本URL
   * @param scopeName - 全局容器名称
   * @param timeout - 加载超时时间(毫秒)
   * @returns 解析为容器作用域的Promise
   */
  const loadRemoteEntry = (url: string, scopeName: string, timeout: number): Promise<any> => {
  	return new Promise((resolve, reject) => {
  		// 检查是否已加载
  		if ((window as any)[scopeName]) {
  			return resolve((window as any)[scopeName]);
  		}
  		const script = document.createElement("script");
  		script.src = url;
  		script.type = "text/javascript";
  		script.async = true;
  		script.crossOrigin = "anonymous"; // 添加跨域支持，anonymous会引起跨域
  		let timeoutId: number | null = null;
  		// 设置超时处理
  		if (timeout > 0) {
  			timeoutId = setTimeout(() => {
  				reject(new Error(`加载远程入口超时: ${url}`));
  				document.head.removeChild(script);
  			}, timeout);
  		}
  		// 成功加载回调
  		script.onload = () => {
  			timeoutId && clearTimeout(timeoutId);
  			if (!(window as any)[scopeName]) {
  				reject(new Error(`加载后未找到容器: ${scopeName}`));
  			} else {
  				resolve((window as any)[scopeName]);
  			}
  		};
  		// 加载失败回调
  		script.onerror = (error) => {
  			timeoutId && clearTimeout(timeoutId);
  			reject(new Error(`加载脚本失败: ${url} - ${(error as ErrorEvent).message}`));
  		};
  		// 添加到DOM
  		document.head.appendChild(script);
  	});
  };
  ```

- ##### React加载远程React 模块	

  ```typescript
  /**
   * 渲染远程React组件到DOM
   *
   * @param compName - React组件名称/类型
   * @param targetEl - 目标DOM元素或文档片段
   * @param attrs - 组件属性
   *
   * 使用示例:
   * const Button = await getRemoteScript(url, 'ReactApp', './Button');
   * loadRemoteReact(Button, document.getElementById('root'), { text: 'Click me' });
   */
  export const loadRemoteReact = (
  	compName: FunctionComponent | ComponentClass | string,
  	targetEl: Element | DocumentFragment,
  	attrs: Attributes & Record<string, any>
  ) => {
  	if (!targetEl) {
  		throw new Error("目标元素无效");
  	}
  	const root = ReactDOM.createRoot(targetEl);
  	root.render(React.createElement(compName, attrs));
  	// 返回卸载函数以便清理
  	return () => root.unmount();
  };
  ```

  示例

  ```tsx
  import { getRemoteScript, loadRemoteReact } from "@repe/remote-utils";
  import { useEffect, useRef } from "react";
  interface IProps {
  	mfName: string;
  	module: string;
  	attrs: {
  		[key: string]: any;
  	};
  }
  const RemoteReact = (props: IProps) => {
  	const ref = useRef(null);
  	const { mfName, module, attrs } = props;
  	const getRemoteComp = async () => {
  		const REMOTE_URL = process.env.REACT_APP_REACT_REMOTE_URL;
  		// import 远程组件
  		const result = await getRemoteScript(
  			`${REMOTE_URL}/remoteEntry.js`,
  			mfName,
  			module,
  		);
  		if (ref.current) {
  			loadRemoteReact(result, ref.current, attrs);
  		}
  	};
  	useEffect(() => {
  		getRemoteComp();
  		// eslint-disable-next-line react-hooks/exhaustive-deps
  	}, []);
  	return <div ref={ref}>Loading...</div>;
  };
  export default RemoteReact;
  
  // 调用
  <RemoteReact
      mfName="ReactApp"
      module="./ReactHeader"
      attrs={{ title: "this is remote react header" }}
      />
  ```

  

- ##### React加载远程Vue模块

  ```typescript
  /**
   * 挂载远程Vue组件到DOM
   *
   * @param compName - Vue组件选项对象
   * @param targetEl - 目标DOM元素或选择器
   * @param attrs - 组件属性
   *
   * 使用示例:
   * const Card = await getRemoteScript(url, 'VueApp', './Card');
   * loadRemoteVue(Card, '#app', { title: 'Vue Card' });
   */
  export const loadRemoteVue = ( compName: VueComponent, targetEl: string | Element, attrs: Record<string, any>) => {
  	const el = typeof targetEl === "string" ? document.querySelector(targetEl) : targetEl;
  	if (!el) {
  		throw new Error("目标元素未找到");
  	}
  	// 创建Vue实例并挂载
  	const app = new Vue({
  		render: (h: VueCreateElement) => h(compName, { props: attrs }),
  	}).$mount(el);
  	// 返回销毁函数以便清理
  	return () => app.$destroy();
  };
  ```

  示例

  ```tsx
  import { getRemoteScript, loadRemoteVue } from "@repe/remote-utils";
  import { useEffect, useRef } from "react";
  interface IProps {
  	mfName: string;
  	module: string;
  	attrs: {
  		props: {
  			[key: string]: any;
  		};
  		on: {
  			click: () => void;
  		};
  	};
  }
  const RemoteVue = (props: IProps) => {
  	const ref = useRef(null);
  	const { mfName, module, attrs } = props;
  	const getRemoteComp = async () => {
  		const REMOTE_URL = process.env.REACT_APP_VUE_REMOTE_URL;
  		// import 远程组件
  		const result = await getRemoteScript(
  			`${REMOTE_URL}/remoteEntry.js`,
  			mfName,
  			module,
  		);
  		if (ref.current) {
  			loadRemoteVue(result, ref.current, {
  				props: attrs.props,
  				on: attrs.on,
  			});
  		}
  	};
  	useEffect(() => {
  		getRemoteComp();
  		// eslint-disable-next-line react-hooks/exhaustive-deps
  	}, []);
  	return <div ref={ref}>Loading...</div>;
  };
  export default RemoteVue;
  
  <RemoteVue
      mfName="VueApp"
      module="./Sidebar"
      attrs={{
          props: {
              title: "this is sidebar title",
          },
              on: {
                  click: () => {
                      console.log("hello");
                  },
              },
      }}
      />
  ```

### Module Federation 2.0

未来趋势：MF 2.0正推动实现 **“模块即服务”（Modules as Service）** 的标准化，逐步减少对构建工具的依赖，向浏览器原生模块（如ESM+Import Maps）靠拢

#### mf-manifest.json

- ##### 定义 & 核心作用

  - 是什么
    - 定义：一个包含联邦模块所有元数据的JSON文件
    - 生成时机：在构建阶段有Module Federation2.0插件自动生成
    - 存储位置：通常部署在CDN或静态服务器，与入口文件同目录

  - 核心加载

    | **功能**     | **MF 1.0** | **MF 2.0 + Manifest** |
    | :----------- | :--------- | :-------------------- |
    | **模块发现** | 静态配置   | 动态发现              |
    | **依赖解析** | 运行时计算 | 预分析优化            |
    | **版本管理** | 手动维护   | 自动同步              |
    | **加载策略** | 无智能决策 | 基于元数据的预取      |

#### 文件结构与解析

- ##### 完整结构示例

  ```json
  {
    "$schema": "https://module-federation.io/schemas/mf-manifest/v1.json",
    "id": "product-app",
    "version": "1.2.3",
    "createdAt": "2023-10-15T08:30:00Z",
    "entry": "/remoteEntry.js",
    "exposes": { // 暴露模块 (exposes)
      "./ProductCard": {
        "path": "/components/ProductCard.js", // 物理路径
        "integrity": "sha384-abc123...", // SRI 哈希值
        "dependencies": { // 模块级依赖
          "react": "^18.0.0",
          "shared-utils": "1.0.0"
        },
        "size": 24576, // 字节大小
        "prefetchPriority": "high" // 加载优先级
      }
    },
    "remotes": { // 远程依赖 (remotes)
      "cart-service": {
        "entry": "https://cart.example.com/mf-manifest.json", // 动态发现入口
        "requiredVersion": "^2.0.0"
      }
    },
    "shared": { // 共享依赖 (shared)
      "react": {
        "version": "18.2.0", // 实际版本
        "singleton": true, // 单例模式
        "eager": false, // 是否急切加载
        "allowedVersions": "^18.0.0" // 可接受版本范围
      }
    },
    "buildInfo": { // 构建信息 (buildInfo)
      "webpackVersion": "5.75.0", // 构建工具版本
      "buildTime": 4500, // 构建耗时(ms)
      "environment": "production" // 构建环境
    }
  }
  ```

#### 工作原理与运行时交互

- 工作流程

  <img src="https://i-coder.oss-cn-beijing.aliyuncs.com/files/20250824100959.png" style="zoom:67%;" />
  
- 运行时加载优化

  ```js
  // 主应用中使用manifest的示例
  async function loadRemoteComponent(scope, module) {
    // 1. 加载manifest
    const manifest = await fetchManifest(`https://${scope}/mf-manifest.json`);
    // 2. 检查模块是否存在
    if (!manifest.exposes[module]) {
      throw new Error(`Module ${module} not exposed by ${scope}`);
    }
    // 3. 智能预取依赖
    await prefetchDependencies(manifest.exposes[module].dependencies);
    // 4. 加载模块
    const container = await loadContainer(manifest.entry);
    const factory = await container.get(module);
    return factory();
  }
  ```

#### 跨工具支持

<img src="https://i-coder.oss-cn-beijing.aliyuncs.com/files/20250824101021.png" style="zoom:67%;" />

远程加载

```js
export default createModuleFederationConfig({
  name: 'mf_app_consumer_1',
  remotes: {
    'mfAppComp1': 'mf_app_provider_1@http://localhost:3001/mf-manifest.json',
    'mfLibCompProvider': 'mf_lib_provider_1@http://localhost:3002/mf-manifest.json',
  },
  shareStrategy: 'loaded-first',
  shared: {...},
});

// 使用
import React from 'react';
import { loadRemote } from '@module-federation/enhanced/runtime';
import MfAppComp1 from 'mfAppComp1';
import MfLibCompIndex from 'mfLibCompProvider/Index';
const MfLibCompButton = React.lazy(() => loadRemote('mfLibCompProvider/Button'));
const App = () => {
  return (
    <div className="content">
      <MfAppComp1 />
      <MfLibCompIndex />
      <MfLibCompButton />
    </div>
  );
};
export default App;

// mf_app_provider_1
import { createModuleFederationConfig } from '@module-federation/rsbuild-plugin';
export default createModuleFederationConfig({
  name: 'mf_app_provider_1',
  filename: 'remoteEntry.js',
  exposes: {
    '.': './src/components/ProviderComponent.tsx',
  },
  shared: {...},
});

// mf_lib_provider_1
import {createModuleFederationConfig} from '@module-federation/rsbuild-plugin';
export default createModuleFederationConfig({
  name: 'mf_lib_provider_1',
  exposes: {
    './Index': './src/index.tsx',
    './Button': './src/button.tsx',
  },
  shared: {...},
})

```



#### shared

- singleton

  是否在共享作用域中只允许共享模块的一个版本 (单例模式).

- requiredVersion

  所需版本，可以是一个版本区间。默认值为当前应用的依赖版本

- eager

  是否立即加载共享模块；（设置为 true 后，会将共享依赖打包到入口文件，从而导致入口文件体积过大。请谨慎开启。）

- strategy

  - version-first（默认值）

    版本优先，确保使用最高版本的共享依赖。设置后，**会在应用初始化时自动加载所有 \*remotes\* 入口文件**，并注册对应的共享依赖，确保能获取到所有的共享依赖版本。当对版本有严格要求时，推荐使用此策略。

  - loaded-first

    复用优先，大幅减少多余的依赖请求。设置后，不会自动加载 *remotes* 入口文件（仅在有需求时才会加载），优先复用已加载的共享依赖。当对版本没有严格要求且对性能有要求时，推荐使用此策略。

### Module Federation 1.x & Module Federation 2.0

### 1. 运行时架构

| **特性**     | **MF 1.0**                | **MF 2.0**                                 |
| :----------- | :------------------------ | :----------------------------------------- |
| **架构模型** | 紧密耦合于Webpack构建系统 | 独立运行时（`@module-federation/runtime`） |
| **依赖关系** | 完全依赖Webpack           | 构建工具无关（Webpack/Vite/Rspack/RN）     |
| **核心大小** | ~30KB (gzip)              | ~13KB (gzip) + 插件扩展                    |
| **扩展机制** | 无                        | Tapable插件系统                            |

| **特性**         | **remoteEntry.js (MF 1.0)** | **mf-manifest.json (MF 2.0)** |
| :--------------- | :-------------------------- | :---------------------------- |
| **元数据丰富度** | 有限（仅暴露模块）          | 全面（依赖、大小、版本等）    |
| **动态发现**     | 不支持                      | 原生支持                      |
| **离线分析**     | 困难                        | 专用工具支持                  |
| **跨工具支持**   | Webpack 专属                | 构建工具无关                  |
| **安全特性**     | 基础                        | SRI、访问控制集成             |
| **加载优化**     | 手动实现                    | 内置优先级提示                |

**底层原理对比**：

<img src="https://i-coder.oss-cn-beijing.aliyuncs.com/files/20250824101047.png" style="zoom:67%;" />

### 2. 类型系统支持

| **特性**     | **MF 1.0**        | **MF 2.0**                                                   |
| :----------- | :---------------- | :----------------------------------------------------------- |
| **类型获取** | 手动维护.d.ts文件 | 自动拉取远程类型（`@mf-types`）<br />- 构建时生成`@mf-types.d.ts`和`@mf-types.zip`，存放远程模块的类型声明<br />- 通过`tsconfig.json`的`paths`配置实现远程模块的TS智能提示 |
| **开发体验** | 无智能提示        | 完整的TS支持                                                 |
| **类型存储** | 本地维护          | 集中式类型仓库                                               |

**类型同步流程**：

<img src="https://i-coder.oss-cn-beijing.aliyuncs.com/files/20250824101106.png" style="zoom:67%;" />

## 二、运行时能力深度对比

### 1. 依赖共享机制

**MF 1.0 共享原理**：

```js
// 共享作用域伪代码
__webpack_share_scopes__.default = {
  'react': {
    version: '18.2.0',
    get: () => Promise.resolve(require('react')),
    loaded: true,
    from: 'host_app'
  }
}
```

**MF 2.0 增强功能**：

1. **策略优先级系统**：

   ```js
   shared: {
     react: {
       strategy: 'loaded-first', // 新策略
       requiredVersion: {
         production: '^18.2.0',
         development: '^18.1.0'
       }
     }
   }
   ```

2. **环境感知共享**：

   ```js
   shared: {
     axios: {
       version: '1.3.4',
       env: {
         browser: { singleton: true },
         node: { singleton: false }
       }
     }
   }
   ```

### 2. 插件系统架构

**MF 2.0插件工作原理**：

```js
classDiagram
  class Runtime {
    +plugin(hook: string, handler: Function)
    +applyPlugins(hook: string, ...args)
  }
  
  class ScriptLoaderPlugin {
    +apply(runtime: Runtime)
    +createScriptNode(url)
  }
  
  class ReactNativeAdapter {
    +apply(runtime: Runtime)
    +createScriptNode() // 覆盖默认实现
  }
  
  Runtime <|-- ScriptLoaderPlugin
  Runtime <|-- ReactNativeAdapter
```

**插件实现示例**（React Native支持）：

```js
class ReactNativeScriptPlugin {
  apply(runtime) {
    runtime.plugin('createScript', (url) => {
      return {
        load: () => {
          return ScriptManager.loadScript({
            url,
            cache: true,
            resolve: () => console.log(`Loaded: ${url}`)
          });
        }
      };
    });
  }
}

// 初始化运行时
const runtime = new Runtime();
runtime.apply(new ReactNativeScriptPlugin());
```

## 三、性能优化对比

### 1. 加载性能优化

| **优化项**     | **MF 1.0**         | **MF 2.0**             |
| :------------- | :----------------- | :--------------------- |
| **运行时复用** | 每个应用独立运行时 | 共享外部化运行时       |
| **模块预取**   | 无                 | 基于Manifest的智能预取 |
| **树摇优化**   | 有限支持           | 深度Tree-Shaking       |

**MF 2.0预取机制**：

<img src="https://i-coder.oss-cn-beijing.aliyuncs.com/files/20250824101125.png" style="zoom:67%;" />

### 2. 生产环境优化

**MF 2.0构建配置**：

```js
// webpack.config.js
module.exports = {
  experiments: {
    externalRuntime: true, // 外部化运行时
    federation: {
      manifest: 'federation-manifest.json' // 生成Manifest
    }
  },
  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            module_federation: true // 专用优化
          }
        }
      })
    ]
  }
}
```

## 五、实际场景对比分析

### 1. 企业级微前端

**MF 1.0痛点**：

- 多个团队使用不同构建工具无法集成
- 类型不一致导致运行时错误
- 移动端无法复用Web模块

**MF 2.0解决方案**：

1. Webpack团队 + Vite团队共享模块
2. 自动同步类型定义
3. React Native复用Web业务组件

### 2. 渐进式迁移

**MF 1.0限制**：

- 仅支持Webpack到Webpack
- 旧系统改造困难

**MF 2.0方案**：

<img src="https://i-coder.oss-cn-beijing.aliyuncs.com/files/20250824101143.png" style="zoom:67%;" />

**适配层实现**：

```js
// jQuery应用适配
export function initJQueryModule(container) {
  return {
    mount: (el) => $(el).load('legacy-module.html'),
    unmount: () => $('#legacy-module').remove()
  };
}

// 注册到MF
runtime.register('legacy-module', initJQueryModule);
```

## 六、底层原理深度解析

### 1. 模块解析算法

**MF 2.0增强解析流程**：

<img src="https://i-coder.oss-cn-beijing.aliyuncs.com/files/20250824101200.png" style="zoom:67%;" />

### 2. 安全沙箱机制

**MF 2.0安全增强**：

```js
// 沙箱插件实现
class SecuritySandboxPlugin {
  apply(runtime) {
    runtime.plugin('beforeModuleExecute', (module, context) => {
      // 1. CSP策略检查
      if (!validateCSP(module.source)) {
        throw new Error('违反内容安全策略');
      }
      
      // 2. 创建安全上下文
      const safeContext = createSecureContext(context);
      
      // 3. 执行模块
      return executeInSandbox(module, safeContext);
    });
  }
}
// 初始化安全运行时
const runtime = new Runtime();
runtime.apply(new SecuritySandboxPlugin());
```



在 **Module Federation** 中，React/Vue 等框架类库是否必须 **共用同一个实例**，是否必须 **单例**，取决于你怎么配置 `shared`，以及微前端架构的目标。

------

## 1. 默认情况（推荐方式）

- **React / Vue 必须单例（singleton: true）**

  - 原因：

    - React：必须保证整个应用树只有 **一个 React 实例**，否则会出现 `Hooks invalid`、`Context 不共享`、`React reconciliation 出错` 等问题。
    - Vue：同理，Vue 的响应式系统和依赖追踪器必须唯一，否则会导致跨应用的组件状态不一致。

  - 配置示例：

    ```
    shared: {
      react: { singleton: true, requiredVersion: '^18.0.0' },
      'react-dom': { singleton: true, requiredVersion: '^18.0.0' },
      vue: { singleton: true, requiredVersion: '^3.0.0' }
    }
    ```

------

## 2. 可以不单例的场景

- **不同子应用完全隔离，互不通信**
  - 例如：一个页面里加载 Vue 应用，一个 Tab 里加载 React 应用，之间完全没有交互。
  - 这种情况下，每个 Remote 可以有自己的一份 React/Vue，互不影响。
  - 配置时可以 **不设置 singleton**，甚至不在 `shared` 里声明。
  - 代价：页面体积增大（因为会重复加载 React/Vue），但安全隔离。

------

## 3. 部分共享 + 隔离

- 有些场景下，可以允许共享基础框架，但不共享某些生态库。

  - 例如 React 必须单例，但 `antd`、`react-query` 等库可以选择自己版本，避免版本冲突。

  - 配置示例：

    ```
    shared: {
      react: { singleton: true, strictVersion: true },
      'react-dom': { singleton: true, strictVersion: true },
      antd: { singleton: false } // 每个应用可带自己的 antd
    }
    ```

------

## 4. 为什么大多数文档推荐 **singleton: true**

- 减少重复依赖 → 减小 bundle 体积。
- 保证上下文一致性（Hooks、依赖注入、响应式系统）。
- 避免运行时奇怪的 bug。

------

✅ **总结：**

- **React / Vue 几乎必须单例**（除非应用完全隔离、不共享状态）。
- **UI 库/工具库** 可根据需要是否共享。
- 最佳实践是：React/Vue 单例，严格版本（`strictVersion`），其他依赖可灵活配置。
