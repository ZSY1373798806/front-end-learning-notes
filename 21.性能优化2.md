

# 性能优化

## 页面工程优化

> 网络协议、资源配置、浏览器性能、缓存等；
>
> 图片懒加载、雪碧图；
>
> 使用prefetch/preload预加载；
>
> tree shaking代码瘦身;



### 动画性能优化

- CSS3动画会比基于javascript实现的动画效率更高，优先使用CSS3动画效果
- 使用CSS3实现动画时，考虑开启GPU加速
- 优先使用消耗最低的transform和opacity两个属性
- 使用will-change属性
- 独立合成层，减少绘制区域
- 对于只能使用javascript实现动画效果的情况，考虑使用requestAnimationFrame、requeststldleCallback API
- 批量进行样式变换，减少布局抖动

## 代码细节优化

> javascript对DOM的操作、宿主环境的单线程相关内容等。

### 案例1 布局抖动问题

> 布局抖动是指：DOM元素被javascript多次反复读写，导致文档多次无意义重排；
>
> 浏览器很懒，会收集（patch）当前操作，统一进行重排；
>
> 但如果在当前操作完成之前，从DOM元素中获取值，会迫使浏览器提早执行布局操作，称作‘强制同步布局’；
>
> 导致严重的后果

错误代码

> 引起布局抖动问题

```javascript
const h1 = element1.clientHeight
element1.style.height = (h1 * 2) + 'px'
const h2 = element2.clientHeight
element2.style.height = (h2 * 2) + 'px'
const h3 = element3.clientHeight
element3.style.height = (h3 * 2) + 'px'
```

优化代码

> 使用window.requestAnimationFrame进行优化
>
> window.requestAnimationFrame(callback)
>
> 该方法告诉浏览器你希望执行的操作，并请求浏览器在下一次重绘之前调用制定的函数来更新

```javascript
const h1 = element1.clientHeight
requestAnimationFrame(() => {
  element1.style.height = (h1 * 2) + 'px'
})
const h2 = element2.clientHeight
requestAnimationFrame(() => {
  element2.style.height = (h2 * 2) + 'px'
})
const h3 = element3.clientHeight
requestAnimationFrame(() => {
  element3.style.height = (h3 * 2) + 'px'
})
```

#### 延伸题目

- 实现window.requestAnimationFrame的polyfill（兼容性）

```javascript
if (!window.requestAnimationFrame) {
  window.requestAnimationFrame = callback => {
    const id = window.setTimeout(() => {
      callback()
    }, 1000 / 60) // 1秒钟60次（大约每16.7毫秒一次）（60帧）
    return id
  }
}
if(!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = id => {
    clearTimeout(id)
  }
}
```

### 案例2 事件代理

- 为每个li添加点击事件

```html
<ul>
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  <li>item 4</li>
</ul>
```

```javascript
window.onload = () => {
  const ul = document.getElementsByTagName('ul')[0]
  ul.onclick = e => {
    const ev = e || window.event
    const target = ev.target || ev.srcElement
    if (target.nodeName.toLowerCase() === 'li') {
      console.log(target.innerHTML)
    }
  }
}
```

### 防抖 && 节流

> 防抖：本质是短时间内高频触发，把短时间内的多次连续调用合并成一次，只触发一次回调函数；
>
> 节流：将短时间的函数调用以一个固定频率间隔执行。

#### 防抖

![img](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210419235636837.png)

​		实现

```javascript
const debounce = (func, wait = 500, immediate) => {
  let timeout
  return function() {
    // 上下文this对象
    const context = this
    const args = arguments
    // 判断是否为立即执行
    const callNow = immediate && !timeout
    timeout && clearTimeout(timeout)
    timeout = setTimeout(() => {
      timeout = null
      if (!immediate){
        func.apply(context, args)
      }
    }, wait)
    // 立即执行
    if (callNow) {
      func.apply(context, args)
    }
  }
}
```

> 使用setTimeout在wait时间后执行事件回调；
>
> 如果在这个时间内又有相关的事件触发，则通过clearTimeout(timeout)取消上一次设置的回调；
>
> 在wait时间内没有连续触发多次事件，才会真正触发回调函数；
>
> wait时间内多次调用被归并成了一次，在最后一次抖动后，进行回调执行；
>
> immediate用于立即执行回调。

```javascript
// 采用防抖
window.addEventListener('scroll', debounce(() => {
	console.log('scroll')
}, 500))
```

#### 节流

![img](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210419235707038.png)

- ##### 时间戳实现

```javascript
function throttleByTimestamp(fn, wait=500) {
  let previous = 0
  return function(...args) {
    const context = this
    let now = +new Date()
    if (now - previous > wait) {
      fn.apply(context, args)
      previous = now
    }
  }
}
```

- ##### 定时器实现

```javascript
function throttleByTimeout(fn, wait=500) {
  let timeout
  return function(...args) {
    const context = this
    if (!timeout) {
      timeout = setTimeout(() => {
        fn.apply(context, args)
        timeout = null
      }, wait)
    }
  }
}
```

###### 时间戳实现 && 定时器实现的区别

- 首次触发
  - 使用时间戳：会立即执行（将previous设置为0的情况）
  - 使用定时器：会设置定时器，wait时间后执行
- 停止触发
  - 使用时间戳：停止触发后不再执行
  - 使用定时器：由于存在定时器，停止触发后还会执行一次

```javascript
body = document.body
body.onscroll = throttleByTimestamp(function(event) {
  console.log('scroll 使用时间戳节流')
})
body.onscroll = throttleByTimeout(function(event) {
  console.log('scroll 使用定时器节流')
})
```

### WebP图片优化

### ⚡ **一、WebP 核心优势**

| **指标**       | WebP vs JPEG/PNG                                          | 效果说明                   |
| :------------- | :-------------------------------------------------------- | :------------------------- |
| **体积压缩率** | 比 JPEG 小 **25-35%** 比 PNG 小 **26%**                   | 同等画质下显著减少带宽占用 |
| **支持特性**   | ✅ 有损/无损压缩 ✅ 透明度（Alpha 通道） ✅ 动画（类似 GIF） | 全面替代 JPEG/PNG/GIF      |
| **解码速度**   | 比 JPEG 慢 1.5~2.2 倍 比 PNG 快 1.5 倍                    | 需权衡体积节省与 CPU 消耗  |

> 实测案例：电商网站首图（1920x1080）
>
> - JPEG（80%质量）：248 KB
> - WebP（80%质量）：**162 KB**（↓ **34.7%**）

### 🛠️ **二、转换工具推荐**

#### 1. **命令行工具（高效批量处理）**

- **cwebp**（官方工具）：

  ```bash
  # 单文件转换（默认75%质量）
  cwebp input.jpg -o output.webp
  
  # 批量转换（结合 find 命令）
  find ./images -name "*.jpg" -exec cwebp {} -o {}.webp \;
  ```

  **关键参数**：
  `-q 80`：质量（推荐 75-85 平衡画质/体积）
  `-m 6`：压缩级别（0-6，越高越慢）
  `-lossless`：无损模式（适合图标/线稿）

- **imagemin-webp**（Node.js 集成）：

  ```js
  const imagemin = require('imagemin');
  const imageminWebp = require('imagemin-webp');
  
  (async () => {
    await imagemin(['images/*.{jpg,png}'], {
      destination: 'webp_images',
      plugins: [imageminWebp({ quality: 75 })]
    });
  })();
  ```

#### 2. **图形界面工具**

- **Squoosh**（Google 开源）：[https://squoosh.app](https://squoosh.app/)
  - 实时预览画质对比
  - 支持高级参数（色域、降噪）

### 🌐 **三、前端部署策略**

#### 1. **兼容性兜底方案（`<picture>`标签）

```html
<picture>
  <!-- 优先加载 WebP（支持浏览器） -->
  <source srcset="image.webp" type="image/webp">
  <!-- 回退到原格式 -->
  <img src="image.jpg" alt="Description" loading="lazy">
</picture>
```

#### 2. **CDN 动态适配**

- **Cloudflare Polish**：自动转换 JPG/PNG → WebP（支持缓存）

- **Akamai Image Manager**：按设备类型动态输出 WebP

  

> 项目中往往存在大量的图片内容，因此图片的性能优化是瓶颈和重点；
>
> 除了传统的图片懒加载外；
>
> 还可以使用WebP图片格式的替换；
>
> 潜在兼容性的问题，需要先对兼容性进行嗅探；

- 兼容性代码片段

```javascript
const supportWebP = () => new Promise(resolve => {
  const image = new Image()
  image.onerror = () => resolve(false)
  image.onload = () => resolve(image.width === 1)
  // 该资源是一张像素为1x1的WebP格式图片
  image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='
}).catch(() => false)

supportWebP().then((isSupport) => {
  console.log(isSupport)
})

// true
```

### **AVIF**

### ⚡ **一、AVIF 核心优势（对比 WebP/JPEG）**

| **指标**     | AVIF 表现                                                    | 对标格式差距             |
| :----------- | :----------------------------------------------------------- | :----------------------- |
| **压缩效率** | 比 JPEG 小 **50%+** 比 WebP 小 **20-30%**                    | 同等画质下全球最强压缩率 |
| **功能支持** | ✅ HDR（10/12bit 色深） ✅ 广色域（BT.2020） ✅ 无损/有损/渐进式 ✅ 深度图/图层 | 超越 WebP 的专业级特性   |
| **画质保留** | 低码率下细节损失更少 （尤其纹理/渐变区域）                   | 主观画质评分高 30%+      |

> **实测数据**（4K 风景图，SSIM 0.98）：
>
> - JPEG：12.8 MB
> - WebP：7.1 MB
> - **AVIF：4.9 MB**（↓ 61% vs JPEG, ↓ 31% vs WebP）

### 🛠️ **二、编码/解码工具链**

#### 1. **命令行工具**

- **libavif**（官方编码器）：

  ```bash
  # 安装
  git clone https://github.com/AOMediaCodec/libavif.git
  cd libavif && mkdir build && cd build
  cmake .. && make
  
  # 转换图片（有损压缩）
  avifenc -c aom -s 6 -q 35 input.jpg output.avif
  ```

  **关键参数**：
  `-q 1-100`：质量（值越高画质越好，推荐 30-50）
  `-s 0-10`：速度（0 最慢压缩率最高）
  `--min 0 --max 63`：设置量化器范围（精细控制）

- **FFmpeg**（视频帧转 AVIF）：

  ```
  ffmpeg -i frame.png -c:v libaom-av1 -still-picture 1 frame.avif
  ```

#### 2. **前端工程化集成**

- **Sharp**（Node.js 高性能图像处理）：

  ```js
  const sharp = require('sharp');
  
  sharp('input.png')
    .avif({ 
      quality: 45,      // 质量 (1-100)
      effort: 6,        // 压缩努力值 (0-9, 越高越慢)
      chromaSubsampling: '4:4:4' // 色度采样（避免色带）
    })
    .toFile('output.avif');
  ```

- **Vite 插件**（构建时自动转换）：

  ```bash
  // vite.config.js
  import { defineConfig } from 'vite';
  import avif from 'vite-plugin-avif';
  
  export default defineConfig({
    plugins: [avif({ quality: 50 })]
  });
  ```

------

### 🌐 **三、前端部署策略**

#### 1. 兼容性兜底方案

```html
<picture>
  <!-- 优先 AVIF（现代浏览器） -->
  <source srcset="image.avif" type="image/avif">
  <!-- 次选 WebP -->
  <source srcset="image.webp" type="image/webp">
  <!-- 最终回退 -->
  <img src="image.jpg" alt="描述" loading="lazy" decoding="async">
</picture>
```

#### 2. **CDN 动态适配**

- **Cloudflare Images**：支持按需输出 AVIF（需启用 Polish 高级版）
- **Akamai Media Accelerator**：实时转码 + AVIF 分发
- **Fastly Image Optimizer**：通过 `?format=avif` 参数动态转换

#### 3. Nginx 内容协商

```nginx
map $http_accept $avif_suffix {
  default   "";
  "~*avif"  ".avif";
}

server {
  location ~* \.(jpg|png|webp)$ {
    add_header Vary Accept;
    try_files $uri$avif_suffix $uri =404;
  }
}
```

------

### ⚠️ **四、关键注意事项**

1. **解码性能瓶颈**

   - 解码速度比 JPEG 慢 **3-5 倍**（低端移动设备慎用）

   - 解决方案：

     ```html
     <!-- 仅对高分辨率图片使用 AVIF -->
     <source 
       media="(min-width: 1200px)" 
       srcset="large.avif" 
       type="image/avif"
     >
     ```

2. **兼容性现状**（截至 2025）

   | **浏览器**     | 支持版本        | 覆盖率 |
   | :------------- | :-------------- | :----- |
   | Chrome         | 85+             | 92%    |
   | Firefox        | 86+             | 88%    |
   | Safari         | 16.4+           | 75%    |
   | Edge           | 90+             | 91%    |
   | **不支持环境** | IE11、iOS <16.4 | <8%    |

3. **压缩参数黄金组合**

   - 高画质：`quality=50, effort=6`
   - 快速编码：`quality=40, effort=4`
   - 无损模式：`quality=100, effort=9`

------

### 📊 **五、性能收益实测**

| **场景**    | 格式     | 体积      | LCP      | FID      | 综合收益  |
| :---------- | :------- | :-------- | :------- | :------- | :-------- |
| 电商 Banner | JPEG     | 420KB     | 1.8s     | 68ms     | 基准      |
| (1920×1080) | WebP     | 280KB     | 1.5s     | 52ms     | ↑ 17%     |
|             | **AVIF** | **180KB** | **1.2s** | **38ms** | ↑ **34%** |
| 用户头像    | PNG      | 120KB     | -        | -        | 基准      |
| (200×200)   | WebP     | 32KB      | -        | -        | ↓ 73%     |
|             | **AVIF** | **18KB**  | -        | -        | ↓ **85%** |

> 数据来源：[Web Almanac 2025 图片性能报告](https://almanac.httparchive.org/)

------

### 💎 **总结：AVIF 落地策略**

1. **适用场景优先级**：
   - ✅ **大尺寸图片**（Banner/产品图/背景图）
   - ✅ **静态资源**（图标/插画需配合 SVG）
   - ⚠️ **小尺寸动态图**（用 WebP 更平衡性能）
2. **工具链推荐**：
   - 开发环境：`sharp` + `vite-plugin-avif`
   - 生产环境：CDN 动态转换（Cloudflare/Akamai）



# 📌 前端性能优化速查表

## 一、页面工程优化

| 优化方向     | 方法/方案                     | 关键点/代码片段                               |
| ------------ | ----------------------------- | --------------------------------------------- |
| **网络协议** | HTTP/2 / HTTP/3               | 多路复用、头部压缩、0-RTT                     |
| **压缩**     | Gzip / Brotli                 | Nginx/webpack 配置 `compression`              |
| **CDN**      | 静态资源分发                  | 缓存 + 边缘节点加速                           |
| **缓存**     | Cache-Control / ETag          | 版本号 + hash 缓存                            |
| **预加载**   | preload / prefetch            | `<link rel="preload" as="script" href="...">` |
| **代码优化** | Tree Shaking / Code Splitting | webpack、Vite 动态 import                     |

------

## 二、代码细节优化

| 场景         | 问题                    | 优化方案                           | 示例代码                                                     |
| ------------ | ----------------------- | ---------------------------------- | ------------------------------------------------------------ |
| **DOM 操作** | 布局抖动 (强制同步布局) | 批量写/读、`requestAnimationFrame` | `js<br>const h = el.clientHeight;<br>requestAnimationFrame(()=> el.style.height = h*2 + 'px');` |
| **事件绑定** | 为每个元素绑定事件      | **事件委托**                       | `js<br>ul.onclick = e => { if(e.target.tagName==='LI'){...}}` |
| **高频触发** | scroll、resize          | **防抖 / 节流**                    | `js<br>// 防抖<br>const debounce=(fn,wait)=>{let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),wait)}}<br>// 节流<br>const throttle=(fn,wait)=>{let prev=0;return(...a)=>{let now=Date.now();if(now-prev>wait){fn(...a);prev=now}}}` |

------

## 三、动画优化

| 技术           | 原则                                           | 代码/技巧                                                    |
| -------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| **CSS3 动画**  | 优先使用 GPU 加速属性 (`transform`, `opacity`) | `transform: translateZ(0);`                                  |
| **独立合成层** | 减少重绘重排                                   | `will-change: transform, opacity;`                           |
| **JS 动画**    | 用 `requestAnimationFrame` 替代 `setInterval`  | `js<br>function step(){/*更新动画*/ requestAnimationFrame(step)} step()` |

------

## 四、图片与多媒体优化

| 格式           | 优势                            | 使用方式                                                     |
| -------------- | ------------------------------- | ------------------------------------------------------------ |
| **WebP**       | 比 JPEG 小 25-35%               | `html<br><picture><source srcset="img.webp" type="image/webp"><img src="img.jpg"></picture>` |
| **AVIF**       | 比 WebP 再小 20-30%（支持 HDR） | `<source srcset="img.avif" type="image/avif">`               |
| **懒加载**     | 延迟加载非首屏图                | `<img src="a.jpg" loading="lazy">`                           |
| **响应式图片** | 根据设备加载不同分辨率          | `<img srcset="small.jpg 480w, large.jpg 1080w" sizes="(max-width:600px) 480px, 1080px" src="large.jpg">` |

------

## 五、进阶优化

| 场景           | 方案                     | 关键点                     |
| -------------- | ------------------------ | -------------------------- |
| **首屏优化**   | Critical CSS / SSR / SSG | 内联关键 CSS，骨架屏       |
| **离线体验**   | Service Worker / PWA     | 缓存资源，支持断网访问     |
| **大计算任务** | Web Worker               | 将计算移出主线程           |
| **长任务优化** | requestIdleCallback      | 浏览器空闲时执行非关键逻辑 |
| **监控指标**   | LCP / FID / CLS          | 核心 Web Vitals 指标       |

------

✅ **优先级落地建议**

1. **图片优化**（WebP/AVIF + 懒加载）
2. **缓存 + 代码拆分**（减少首屏请求）
3. **动画/交互优化**（流畅度提升）
4. **监控 & 持续优化**（Lighthouse / Sentry）
