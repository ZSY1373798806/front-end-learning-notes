## 模块化
### 概念
	就是将一块独立功能的代码，封装成一个独立的文件，在其他模块中按需引入；
### 区别
- commonjs规范
	- 是在运行时加载的，在运行时导出对象；属于浅拷贝；
		运行时加载：
		- 在输入时先加载整个模块，生成一个对象；
		- 再从这个对象上面读取方法；
		- require()是同步加载模块
	- 场景：nodejs
	- 使用：module.exports/require
- es6模块
	- 编译时输出接口
		编译时加载：
		- 引用
		- es6模块不是对象，是通过export命令显式指定输出的代码；
		- import时采用静态命令的形式；
		- 即在import时可以指定加载某个输出值，而不是加载整个模块；
		- import命令时异步加载，有一个独立的模块依赖的解析阶段
	- 使用：export/import
- AMD（require.js）
	- 依赖前置，提前执行
```js
define(["a", "b", "c", "d", "e", "f"], function(a, b, c, d, e, f) { 
    // 等于在最前面声明并初始化了要用到的所有模块
    a.doSomething();
    if (false) {
    	// 即便没用到某个模块 b，但 b 还是提前执行了
    	b.doSomething()
	} 
});
```
- CMD（sea.js）
	- 依赖就近，延迟执行
```js
define(function(require, exports, module) {
    var a = require('./a'); //在需要时申明
    a.doSomething();
    if (false) {
        var b = require('./b');
        b.doSomething();
    }
});
```
- ES Modules
  - 在浏览器中直接使用模块的方式是给script标签设置type=module

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script type="module">
      var hi = "hello, world!";
      console.log(hi);
    </script>
  </body>
</html>
```



### commonjs 如何解决循环引用的

- 案例一
	- 循环引用
```js
    //index.js
    var a = require('./a')
    console.log('入口模块引用a模块：',a)

    // a.js
    exports.a = '原始值-a模块内变量'
    var b = require('./b')
    console.log('a模块引用b模块：',b)
    exports.a = '修改值-a模块内变量'

    // b.js
    exports.b ='原始值-b模块内变量'
    var a = require('./a')
    console.log('b模块引用a模块',a)
    exports.b = '修改值-b模块内变量'

    // 输出结果
    b模块引用a模块：{a: '原始值-a模块内变量'}
    a模块引用b模块：{b: '修改值-b模块内变量'}
    入口模块引用a模块：{a: '修改值-a模块内变量'}
```

	- 执行过程
		- 入口模块开始执行，把入口模块加入缓存
		- 

### ESModule 模块化是怎么解决循环引用的问题的
