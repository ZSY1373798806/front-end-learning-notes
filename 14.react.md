### React核心设计思想

- #### 组件化设计

- #### 声明式编程范式

- #### 高效更新引擎

- #### 单向数据控制


### useEffect 工作原理

useEffect钩子的工作原理涉及到React的渲染流程和副作用的调度机制

- #### 调度副作用

  - 调用 `useEffect(fn, deps)` 时，副作用函数不会立即执行，而是加入队列等待提交阶段执行。

- #### 提交阶段

  - React渲染组件并执行了所有纯函数组件或类组件的渲染方法后，会进入提交阶段
  - 在这个阶段，将计算出的新视图（新的DOM节点）更新到屏幕上
  - 一旦更新完成，React就知道现在可以安全的执行副作用函数了，因为这不会影响到正在屏幕上显示的界面

- #### 副作用执行

  - 初次渲染：所有副作用执行。
  - 更新渲染：
    - 对比依赖数组：
      - 若未变化 → 不执行
      - 若变化或未提供 → 执行

- #### 清理机制

  - `useEffect` 返回函数作为清理函数：
    - 在下一次副作用执行前或组件卸载前执行
    - 防止内存泄漏，撤销上一次副作用的影响

通过这种机制，`useEffect` 允许开发者以一种优化的方式来处理组件中可能存在的副作用，而不需要关心渲染的具体时机。退出清理功能确保了即使组件被多次快速创建和销毁，应用程序也能保持稳定和性能。

- #### 延迟副作用

  - 异步执行，不阻塞浏览器绘制。
  - React 会等浏览器完成屏幕更新后再执行副作用。

### useEffect & useLayoutEffect

- | Hook            | 执行时机                 | 阻塞渲染         |
  | --------------- | ------------------------ | ---------------- |
  | useLayoutEffect | DOM 更新后立即执行       | 会阻塞浏览器绘制 |
  | useEffect       | 浏览器完成绘制后异步执行 | 不阻塞           |


### 性能优化

- #### useCallback

  用于函数的缓存

  等价于 useMemo(() => () => {}, []);

-  #### useMemo

  用户函数结果的缓存

- #### React.memo

  用于组件级缓存，避免不必要的重新渲染(浅比较props)

### 合成事件

- #### 是什么

  - 对 **原生浏览器事件对象的封装**

- #### 合成事件的优势

  - 抹平不同浏览器之间的差异，提供统一的API使用体验
  - 通过事件委托的方式，统一绑定和分发事件，有利于提升性能，减少内存消耗

- #### 合成事件的绑定及分发流程

  - **JSX 中绑定事件**
  
    ```
    <button onClick={handleClick}>Click</button>
    ```
  
    编译后会在 Fiber 节点上记录该事件。
  - **根节点统一监听原生事件**
     React 在 `root` 上通过原生 DOM API (`addEventListener`) 绑定事件（委托）（如 `click`）。
  
  - **事件触发 → 冒泡到 root**
     浏览器原生事件触发后冒泡到 `root`，React 捕获到该事件。
  
  - **dispatchEvent 分发**
     React 内部根据事件类型，找到对应 Fiber 节点及其回调，创建 `SyntheticEvent`（合成事件），并按捕获/冒泡顺序执行。

### 实现一个useState Hook

- 简化实现（基础理解）

```typescript
import { useRef, useReducer } from 'react';
const useState = defaultValue => {
    const value = useRef(defaultValue);
    const [, dispatch] = useReducer(() => ({}), {});
    const setValue = newValue => {
        if (typeof newValue === 'function') {
            value.current = newValue(value.current);
        } else {
            value.current = newValue;
        }
        dispatch();
    }
    return [value.current, setValue];
}
```

- 源码核心

  - useState 是 useReducer 的语法糖。
  - 内部维护 **更新队列**。
  - 每次渲染，执行队列，得到最新 state。

  ```js
  function useState(initialState) {
    const hook = mountWorkInProgressHook();
    if (!hook.memoizedState) hook.memoizedState = initialState;
    const queue = (hook.queue = []);
    function dispatch(action) {
      queue.push(action);
      scheduleUpdateOnFiber(fiber);
    }
    return [hook.memoizedState, dispatch];
  }
  ```

  

### react 架构

- #### Scheduler（调度器）

  - **作用**：负责调度更新任务的 **优先级** 和 **执行时机**，保证高优先级任务（如用户交互）优先执行。

  - **实现方式**：

    - React 采用 **MessageChannel + 时间切片** 实现更稳定的调度机制。

      - 1. **时间切片（time slicing）**

        - 把长任务拆成小片段，每片段大约执行 **5ms** 左右。

        - 每执行完一片，检查主线程是否还有剩余时间：
          - 有 → 继续下一个片段 ；没有 → 把控制权交还浏览器，下次再继续

        👉 这样就能避免长任务一次性占满 16ms（浏览器一帧的预算时间），减少掉帧。

      - 2. **MessageChannel**

      - `MessageChannel` 是浏览器提供的一个宏任务调度 API，比 `setTimeout(fn, 0)` 更高效。
      - React 利用它来“异步调度下一片任务”。
      - 机制：
        - 每次任务片段执行完后，向 `MessageChannel` 发送消息。
        - 消息一到，调度器就继续执行下一个片段。

      👉 这样就形成了一个 **高效的任务循环**。

    - 为什么不用 `requestIdleCallback`，因为：
      - **兼容性差**（Safari 等支持不好）。
      - **触发不稳定**（切换 tab 后触发频率会极低，影响渲染）。

    - 为什么主要用 **宏任务 (MessageChannel)**

      | 特性                  | 微任务（Promise.then / process.nextTick） | 宏任务（setTimeout / MessageChannel） |
      | --------------------- | ----------------------------------------- | ------------------------------------- |
      | 执行时机              | 当前执行栈执行完立即执行                  | 当前任务执行完，浏览器空闲时执行      |
      | 可插入浏览器渲染/事件 | 不行，React无法“中断”                     | 可以，浏览器有机会处理事件和渲染      |
      | 是否可中断            | 否（连续执行完微任务才轮到宏任务）        | 是（两次宏任务之间可让出线程）        |

      ```
      [同步代码执行] 
            ↓
      [微任务队列(Promise.then)] → 执行完立即继续下一微任务
            ↓
      [宏任务队列(MessageChannel)] → 每个 Fiber 任务可被打断
            ↓
      [浏览器渲染 / 用户事件处理]
      ```

      **微任务的问题**

      - 微任务在当前宏任务结束前立即执行。
      - 如果用 Promise.then 执行 Fiber 渲染：
        - 当前宏任务还没结束，微任务就把 Fiber 渲染跑完。
        - 就失去了时间切片的意义，UI还是可能“卡死”。

      **MessageChannel 的优势**

      - MessageChannel 属于宏任务。
      - 每次任务执行完，浏览器有机会中断 Fiber 渲染：
        - 检查剩余时间片
        - 响应用户输入
        - 高优先级任务可打断低优先级更新

    - 这就是 **时间切片** 的关键：利用宏任务切片执行，让更新可被中断。

    - 同步代码 -> 微任务队列 -> 宏任务队列 -> 浏览器渲染/事件处理

  - **结果**：更新任务不会长时间阻塞主线程，提升流畅度。

  #### 优先级调度模型

  > 调度策略：高优先级任务可中断低优先级任务

  | 优先级               | 对应场景                    |
  | -------------------- | --------------------------- |
  | ImmediatePriority    | 同步任务（如 flushSync）    |
  | UserBlockingPriority | 用户交互（点击、输入）      |
  | NormalPriority       | 数据更新、网络响应          |
  | LowPriority          | 过渡更新（Concurrent 模式） |
  | IdlePriority         | 空闲时执行的任务            |

- #### Reconciler（协调器）

  - **作用**：负责找出哪些组件需要更新。
  - **核心机制**：
    
    - 基于 **Fiber 架构**，将组件树拆分为 Fiber 节点（链表结构）。
    - 执行 **Diff 算法**（基于 key + type 进行节点复用），尽可能复用已有 DOM，减少不必要操作。
    - 生成 **Effect List**（副作用链表），把要修改的 DOM 节点、副作用记录下来（如 `Placement/Update/Deletion`）。
  - **阶段**：
    
    - **render 阶段**（可中断）：构建 Fiber 树，标记副作用，不操作 DOM。
    
      - 过程
    
        - 递阶段：`beginWork`，深度优先遍历 Fiber，调用render生成子节点，标记变化
    
          - beginWork【packages\react-reconciler\src\ReactFiberBeginWork.old.js】
    
            ```typescript
            /**
             * current: 当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate
             * workInProgress: 当前组件对应的Fiber节点
             * renderLanes: 优先级相关
             */
            function beginWork(current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes): Fiber | null {
              // ...省略函数体
            }
            ```
    
            
    
          - 先从rootFiber开始向下深度优先遍历，为遍历到的每个Fiber节点调用beginWork方法
    
          - 该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来
    
          - 当遍历到叶子节点（即没有子组件的组件）时就会进入【归】阶段
    
        - 归阶段：`completeWork`，收集副作用，向上回溯收集副作用
    
          - completeWork【packages\react-reconciler\src\ReactFiberCompleteWork.old.js】
          - 在【归】阶段会调用completeWork处理Fiber节点
          - 当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的【递】阶段
          - 如果不存在兄弟Fiber，会进入父级Fiber的【归】阶段
          - 【递】和【归】阶段会交错执行，直到【归】到rootFiber；至此，render阶段的工作就结束了
    - **commit 阶段**（不可中断）：批量提交 Effect List → 一次性完成 DOM 变更，由 Renderer 执行真实更新，真正修改 DOM。
    
      - 过程
    
        - #### Renderer（渲染器）流程
    

- #### Renderer（渲染器）

  - **作用**：把 Reconciler 找到的变化，真正渲染到宿主环境（DOM、Native、Canvas）。
  - **解决办法**：
    - 遍历Effect List，把每个副作用翻译成宿主环境能理解的 原生API 调用。
    - 不同环境对应不同 Renderer：
      - `react-dom` → 浏览器 DOM
      - `react-native` → 原生控件
      - `react-three-fiber` → WebGL 场景
      - 甚至可以自定义 Renderer（基于 `react-reconciler` 包）
  - **流程**：
    - **Before mutation**：
      - 执行 `getSnapshotBeforeUpdate`（让开发者在 DOM 变化前拿到快照，例如滚动条位置）；此时DOM还没改。
      - 返回值会传给 **`componentDidUpdate`**，更新后你就能用它来做修正。
    - **Mutation**：应用 DOM 更新（插入、删除、更新属性）。
    - **Layout**：执行 `componentDidMount` / `componentDidUpdate`、执行 `useLayoutEffect`。

- ## 📌 总结一句话

  React 架构就像 **流水线**：

  - **Scheduler** → 什么时候干？（分优先级 + 执行时机 + 时间切片）
  - **Reconciler** → 干什么？（哪些组件需要更新 计算差异 + 构建 Fiber 树 + 生成 Effect List）
  - **Renderer** → 怎么干？（调用宿主 API → 更新 DOM/Native/Canvas）

### Fiber

#### 背景

- ##### 旧版协调算法瓶颈

  - 递归不可中断

    同步遍历整个虚拟DOM树，长时间占用主线程

  - 卡顿问题

    复杂组件树更新导致掉帧（如大型列表，动画场景）

- ##### 目标

  - 实现增量渲染，支持异步可中断的更新；React 18 开启 **并发渲染**（Concurrent Mode），Fiber 真正发挥作用。

#### 核心设计思想

- ##### 时间切片

  - 将渲染任务拆分为多个小任务（Fiber节点）
  - 利用浏览器空闲时段（requestIdleCallback）分片执行

- ##### 优先级调度

  - 用户交互（如输入）优先于数据更新（如API响应）

- ##### 可恢复工作单元

  - 保存中间状态，允许暂停/恢复渲染流程

- ##### Fiber节点数据结构

  > 每个Fiber节点对应一个组件实例或DOM节点，包含一下核心属性

| 属性          | 类型          | 作用                                         |
| ------------- | ------------- | -------------------------------------------- |
| type          | String/Object | 组件类型（如 'div'、函数组件引用）           |
| stateNode     | Object        | 对应的真实 DOM 节点或类组件实例              |
| child         | Fiber         | 第一个子节点                                 |
| sibling       | Fiber         | 下一个兄弟节点                               |
| return        | Fiber         | 父节点                                       |
| pendingProps  | Object        | 新传入的 props                               |
| memoizedProps | Object        | 上一次渲染使用的 props                       |
| memoizedState | Object        | 上一次渲染后的 state（如 Hooks 链表）        |
| effectTag     | Number        | 标记副作用（如 Placement、Update、Deletion） |
| alternate     | Fiber         | 指向当前 Fiber 的镜像（用于 Diff 比较）      |

## Fiber 双缓冲机制概述

React 为了实现**高效增量更新和可中断渲染**，使用了 **双缓冲（Double Buffering）**机制，维护 **两棵 Fiber 树**：

| 树                      | 作用                                                      |
| ----------------------- | --------------------------------------------------------- |
| **Current Tree**        | 当前已渲染的 UI 对应的 Fiber 树，保证用户界面始终完整可用 |
| **WorkInProgress Tree** | 正在构建的新 Fiber 树，用于执行更新（diff & render）      |

> 这样可以在更新过程中，保证用户看到的 UI 不会出现半更新状态。

## 更新流程

1. **创建 WorkInProgress Tree**

   - React 根据 Current Tree 克隆出 WorkInProgress Tree。
   - WorkInProgress Tree 会承载新的状态、props 等更新。

2. **调度 & 执行渲染**

   - React 对 WorkInProgress Tree 执行 **reconciliation（协调/diff）**。
   - 找出哪些节点需要更新、替换或删除。

3. **提交（Commit）阶段**

   - 将 WorkInProgress Tree 的变化应用到 **DOM 或宿主环境**。
   - 此时 DOM 更新是**批量的、同步的**。

4. **切换 Fiber 树**

   - 提交完成后：

     ```
     Current Tree ← WorkInProgress Tree
     ```

   - 也就是说，新的 Fiber 树成为当前 UI 的真实映射。

   - 旧的 Current Tree 可以被垃圾回收。

------

## 双缓冲的好处

- **避免 UI 闪烁或不一致**
   更新期间 Current Tree 仍可使用，保证界面完整。
- **支持可中断渲染**
   WorkInProgress Tree 可以被拆分成小任务（time slicing），允许浏览器处理高优先级事件。
- **高性能增量更新**
   只对需要更新的节点进行操作，减少 DOM 变更。

#### Fiber渲染

- ##### 整个更新流程

  其中红框部分的步骤随时可能由于以下原因被中断

  - 有其他更高优任务需要先更新
  - 当前帧没有剩余时间

> 由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM

<img src="https://react.iamkasong.com/img/v15.png" alt="更新流程" style="zoom: 33%;" />

<img src="https://react.iamkasong.com/img/process.png" alt="更新流程" style="zoom:33%;" />

```react
function App() {
  return (
    <div>
      i am
      <span>KaSong</span>
    </div>
  )
}
```

对应Fiber树结构

<img src="https://react.iamkasong.com/img/fiber.png" alt="Fiber架构" style="zoom: 25%;" />

render阶段会依次执行

```js
1. rootFiber beginWork
2. App Fiber beginWork
3. div Fiber beginWork
4. "i am" Fiber beginWork
5. "i am" Fiber completeWork
6. span Fiber beginWork
7. span Fiber completeWork
8. div Fiber completeWork
9. App Fiber completeWork
10. rootFiber completeWork
```

> 之所以没有 “KaSong” Fiber 的 beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的`Fiber`，`React`会特殊处理。

#### Fiber对生命周期的影响

- 废弃生命周期

  - `componentWillMount`、`componentWillReceiveProps`、`componentWillUpdate`

  - **原因**：Fiber 支持异步可中断渲染，如果这些生命周期多次调用可能产生副作用，破坏 UI 状态。

- 新增 API
  - `getDerivedStateFromProps`（静态方法，替代 `componentWillReceiveProps`）
  - `getSnapshotBeforeUpdate`（替代 `componentWillUpdate`，在 DOM 更新前获取快照）

## Fiber 与并发模式（Concurrent Mode）

### 主要特性

1. **useTransition**

   - 标记低优先级更新（Transition），可被高优先级任务打断。

   - 核心逻辑：

     ```js
     function startTransition(scope) {
       const prevPriority = getCurrentPriority();
       setCurrentPriority(TransitionPriority); // 降级
       try { scope(); } finally { setCurrentPriority(prevPriority); }
     }
     ```

   - 用于切换 tab、路由等非紧急更新。

2. **Suspense**

   - 异步组件或数据未加载完成时，显示 fallback UI。

   - 原理：

     ```js
     try { render(child); } 
     catch (promise) {
       if (promise instanceof Promise) {
         markFiberSuspended(fiber);
         showFallback();
         promise.then(() => retryRender(fiber));
       }
     }
     ```

   - Fiber 捕获 Promise → 挂起当前子树 → 渲染 fallback → Promise resolve 后恢复渲染。

### 启用方式

```js
ReactDOM.createRoot(document.getElementById('root')).render(<App />);
```


### React 更新流程（Patch 流程）

- **setState** 或 props 更新触发渲染。

  **Reconciler** 调用 render，生成新的 Fiber。

  **Scheduler** 根据车道模型（Lane）调度任务：

  - 每个 Fiber 生成任务可异步执行。
  - 用 `MessageChannel + 时间切片` 检查剩余时间片。
  - 如果时间不足，可中断任务，将剩余 Fiber 推迟到下一个渲染帧。
- Render 阶段完成后，触发 **Commit 阶段** → 更新 DOM（Patch）。

### react的diff算法

- #### 单节点diff

  - 老 Fiber 不存在 → 新增节点。
  - key 不同 → 删除老节点，新增。
  - type 不同 → 删除老节点，新增。
  - type 相同 → 可复用。

- #### 多节点diff

  - 双重遍历 children[i] vs oldFiber

    三种情况：
  
    1. 新增节点 → children 剩余
    2. 删除节点 → oldFiber 剩余
    3. 移动节点 → key 匹配但位置改变

### setState之后，发生了哪些事情

setState就是触发组件的一次渲染过程

- setState 更新状态。

- Reconciler 执行 render 生成新 Fiber。

- Scheduler 按优先级调度 Fiber 创建任务。

- Diff 算法对比新旧 Fiber。

- Commit 阶段更新 DOM。

### Hook核心原理

- #### 闭包与链表存储

  - 存储结构

    Hooks数据存储在Fiber节点的memoizedState属性中，通过单向链表管理

  - 执行顺序依赖

    Hooks调用顺序在每次渲染中必须严格一致（链表顺序不可变）

  - 闭包陷阱

    每个Hooks闭包捕获单次渲染的props/state快照

```js
// Fiber 节点结构示意
const fiber = {
  memoizedState: {
    memoizedState: '状态值',    // useState 的状态
    next: {                   // 下一个 Hook
      memoizedState: [],      // useEffect 的依赖数组
      next: null
    }
  },
  type,           // 组件类型
  pendingProps,   // 新的 props
  memoizedProps,  // 上一次渲染的 props
  child, sibling, return, // 形成链表结构
  flags,          // 副作用标记
};
```

- #### 调度机制

  - 优先级调度

    Hooks更新请求会被Scheduler模块根据优先级（Immediate/UserBlocking/Normal）排队处理

  - 批量更新

    React自动合并多个setState调用，减少渲染次数

#### useTransition  & useDeferredValue 

- `useTransition`：把某次更新标记为低优先级（适合切换 tab、路由跳转）。

- `useDeferredValue`：延迟某个值的更新（适合输入搜索框时，延迟大列表渲染）。

### React源码的文件结构

```bash
react/
 ├── packages/
 │    ├── react/                # 核心 API
 │    ├── react-dom/            # DOM Renderer
 │    ├── react-reconciler/     # Reconciler 实现
 │    ├── scheduler/            # Scheduler 调度器
 │    ├── react-native-renderer # 原生渲染
 │    └── shared/               # 公用工具和符号
 ├── scripts/                   # 构建工具
 ├── fixtures/                  # 测试示例
 └── build/

```

