### React核心设计思想

- #### 组件化设计

- #### 声明式编程范式

- #### 高效更新引擎

- #### 单向数据控制


### useEffect 工作原理

useEffect钩子的工作原理涉及到React的渲染流程和副作用的调度机制

- #### 调度副作用

  - 调用 `useEffect(fn, deps)` 时，副作用函数不会立即执行，而是加入队列等待提交阶段执行。

- #### 提交阶段

  - React渲染组件并执行了所有纯函数组件或类组件的渲染方法后，会进入提交阶段
  - 在这个阶段，将计算出的新视图（新的DOM节点）更新到屏幕上
  - 一旦更新完成，React就知道现在可以安全的执行副作用函数了，因为这不会影响到正在屏幕上显示的界面

- #### 副作用执行

  - 初次渲染：所有副作用执行。
  - 更新渲染：
  - 对比依赖数组：
    - 若未变化 → 不执行
    - 若变化或未提供 → 执行

- #### 清理机制

  - `useEffect` 返回函数作为清理函数：
    - 在下一次副作用执行前或组件卸载前执行
    - 防止内存泄漏，撤销上一次副作用的影响

通过这种机制，`useEffect` 允许开发者以一种优化的方式来处理组件中可能存在的副作用，而不需要关心渲染的具体时机。退出清理功能确保了即使组件被多次快速创建和销毁，应用程序也能保持稳定和性能。

- #### 延迟副作用

  - 异步执行，不阻塞浏览器绘制。
  - React 会等浏览器完成屏幕更新后再执行副作用。

### useEffect & useLayoutEffect

- | Hook            | 执行时机                 | 阻塞渲染         |
  | --------------- | ------------------------ | ---------------- |
  | useLayoutEffect | DOM 更新后立即执行       | 会阻塞浏览器绘制 |
  | useEffect       | 浏览器完成绘制后异步执行 | 不阻塞           |


### 性能优化

- #### useCallback

  用于函数的缓存

  等价于 useMemo(() => () => {}, []);

-  #### useMemo

  用户函数结果的缓存

- #### React.memo

  用于组件记缓存，避免不必要的重新渲染(浅比较props)

### 合成事件

- #### 合成事件的优势

  - 抹平不同浏览器直接的差异，提供统一的API使用体验
  - 通过事件委托的方式，统一绑定和分发事件，有利于提升性能，减少内存消耗

- #### 合成事件的绑定及分发流程

  - React 根节点绑定原生事件（委托）。
  - JSX 解析组件绑定事件 → 映射 Fiber 节点。
  - 用户事件冒泡至根节点 → dispatchEvent 派发。
  - 根据 Fiber 找到对应回调队列执行。

### 实现一个useState Hook

- 简化实现（基础理解）

```typescript
import { useRef, useReducer } from 'react';
const useState = defaultValue => {
    const value = useRef(defaultValue);
    const [, dispatch] = useReducer(() => ({}), {});
    const setValue = newValue => {
        if (typeof newValue === 'function') {
            value.current = newValue(value.current);
        } else {
            value.current = newValue;
        }
        dispatch();
    }
    return [value.current, setValue];
}
```

- 源码核心

  - useState 是 useReducer 的语法糖。
  - 内部维护 **更新队列**。
  - 每次渲染，执行队列，得到最新 state。

  ```js
  function useState(initialState) {
    const hook = mountWorkInProgressHook();
    if (!hook.memoizedState) hook.memoizedState = initialState;
    const queue = (hook.queue = []);
    function dispatch(action) {
      queue.push(action);
      scheduleUpdateOnFiber(fiber);
    }
    return [hook.memoizedState, dispatch];
  }
  ```

  

### react 架构

- #### Scheduler（调度器）

  - **作用**：负责调度更新任务的 **优先级** 和 **执行时机**，保证高优先级任务（如用户交互）优先执行。
  - **实现方式**：
    - React 没有直接用 `requestIdleCallback`，因为：
      - **兼容性差**（Safari 等支持不好）。
      - **触发不稳定**（切换 tab 后触发频率会极低，影响渲染）。
    - React 采用 **MessageChannel + 时间切片** 实现更稳定的调度机制。
  - **结果**：更新任务不会长时间阻塞主线程，提升流畅度。

  #### 优先级调度模型

  > 调度策略：高优先级任务可中断低优先级任务

  | 优先级               | 对应场景                    |
  | -------------------- | --------------------------- |
  | ImmediatePriority    | 同步任务（如 flushSync）    |
  | UserBlockingPriority | 用户交互（点击、输入）      |
  | NormalPriority       | 数据更新、网络响应          |
  | LowPriority          | 过渡更新（Concurrent 模式） |
  | IdlePriority         | 空闲时执行的任务            |

- #### Reconciler（协调器）

  - **作用**：负责找出哪些组件需要更新。
  - **核心机制**：
    - 基于 **Fiber 架构**，将组件树拆分为 Fiber 节点（链表结构）。
    - 执行 **Diff 算法**（基于 key + type 进行节点复用）。
    - 生成 **Effect List**（副作用链表），描述哪些地方需要变动。
  - **特点**：
    - **render 阶段**（可中断）：构建 Fiber 树，标记副作用，不操作 DOM。
    - **commit 阶段**（不可中断）：由 Renderer 执行真实更新，真正修改 DOM。

- #### Renderer（渲染器）

  - **作用**：把 Reconciler 找到的变化，真正渲染到宿主环境（DOM、Native、Canvas）。
  - **流程**：
    - **Before mutation**：执行 `getSnapshotBeforeUpdate`。
    - **Mutation**：应用 DOM 更新（插入、删除、更新属性）。
    - **Layout**：执行 `useLayoutEffect`。
  - **可扩展性**：
    - ReactDOM → 渲染到浏览器 DOM
    - React Native → 渲染到原生控件
    - 也可以自定义 Renderer（基于 React Reconciler 包）。

### Fiber

#### 背景

- ##### 旧版协调算法瓶颈

  - 递归不可中断

    同步遍历整个虚拟DOM树，长时间占用主线程

  - 卡顿问题

    复杂组件树更新导致掉帧（如大型列表，动画场景）

- ##### 目标

  - 实现增量渲染，支持异步可中断的更新；React 18 开启 **并发渲染**，Fiber 真正发挥作用。

#### 核心设计思想

- ##### 时间切片

  - 将渲染任务拆分为多个小任务（Fiber节点）
  - 利用浏览器空闲时段（requestIdleCallback）分片执行

- ##### 优先级调度

  - 用户交互（如输入）优先于数据更新（如API响应）

- ##### 可恢复工作单元

  - 保存中间状态，允许暂停/恢复渲染流程

- ##### Fiber节点数据结构

  > 每个Fiber节点对应一个组件实例或DOM节点，包含一下核心属性

| 属性          | 类型          | 作用                                         |
| ------------- | ------------- | -------------------------------------------- |
| type          | String/Object | 组件类型（如 'div'、函数组件引用）           |
| stateNode     | Object        | 对应的真实 DOM 节点或类组件实例              |
| child         | Fiber         | 第一个子节点                                 |
| sibling       | Fiber         | 下一个兄弟节点                               |
| return        | Fiber         | 父节点                                       |
| pendingProps  | Object        | 新传入的 props                               |
| memoizedProps | Object        | 上一次渲染使用的 props                       |
| memoizedState | Object        | 上一次渲染后的 state（如 Hooks 链表）        |
| effectTag     | Number        | 标记副作用（如 Placement、Update、Deletion） |
| alternate     | Fiber         | 指向当前 Fiber 的镜像（用于 Diff 比较）      |

- ##### Fiber双缓冲机制

  > React维护两颗Fiber树：保证渲染过程中Current Tree始终完整可用，避免更新过程中出现UI不一致

  - Current Tree：当前已渲染的UI对应的Fiber树
  - WorkInProgress Tree：正在构建的新Fiber树

  > 切换流程：更新完成后，workInProgress Tree树变成Current树

  ```text
  初始渲染：
  Current Tree: null
  WorkInProgress Tree: → 构建完成 → 提交后成为 Current Tree
  
  更新阶段：
  Current Tree ←→ WorkInProgress Tree（复用或新建节点） 
  ```

  > 两颗树通过alternate属性连接

  ```js
  currentFiber.alternate === workInProgressFiber;
  workInProgressFiber.alternate === currentFiber;
  ```

#### Fiber渲染

- ##### render阶段

  - 目标

    - 生成副作用列表，不修改DOM；负责计算变更

  - 过程

    - 递阶段：`beginWork`，深度优先遍历 Fiber，调用render生成子节点，标记变化

      - beginWork【packages\react-reconciler\src\ReactFiberBeginWork.old.js】

        ```typescript
        /**
         * current: 当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate
         * workInProgress: 当前组件对应的Fiber节点
         * renderLanes: 优先级相关
         */
        function beginWork(current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes): Fiber | null {
          // ...省略函数体
        }
        ```

        

      - 先从rootFiber开始向下深度优先遍历，为遍历到的每个Fiber节点调用beginWork方法

      - 该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来

      - 当遍历到叶子节点（即没有子组件的组件）时就会进入【归】阶段

    - 归阶段：`completeWork`，收集副作用，向上回溯收集副作用

      - completeWork【packages\react-reconciler\src\ReactFiberCompleteWork.old.js】
      - 在【归】阶段会调用completeWork处理Fiber节点
      - 当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的【递】阶段
      - 如果不存在兄弟Fiber，会进入父级Fiber的【归】阶段
      - 【递】和【归】阶段会交错执行，直到【归】到rootFiber；至此，render阶段的工作就结束了

  - 可中断

    - 根据剩余时间片暂停/恢复遍历

- ##### commit阶段

  - 目标
    - 同步执行所有DOM变更；执行DOM操作， 执行 layout effect
  - 过程
    - Before Mutation：调用getSnapshotBeforeUpdate
    - Mutation：执行DOM增删改
    - Layout：调用useLayoutEffect和componentDidMount/Update
  - 不可中断
    - 避免中间状态导致UI不一致

- ##### 整个更新流程

  其中红框部分的步骤随时可能由于一下原因被中断

  - 有其他更高优任务需要先更新
  - 当前帧没有剩余时间

> 由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM

<img src="https://react.iamkasong.com/img/v15.png" alt="更新流程" style="zoom: 33%;" />

<img src="https://react.iamkasong.com/img/process.png" alt="更新流程" style="zoom:33%;" />

```react
function App() {
  return (
    <div>
      i am
      <span>KaSong</span>
    </div>
  )
}
```

对应Fiber树结构

<img src="https://react.iamkasong.com/img/fiber.png" alt="Fiber架构" style="zoom: 25%;" />

render阶段会依次执行

```js
1. rootFiber beginWork
2. App Fiber beginWork
3. div Fiber beginWork
4. "i am" Fiber beginWork
5. "i am" Fiber completeWork
6. span Fiber beginWork
7. span Fiber completeWork
8. div Fiber completeWork
9. App Fiber completeWork
10. rootFiber completeWork
```

> 之所以没有 “KaSong” Fiber 的 beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的`Fiber`，`React`会特殊处理。

#### Fiber对生命周期的影响

- ##### 废弃生命周期

  - `componentWillMount、componentWillReceiveProps、componentWillUpdate`
  - 原因：异步可渲染可能导致多次调用，引发副作用错误

- ##### 新增API

  - getDerivedStateFromProps（静态方法，代替componentWillReceiveProps）
  - getSnapshotBeforeUpdate（代替componentWillUpdate）

#### Fiber 与 并发模式（Concurrent Mode）

- ##### 并发特性

  - useTranstion：标记非紧急更新，可被高优先级任务打断

    ```js
    // startTransition 源码核心
    function startTransition(scope) {
      const prevPriority = getCurrentPriority();
      setCurrentPriority(TransitionPriority); // 降级
      try {
        scope();
      } finally {
        setCurrentPriority(prevPriority); // 恢复
      }
    }
    
    useTransition 内部通过 startTransition 把更新标记为 Transition 优先级，这类任务会被调度器延后，避免阻塞交互。
    ```

    

  - Suspense：等待异步数据加载时显示回退UI

    - 原理
      - 当子组件抛出一个 Promise，React 捕获后进入“挂起”状态。
      - 在 Fiber 上打上 `Suspended` 标记，渲染 fallback UI。
      - 等 Promise resolve 后，再恢复渲染子树。

    ```js
    // Suspense 关键逻辑
    try {
      render(child);
    } catch (promise) {
      if (promise instanceof Promise) {
        markFiberSuspended(fiber);
        showFallback();
        promise.then(() => retryRender(fiber));
      }
    }
    
    Suspense 依赖“抛 Promise”机制，Fiber 捕获后挂起当前子树，渲染 fallback，等数据回来再恢复渲染。
    ```

    

- ##### 启用方式

```js
// 创建根节点时启用
ReactDOM.createRoot(document.getElementById('root')).render(<App />);
```


### react的patch流程

- react有一个Scheduler调度器，主要用于调度fiber节点的生成和更新任务
- 当组件更新时，Reconciler协调器执行组件的render方法，生成一个fiber节点之后，再递归的去生成fiber节点的子节点
- 每个fiber的生成都是一个单独的任务，会医回调的形式交给Scheduler进行调度处理，在Scheduler里会根据任务的优先级去执行任务
- 任务的优先级的指定是根据【车道模型】，将任务进行分类，每一类拥有不同的优先级，所有的分类和优先级都在react中进行了枚举
- Scheduler按照优先级执行任务时，会异步的执行，同时没一个任务执行完成之后，都会通过requestIdleCallback去判断下一个任务是否能在当前渲染的剩余时间内完成
- 如果不能完成就发生中断，把线程的控制权交给浏览器，剩下的任务则在下一个渲染帧内执行
- 整个Reconciler和Scheduler的任务执行完成之后，会生成一个新的workInProgressFiber节点数，之后Reconciler触发Commit阶段通知Render渲染器去进行diff操作，就是所谓的patch流程

### react的diff算法

- #### 单节点diff

  - 老 Fiber 不存在 → 新增节点。
  - key 不同 → 删除老节点，新增。
  - type 不同 → 删除老节点，新增。
  - type 相同 → 可复用。

- #### 多节点diff

  多节点的Diff操作主要用于map返回多个相同节点的情况下，可以分为三种情况：新增节点、删除节点以及节点移动，React采用双重遍历的方式来进行三种情况的判断，流程如下：

  - 第一轮遍历：顺序对比 children[i] 和 currentFiber。
  - 结束遍历 → 都可复用 → 直接返回。
  - 剩余 children → 新增节点。
  - 剩余 oldFiber → 删除节点。
  - 节点移动 → key 匹配，位置替换。

### setState之后，发生了哪些事情

setState就是触发组件的一次渲染过程

- setState 更新状态。

- Reconciler 执行 render 生成新 Fiber。

- Scheduler 按优先级调度 Fiber 创建任务。

- Diff 算法对比新旧 Fiber。

- Commit 阶段更新 DOM。

### Hook核心原理

- #### 闭包与链表存储

  - 存储结构

    Hooks数据存储在Fiber节点的memoizedState属性中，通过单向链表管理

  - 执行顺序依赖

    Hooks调用顺序在每次渲染中必须严格一致（链表顺序不可变）

  - 闭包陷阱

    每个Hooks闭包捕获单次渲染的props/state快照

```js
// Fiber 节点结构示意
const fiber = {
  memoizedState: {
    memoizedState: '状态值',    // useState 的状态
    next: {                   // 下一个 Hook
      memoizedState: [],      // useEffect 的依赖数组
      next: null
    }
  },
  type,           // 组件类型
  pendingProps,   // 新的 props
  memoizedProps,  // 上一次渲染的 props
  child, sibling, return, // 形成链表结构
  flags,          // 副作用标记
};
```

- #### 调度机制

  - 优先级调度

    Hooks更新请求会被Scheduler模块根据优先级（Immediate/UserBlocking/Normal）排队处理

  - 批量更新

    React自动合并多个setState调用，减少渲染次数

#### useTransition  & useDeferredValue 

- `useTransition`：把某次更新标记为低优先级（适合切换 tab、路由跳转）。

- `useDeferredValue`：延迟某个值的更新（适合输入搜索框时，延迟大列表渲染）。

### React源码的文件结构

```bash
react/
 ├── packages/
 │    ├── react/                # 核心 API
 │    ├── react-dom/            # DOM Renderer
 │    ├── react-reconciler/     # Reconciler 实现
 │    ├── scheduler/            # Scheduler 调度器
 │    ├── react-native-renderer # 原生渲染
 │    └── shared/               # 公用工具和符号
 ├── scripts/                   # 构建工具
 ├── fixtures/                  # 测试示例
 └── build/

```

